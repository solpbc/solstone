<style>
/* Settings app - vertical nav layout */
.settings-wrap {
  display: flex;
  min-height: calc(100vh - var(--facet-bar-height, 60px) - 40px);
  max-width: 1200px;
  margin: 0 auto;
  padding: 1em;
  gap: 2em;
}

/* Left navigation */
.settings-nav {
  width: 200px;
  flex-shrink: 0;
  position: sticky;
  top: calc(var(--facet-bar-height, 60px) + 1em);
  align-self: flex-start;
  max-height: calc(100vh - var(--facet-bar-height, 60px) - 2em);
  overflow-y: auto;
}

.settings-nav-group {
  margin-bottom: 1.5em;
}

.settings-nav-label {
  font-size: 0.75em;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: #888;
  padding: 0 0.75em;
  margin-bottom: 0.5em;
}

.settings-nav-item {
  display: block;
  width: 100%;
  padding: 0.6em 0.75em;
  border: none;
  background: none;
  text-align: left;
  font-size: 0.95em;
  color: #333;
  cursor: pointer;
  border-radius: 6px;
  transition: background 0.15s;
}

.settings-nav-item:hover {
  background: #f0f0f0;
}

.settings-nav-item.active {
  background: var(--facet-color, #1a73e8);
  color: white;
  font-weight: 600;
}

/* Mobile nav dropdown */
.settings-nav-mobile {
  display: none;
  margin-bottom: 1em;
}

.settings-nav-select {
  width: 100%;
  padding: 0.75em 1em;
  font-size: 1em;
  border: 1px solid #ddd;
  border-radius: 8px;
  background: white;
  cursor: pointer;
}

/* Right content panel */
.settings-content {
  flex: 1;
  min-width: 0;
  max-width: 600px;
}

.settings-section {
  display: none;
}

.settings-section.active {
  display: block;
  animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.settings-section h2 {
  font-size: 1.4em;
  font-weight: 600;
  color: #333;
  margin: 0 0 0.5em 0;
}

.settings-section-desc {
  color: #666;
  font-size: 0.9em;
  margin-bottom: 1.5em;
  line-height: 1.4;
}

/* Form fields */
.settings-field {
  margin-bottom: 1.5em;
}

.settings-field label {
  display: block;
  font-weight: 600;
  color: #333;
  margin-bottom: 0.4em;
  font-size: 0.95em;
}

.settings-field input,
.settings-field textarea,
.settings-field select {
  width: 100%;
  padding: 0.6em 0.75em;
  border: 2px solid #ddd;
  border-radius: 8px;
  font-size: 0.95em;
  font-family: inherit;
  transition: border-color 0.2s, box-shadow 0.2s;
  box-sizing: border-box;
}

.settings-field input:focus,
.settings-field textarea:focus,
.settings-field select:focus {
  outline: none;
  border-color: var(--facet-color, #667eea);
  box-shadow: 0 0 0 3px var(--facet-bg, rgba(102, 126, 234, 0.1));
}

.settings-field textarea {
  resize: vertical;
  min-height: 60px;
}

.settings-field small {
  display: block;
  margin-top: 0.3em;
  color: #666;
  font-size: 0.85em;
  line-height: 1.4;
  transition: opacity 0.3s ease;
}

/* Inline save status - replaces helper text temporarily */
.settings-field small.status-saved {
  color: #166534;
}

.settings-field small.status-saved::before {
  content: '✓ ';
}

.settings-field small.status-error {
  color: #991b1b;
}

.settings-field small.status-error::before {
  content: '✕ ';
}

.settings-field small.status-fade {
  opacity: 0;
}

/* API key status indicators */
.key-status {
  font-weight: normal;
  margin-left: 0.3em;
}

.key-status-journal {
  color: #28a745;
}

.key-status-system {
  color: #6c757d;
  font-size: 0.85em;
}

/* Password field with toggle */
.password-wrap {
  position: relative;
}

.password-wrap input {
  padding-right: 3em;
}

.password-toggle {
  position: absolute;
  right: 0.5em;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  padding: 0.5em;
  cursor: pointer;
  color: #666;
  font-size: 1.1em;
}

.password-toggle:hover {
  color: #333;
}

/* Facet appearance section */
.facet-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5em;
}

.toggle-container {
  display: flex;
  align-items: center;
  gap: 0.75em;
}

.toggle-label {
  font-weight: 600;
  font-size: 0.95em;
  color: #333;
  min-width: 60px;
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 52px;
  height: 28px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #28a745;
  transition: 0.3s;
  border-radius: 28px;
}

.slider:before {
  position: absolute;
  content: "";
  height: 22px;
  width: 22px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: 0.3s;
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

input:checked + .slider {
  background-color: #6c757d;
}

input:checked + .slider:before {
  transform: translateX(24px);
}

/* Positive toggle: green when checked (for enable/active states) */
.toggle-switch.toggle-positive .slider {
  background-color: #6c757d;
}

.toggle-switch.toggle-positive input:checked + .slider {
  background-color: #28a745;
}

/* Editable fields (double-tap to edit) */
.editable-field {
  min-height: 2.5em;
  display: flex;
  align-items: center;
}

.editable-field .field-display {
  cursor: pointer;
  padding: 0.6em 0.75em;
  border: 2px solid transparent;
  border-radius: 8px;
  transition: all 0.2s;
  flex: 1;
  min-height: 2.5em;
  display: flex;
  align-items: center;
}

.editable-field .field-display:hover {
  background: #f5f5f5;
  border-color: #ddd;
}

.editable-field .field-input {
  width: 100%;
  padding: 0.6em 0.75em;
  border: 2px solid var(--facet-color, #667eea);
  border-radius: 8px;
  font-size: 0.95em;
  font-family: inherit;
}

/* Emoji picker */
.emoji-display {
  font-size: 3em;
  cursor: pointer;
  display: inline-block;
  padding: 0.2em 0.3em;
  border-radius: 12px;
  transition: all 0.2s;
  user-select: none;
  width: fit-content;
}

.emoji-display:hover {
  transform: scale(1.1);
  background: #f5f5f5;
}

.emoji-input {
  width: 100%;
  max-width: 200px;
  padding: 0.6em 0.75em;
  border: 2px solid #ddd;
  border-radius: 8px;
  font-size: 1.2em;
  text-align: center;
}

/* Color picker */
.color-picker-trigger {
  display: flex;
  align-items: center;
  gap: 1em;
  cursor: pointer;
  padding: 0.6em 0.75em;
  border: 2px solid #ddd;
  border-radius: 8px;
  width: fit-content;
  transition: all 0.2s;
}

.color-picker-trigger:hover {
  background: #f5f5f5;
  border-color: #999;
}

.color-preview {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  border: 2px solid #ddd;
}

.color-picker-trigger span {
  font-family: monospace;
  font-size: 1em;
  font-weight: 600;
}

/* Color picker modal */
.color-modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
}

.color-modal-content {
  background: white;
  margin: 5% auto;
  padding: 2em;
  border-radius: 12px;
  max-width: 500px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.3);
  position: relative;
}

.color-close {
  position: absolute;
  right: 1em;
  top: 1em;
  font-size: 2em;
  font-weight: bold;
  color: #999;
  cursor: pointer;
  line-height: 1;
}

.color-close:hover {
  color: #333;
}

.color-modal h3 {
  margin: 0 0 1.5em 0;
  color: #333;
}

.color-swatches {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 0.75em;
  margin-bottom: 1.5em;
}

.color-swatch {
  width: 100%;
  aspect-ratio: 1;
  border-radius: 8px;
  cursor: pointer;
  border: 3px solid transparent;
  transition: all 0.2s;
}

.color-swatch:hover {
  transform: scale(1.1);
  border-color: #333;
}

.color-swatch.selected {
  border-color: #000;
  box-shadow: 0 0 0 2px #fff, 0 0 0 5px #000;
}

.custom-color {
  margin-bottom: 1.5em;
}

.custom-color label {
  display: block;
  font-weight: 600;
  margin-bottom: 0.5em;
  color: #333;
}

.color-input-group {
  display: flex;
  gap: 0.75em;
  align-items: center;
}

.custom-color input[type="color"] {
  width: 60px;
  height: 45px;
  padding: 0.2em;
  border: 2px solid #ddd;
  border-radius: 8px;
  cursor: pointer;
}

.custom-color input[type="text"] {
  flex: 1;
  padding: 0.6em 0.75em;
  border: 2px solid #ddd;
  border-radius: 8px;
  font-family: monospace;
  font-size: 1em;
}

.color-preview-section {
  padding: 1em;
  background: #f8f8f8;
  border-radius: 8px;
  margin-bottom: 1.5em;
}

.color-preview-section h4 {
  margin: 0 0 0.75em 0;
  color: #333;
  font-size: 0.9em;
}

.modal-preview-pill {
  display: inline-flex;
  align-items: center;
  gap: 0.5em;
  padding: 0.6em 1.2em;
  border-radius: 20px;
  border: 2px solid #667eea;
  background: rgba(102, 126, 234, 0.1);
  font-weight: 500;
}

.modal-preview-emoji {
  font-size: 1.3em;
}

.save-color-btn {
  width: 100%;
  padding: 0.75em 1.5em;
  background: var(--facet-color, #667eea);
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 1em;
  font-weight: 600;
  cursor: pointer;
  transition: opacity 0.2s;
}

.save-color-btn:hover {
  opacity: 0.9;
}

/* Activity log */
.log-panel {
  background: #fafafa;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
}

.log-header {
  padding: 0.75em 1em;
  border-bottom: 1px solid #e0e0e0;
  font-weight: 600;
  font-size: 0.9em;
  color: #555;
}

.log-entries {
  padding: 0.5em 0;
  max-height: 400px;
  overflow-y: auto;
}

.log-empty {
  padding: 2em 1em;
  text-align: center;
  color: #999;
  font-size: 0.9em;
}

.log-day {
  display: flex;
  align-items: center;
  gap: 0.75em;
  padding: 0.5em 1em;
  margin: 0.25em 0;
}

.log-day-line {
  flex: 1;
  height: 1px;
  background: #ddd;
}

.log-day-label {
  font-size: 0.75em;
  color: #888;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.log-row {
  display: flex;
  align-items: center;
  gap: 0.5em;
  padding: 0.35em 1em;
  font-size: 0.85em;
}

.log-row:hover {
  background: #f0f0f0;
}

.log-icon {
  font-size: 0.9em;
}

.log-action {
  color: #333;
  font-weight: 500;
}

.log-actor {
  color: #888;
  font-size: 0.9em;
}

.log-actor::before {
  content: "\2022";
  margin-right: 0.5em;
  color: #ccc;
}

.log-more {
  padding: 0.5em 1em;
  text-align: center;
  border-top: 1px solid #e0e0e0;
}

.log-more-btn {
  background: none;
  border: none;
  color: var(--facet-color, #667eea);
  cursor: pointer;
  font-size: 0.85em;
  padding: 0.5em 1em;
  border-radius: 4px;
}

.log-more-btn:hover {
  background: var(--facet-bg, rgba(102, 126, 234, 0.1));
}

.log-more-btn:disabled {
  color: #ccc;
  cursor: default;
}

/* Providers section */
.provider-row {
  display: flex;
  gap: 1em;
  margin-bottom: 1em;
}

.provider-row .settings-field {
  flex: 1;
  margin-bottom: 0;
}

.provider-key-warning {
  display: flex;
  align-items: center;
  gap: 0.5em;
  margin-top: 0.5em;
  padding: 0.5em 0.75em;
  background: #fff8dc;
  border: 1px solid #ffd700;
  border-radius: 6px;
  font-size: 0.85em;
  color: #856404;
}

.provider-key-warning a {
  color: #0066cc;
  text-decoration: none;
}

.provider-key-warning a:hover {
  text-decoration: underline;
}

/* Backend settings fieldsets */
.backend-settings {
  border: none;
  padding: 0;
  margin: 0.5em 0 0 0;
}

/* Context overrides collapsible section */
.context-overrides {
  margin-top: 2em;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  overflow: hidden;
}

.context-overrides-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75em 1em;
  background: #f8f8f8;
  border-bottom: 1px solid #e0e0e0;
}

.context-overrides-title {
  font-weight: 600;
  font-size: 0.95em;
  color: #333;
}

.context-overrides-toggle {
  font-size: 0.8em;
  color: #666;
  transition: transform 0.2s;
}

.context-overrides.expanded .context-overrides-toggle {
  transform: rotate(180deg);
}

.context-overrides-body {
  display: none;
  padding: 1em;
}

.context-overrides.expanded .context-overrides-body {
  display: block;
}

.redact-list {
  padding: 0.5em 0;
}

.redact-item {
  display: flex;
  align-items: center;
  gap: 0.5em;
  padding: 0.5em 0.5em;
  border-bottom: 1px solid #f0f0f0;
}

.redact-item:last-child {
  border-bottom: none;
}

.redact-item:hover {
  background: #fafafa;
}

.redact-text {
  flex: 1;
  font-size: 0.9em;
  color: #333;
  cursor: default;
  padding: 0.25em 0.5em;
  border-radius: 4px;
  border: 1px solid transparent;
  min-height: 1.4em;
  word-break: break-word;
}

.redact-text:hover {
  border-color: #e0e0e0;
}

.redact-input {
  flex: 1;
  font-size: 0.9em;
  padding: 0.25em 0.5em;
  border: 1px solid var(--facet-color, #667eea);
  border-radius: 4px;
  outline: none;
}

.redact-remove {
  background: none;
  border: none;
  color: #ccc;
  font-size: 1.2em;
  cursor: pointer;
  padding: 0 0.25em;
  line-height: 1;
  transition: color 0.15s;
}

.redact-remove:hover {
  color: #e74c3c;
}

.redact-empty {
  padding: 1.5em;
  text-align: center;
  color: #888;
  font-size: 0.9em;
}

.redact-add-row {
  display: flex;
  gap: 0.5em;
  padding: 0.75em 0.5em 0.25em;
}

.redact-add-input {
  flex: 1;
  font-size: 0.9em;
  padding: 0.4em 0.75em;
  border: 1px solid #ddd;
  border-radius: 6px;
  outline: none;
}

.redact-add-input:focus {
  border-color: var(--facet-color, #667eea);
}

.redact-add-btn {
  background: none;
  border: 1px dashed #ccc;
  border-radius: 20px;
  padding: 0.4em 0.75em;
  font-size: 0.85em;
  color: #666;
  cursor: pointer;
  transition: all 0.15s;
  white-space: nowrap;
}

.redact-add-btn:hover {
  border-color: var(--facet-color, #667eea);
  color: var(--facet-color, #667eea);
  background: var(--facet-bg, rgba(102, 126, 234, 0.05));
}

.redact-add-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.redact-validation {
  font-size: 0.8em;
  color: #e74c3c;
  padding: 0.25em 0.5em;
}

.context-group {
  margin-bottom: 1.5em;
}

.context-group:last-child {
  margin-bottom: 0;
}

.context-group-label {
  font-size: 0.75em;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: #888;
  margin-bottom: 0.5em;
  padding-left: 0.25em;
}

.context-item {
  display: flex;
  align-items: center;
  gap: 0.75em;
  padding: 0.5em 0.5em;
  border-radius: 6px;
  margin-bottom: 0.25em;
}

.context-item:hover {
  background: #f5f5f5;
}

.context-label {
  flex: 1;
  font-size: 0.9em;
  color: #333;
}

.context-value {
  display: flex;
  align-items: center;
  gap: 0.5em;
}

.context-select {
  padding: 0.3em 0.5em;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 0.85em;
  background: white;
  min-width: 80px;
}

.context-action {
  width: 1.5em;
  text-align: center;
}

.context-reset {
  background: none;
  border: none;
  color: #888;
  cursor: pointer;
  font-size: 0.9em;
  padding: 0.2em 0.4em;
  border-radius: 4px;
  opacity: 0;
  transition: opacity 0.15s;
}

.context-item:hover .context-reset {
  opacity: 1;
}

.context-reset:hover {
  color: #d32f2f;
  background: #ffebee;
}

.context-saved {
  color: #28a745;
  opacity: 1;
  transition: opacity 0.3s;
}

.context-saved.fade {
  opacity: 0;
}

/* Vision extraction display (double-click to edit) */
.vision-extraction-display {
  display: block;
  padding: 0.4em 0.6em;
  font-size: 0.85em;
  border: 1px solid transparent;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.15s;
  line-height: 1.4;
}

.vision-extraction-display:hover {
  background: #f5f5f5;
  border-color: #ddd;
}

.vision-extraction-display.vision-extraction-default {
  color: #666;
  font-style: italic;
}

.vision-extraction-display.vision-extraction-empty {
  color: #999;
  font-style: italic;
}

.vision-extraction-display.vision-extraction-disabled {
  color: #999;
  font-style: italic;
  opacity: 0.5;
  cursor: default;
}

.vision-extraction-display.vision-extraction-disabled:hover {
  background: transparent;
  border-color: transparent;
}

.vision-extraction-input {
  width: 100%;
  padding: 0.4em 0.6em;
  font-size: 0.85em;
  border: 2px solid var(--facet-color, #667eea);
  border-radius: 4px;
  font-family: inherit;
  line-height: 1.4;
}

/* Vision importance sections */
.importance-section {
  margin-bottom: 1em;
  border-radius: 8px;
  padding: 0.75em;
  transition: background 0.2s;
}

.importance-section:last-child {
  margin-bottom: 0;
}

.importance-section.importance-high {
  background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
  border: 1px solid #b1dfbb;
}

.importance-section.importance-normal {
  background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
  border: 1px solid #abdde5;
}

.importance-section.importance-low {
  background: linear-gradient(135deg, #fff3cd 0%, #ffeeba 100%);
  border: 1px solid #ffc107;
}

.importance-section.importance-ignore {
  background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
  border: 1px solid #c6c8ca;
}

.importance-section-header {
  font-size: 0.8em;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 0.5em;
  padding-left: 0.25em;
  display: flex;
  align-items: center;
  gap: 0.5em;
}

.importance-high .importance-section-header { color: #155724; }
.importance-normal .importance-section-header { color: #0c5460; }
.importance-low .importance-section-header { color: #856404; }
.importance-ignore .importance-section-header { color: #383d41; }

.importance-section-empty {
  font-size: 0.85em;
  font-style: italic;
  padding: 0.5em;
  opacity: 0.6;
}

.vision-category-item {
  background: rgba(255,255,255,0.7);
  border-radius: 6px;
  padding: 0.5em;
  margin-bottom: 0.5em;
  transition: transform 0.2s, opacity 0.2s, background 0.15s;
}

.vision-category-item:last-child {
  margin-bottom: 0;
}

.vision-category-item:hover {
  background: rgba(255,255,255,0.9);
}

.vision-category-item.moving {
  opacity: 0.5;
  transform: scale(0.98);
}

.vision-move-buttons {
  display: flex;
  gap: 0.25em;
}

.vision-move-btn {
  background: rgba(255,255,255,0.8);
  border: 1px solid #ccc;
  border-radius: 4px;
  width: 1.5em;
  height: 1.5em;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 0.85em;
  color: #555;
  transition: all 0.15s;
}

.vision-move-btn:hover:not(:disabled) {
  background: white;
  border-color: #999;
  color: #333;
}

.vision-move-btn:disabled {
  opacity: 0.3;
  cursor: default;
}

/* Setup section */
.setup-section {
  padding: 1.5em;
  background: linear-gradient(135deg, #007bff08 0%, #007bff15 100%);
  border: 2px solid #007bff30;
  border-radius: 12px;
  margin-bottom: 1.5em;
}

.setup-section h3 {
  color: #333;
  font-size: 1.2em;
  margin: 0 0 0.5em 0;
}

.setup-section p {
  color: #555;
  margin: 0 0 1em 0;
  line-height: 1.5;
}

.setup-btn {
  display: inline-flex;
  align-items: center;
  gap: 0.5em;
  padding: 0.75em 1.5em;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 1em;
  font-weight: 600;
  cursor: pointer;
}

.setup-btn:hover {
  background: #0056b3;
}

.setup-btn:disabled {
  opacity: 0.7;
  cursor: not-allowed;
}

/* Insights section */
.insights-group {
  margin-bottom: 1.5em;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  overflow: hidden;
}

.insights-group-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75em 1em;
  background: #f8f8f8;
  cursor: pointer;
  user-select: none;
  border-bottom: 1px solid transparent;
  transition: background 0.15s;
}

.insights-group-header:hover {
  background: #f0f0f0;
}

.insights-group.expanded .insights-group-header {
  border-bottom-color: #e0e0e0;
}

.insights-group-title {
  font-weight: 600;
  font-size: 0.95em;
  color: #333;
}

.insights-group-count {
  font-weight: normal;
  color: #888;
  font-size: 0.85em;
  margin-left: 0.5em;
}

.insights-group-toggle {
  font-size: 0.8em;
  color: #666;
  transition: transform 0.2s;
}

.insights-group.expanded .insights-group-toggle {
  transform: rotate(180deg);
}

.insights-group-body {
  display: none;
  padding: 0.5em;
}

.insights-group.expanded .insights-group-body {
  display: block;
}

.insight-source-group {
  margin-bottom: 1em;
}

.insight-source-group:last-child {
  margin-bottom: 0;
}

.insight-source-label {
  font-size: 0.7em;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: #888;
  padding: 0.5em 0.5em 0.25em;
}

.insight-row {
  display: flex;
  align-items: flex-start;
  gap: 0.75em;
  padding: 0.6em 0.5em;
  border-radius: 6px;
  margin-bottom: 0.25em;
  transition: background 0.15s;
}

.insight-row:hover {
  background: #f5f5f5;
}

.insight-row.insight-disabled {
  opacity: 0.6;
}

.insight-info {
  flex: 1;
  min-width: 0;
}

.insight-title {
  font-size: 0.9em;
  font-weight: 600;
  color: #333;
  margin-bottom: 0.15em;
}

.insight-desc {
  font-size: 0.8em;
  color: #666;
  line-height: 1.3;
}

.insight-controls {
  display: flex;
  align-items: center;
  gap: 0.75em;
  flex-shrink: 0;
}

.insight-toggle-group {
  display: flex;
  align-items: center;
  gap: 0.4em;
}

.insight-toggle-label {
  font-size: 0.75em;
  color: #666;
  white-space: nowrap;
}

.insight-toggle {
  position: relative;
  width: 36px;
  height: 20px;
}

.insight-toggle input {
  opacity: 0;
  width: 0;
  height: 0;
}

.insight-toggle .slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  transition: 0.2s;
  border-radius: 20px;
}

.insight-toggle .slider:before {
  position: absolute;
  content: "";
  height: 14px;
  width: 14px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  transition: 0.2s;
  border-radius: 50%;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.insight-toggle input:checked + .slider {
  background-color: #28a745;
}

.insight-toggle input:checked + .slider:before {
  transform: translateX(16px);
}

.insight-toggle input:disabled + .slider {
  opacity: 0.5;
  cursor: default;
}

/* Activities section */
.activities-section {
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  overflow: hidden;
}

.activities-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75em 1em;
  background: #f8f8f8;
  border-bottom: 1px solid #e0e0e0;
}

.activities-title {
  font-weight: 600;
  font-size: 0.95em;
  color: #333;
}

.activities-count {
  font-weight: normal;
  color: #888;
  font-size: 0.85em;
}

.activities-list {
  padding: 0.5em;
}

.activities-empty {
  padding: 1.5em;
  text-align: center;
  color: #888;
  font-size: 0.9em;
}

.activity-item {
  display: flex;
  align-items: flex-start;
  gap: 0.75em;
  padding: 0.75em;
  border-radius: 6px;
  margin-bottom: 0.5em;
  background: #fafafa;
  transition: background 0.15s;
}

.activity-item:last-child {
  margin-bottom: 0;
}

.activity-item:hover {
  background: #f0f0f0;
}

.activity-icon {
  font-size: 1.5em;
  line-height: 1;
  flex-shrink: 0;
}

.activity-info {
  flex: 1;
  min-width: 0;
}

.activity-name {
  font-weight: 600;
  font-size: 0.95em;
  color: #333;
  margin-bottom: 0.2em;
}

.activity-desc {
  font-size: 0.85em;
  color: #666;
  line-height: 1.3;
}

.activity-desc.activity-desc-editable {
  cursor: pointer;
  padding: 0.2em 0.4em;
  margin: -0.2em -0.4em;
  border-radius: 4px;
  transition: background 0.15s;
}

.activity-desc.activity-desc-editable:hover {
  background: #e8e8e8;
}

.activity-controls {
  display: flex;
  align-items: center;
  gap: 0.5em;
  flex-shrink: 0;
}

.activity-priority {
  padding: 0.25em 0.5em;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 0.8em;
  background: white;
  cursor: pointer;
}

.activity-remove {
  background: none;
  border: none;
  color: #999;
  cursor: pointer;
  font-size: 1.1em;
  padding: 0.2em 0.4em;
  border-radius: 4px;
  transition: all 0.15s;
}

.activity-remove:hover {
  color: #d32f2f;
  background: #ffebee;
}

/* Add activities panel */
.activities-add-panel {
  padding: 0.75em;
}

.activities-defaults {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5em;
  margin-bottom: 0.75em;
}

.activity-chip {
  display: inline-flex;
  align-items: center;
  gap: 0.4em;
  padding: 0.4em 0.75em;
  background: #f0f0f0;
  border: 1px solid #ddd;
  border-radius: 20px;
  font-size: 0.85em;
  cursor: pointer;
  transition: all 0.15s;
}

.activity-chip:hover {
  background: #e0e0e0;
  border-color: #bbb;
}

.activity-chip.activity-chip-attached {
  opacity: 0.5;
  cursor: default;
}

.activity-chip-icon {
  font-size: 1.1em;
}

.activities-custom {
  padding-top: 0.5em;
  border-top: 1px solid #eee;
}

.activities-add-custom-btn {
  background: none;
  border: 1px dashed #ccc;
  border-radius: 20px;
  padding: 0.4em 0.75em;
  font-size: 0.85em;
  color: #666;
  cursor: pointer;
  transition: all 0.15s;
}

.activities-add-custom-btn:hover {
  border-color: var(--facet-color, #667eea);
  color: var(--facet-color, #667eea);
  background: var(--facet-bg, rgba(102, 126, 234, 0.05));
}

/* Responsive */
@media (max-width: 768px) {
  .settings-wrap {
    flex-direction: column;
    gap: 1em;
  }

  .settings-nav {
    display: none;
  }

  .settings-nav-mobile {
    display: block;
  }

  .settings-content {
    max-width: none;
  }
}
</style>

<div class="settings-wrap">
  <!-- Mobile nav dropdown -->
  <div class="settings-nav-mobile">
    <select class="settings-nav-select" id="navSelect">
      <optgroup label="Journal">
        <option value="profile">Profile</option>
        <option value="providers">Providers</option>
        <option value="apikeys">API Keys</option>
        <option value="transcription">Transcription</option>
        <option value="observer">Observer</option>
        <option value="vision">Vision</option>
        <option value="insights">Insights</option>
        <option value="security">Security</option>
      </optgroup>
      <optgroup label="Facet" id="navSelectFacetGroup" style="display:none">
        <option value="facet-appearance">Appearance</option>
        <option value="facet-activities">Activities</option>
        <option value="facet-activity">Activity Log</option>
      </optgroup>
    </select>
  </div>

  <!-- Desktop nav sidebar -->
  <nav class="settings-nav" id="settingsNav">
    <div class="settings-nav-group">
      <div class="settings-nav-label">Journal</div>
      <button class="settings-nav-item active" data-section="profile">Profile</button>
      <button class="settings-nav-item" data-section="providers">Providers</button>
      <button class="settings-nav-item" data-section="apikeys">API Keys</button>
      <button class="settings-nav-item" data-section="transcription">Transcription</button>
      <button class="settings-nav-item" data-section="observer">Observer</button>
      <button class="settings-nav-item" data-section="vision">Vision</button>
      <button class="settings-nav-item" data-section="insights">Insights</button>
      <button class="settings-nav-item" data-section="security">Security</button>
    </div>
    <div class="settings-nav-group" id="facetNavGroup" style="display:none">
      <div class="settings-nav-label" id="facetNavLabel">Facet</div>
      <button class="settings-nav-item" data-section="facet-appearance">Appearance</button>
      <button class="settings-nav-item" data-section="facet-activities">Activities</button>
      <button class="settings-nav-item" data-section="facet-activity">Activity Log</button>
    </div>
  </nav>

  <!-- Content panels -->
  <div class="settings-content">
    <!-- Profile Section -->
    <section class="settings-section active" id="section-profile">
      <h2>Profile</h2>
      <p class="settings-section-desc">Your identity information used in AI templates and transcription.</p>

      <!-- Setup prompt (shown when no facets) -->
      <div class="setup-section" id="setupSection" style="display:none">
        <h3>Welcome to solstone</h3>
        <p>Create your first facet to start organizing your journal.</p>
        <button class="setup-btn" id="createPersonalBtn">Create Personal Facet</button>
      </div>

      <div class="settings-field">
        <label for="field-name">Full Name</label>
        <input type="text" id="field-name" data-section="identity" data-key="name" placeholder="Your full name">
        <small>Your full legal or formal name</small>
      </div>

      <div class="settings-field">
        <label for="field-preferred">Preferred Name</label>
        <input type="text" id="field-preferred" data-section="identity" data-key="preferred" placeholder="Your preferred name">
        <small>Preferred name or nickname to be used when addressing you</small>
      </div>

      <div class="settings-field">
        <label for="field-bio">Bio</label>
        <textarea id="field-bio" data-section="identity" data-key="bio" rows="2" placeholder="e.g., a software engineer interested in AI"></textarea>
        <small>Brief description of yourself used in AI templates</small>
      </div>

      <div class="settings-field">
        <label for="field-pronouns">Pronouns</label>
        <select id="field-pronouns" data-section="identity" data-key="pronouns">
          <option value="">Select pronouns...</option>
          <option value="she/her/her/herself">she/her/hers/herself</option>
          <option value="he/him/his/himself">he/him/his/himself</option>
          <option value="they/them/their/themselves">they/them/their/themselves</option>
          <option value="ze/zir/zir/zirself">ze/zir/zirs/zirself</option>
          <option value="xe/xem/xyr/xemself">xe/xem/xyrs/xemself</option>
          <option value="it/it/its/itself">it/its/its/itself</option>
        </select>
        <small>Pronouns for use in templates (subject/object/possessive/reflexive)</small>
      </div>

      <div class="settings-field">
        <label for="field-aliases">Aliases</label>
        <input type="text" id="field-aliases" data-section="identity" data-key="aliases" placeholder="e.g., nickname1, nickname2">
        <small>Comma-separated alternative names that may appear in transcripts</small>
      </div>

      <div class="settings-field">
        <label for="field-emails">Email Addresses</label>
        <input type="text" id="field-emails" data-section="identity" data-key="email_addresses" placeholder="e.g., work@company.com, personal@example.com">
        <small>Comma-separated email addresses for participant detection</small>
      </div>

      <div class="settings-field">
        <label for="field-timezone">Home Timezone</label>
        <input type="text" id="field-timezone" data-section="identity" data-key="timezone" list="timezone-list" placeholder="e.g., America/New_York">
        <datalist id="timezone-list">
          <option value="America/New_York">
          <option value="America/Chicago">
          <option value="America/Denver">
          <option value="America/Los_Angeles">
          <option value="America/Phoenix">
          <option value="America/Anchorage">
          <option value="America/Honolulu">
          <option value="America/Toronto">
          <option value="America/Vancouver">
          <option value="America/Mexico_City">
          <option value="America/Sao_Paulo">
          <option value="Europe/London">
          <option value="Europe/Paris">
          <option value="Europe/Berlin">
          <option value="Europe/Amsterdam">
          <option value="Europe/Madrid">
          <option value="Europe/Rome">
          <option value="Europe/Moscow">
          <option value="Asia/Tokyo">
          <option value="Asia/Shanghai">
          <option value="Asia/Hong_Kong">
          <option value="Asia/Singapore">
          <option value="Asia/Seoul">
          <option value="Asia/Kolkata">
          <option value="Asia/Dubai">
          <option value="Australia/Sydney">
          <option value="Australia/Melbourne">
          <option value="Pacific/Auckland">
          <option value="UTC">
        </datalist>
        <small>IANA timezone identifier</small>
      </div>
    </section>

    <!-- Providers Section -->
    <section class="settings-section" id="section-providers">
      <h2>Providers</h2>
      <p class="settings-section-desc">Configure which AI provider and model tier to use. Higher tiers are more capable but cost more.</p>

      <div class="provider-row">
        <div class="settings-field">
          <label for="field-provider">Default Provider</label>
          <select id="field-provider">
            <!-- Populated dynamically from registry -->
          </select>
          <small></small>
        </div>
        <div class="settings-field">
          <label for="field-tier">Default Tier</label>
          <select id="field-tier">
            <option value="1">Best - Most capable</option>
            <option value="2">Average - Balanced</option>
            <option value="3">Fast - Lightweight</option>
          </select>
          <small></small>
        </div>
      </div>
      <div id="providerKeyWarning" class="provider-key-warning" style="display:none">
        <span>&#9888;</span>
        <span>API key not configured for this provider.</span>
        <a href="#" id="providerKeyLink">Configure in API Keys</a>
      </div>
      <div class="provider-row">
        <div class="settings-field">
          <label for="field-backup-provider">Backup Provider</label>
          <select id="field-backup-provider">
            <!-- Populated dynamically from registry -->
          </select>
          <small></small>
        </div>
      </div>
      <div id="backupProviderKeyWarning" class="provider-key-warning" style="display:none">
        <span>&#9888;</span>
        <span>API key not configured for backup provider.</span>
        <a href="#" id="backupProviderKeyLink">Configure in API Keys</a>
      </div>
      <small id="providerStatus">Loading...</small>

      <!-- Detailed Tasks -->
      <div class="context-overrides expanded" id="contextOverrides">
        <div class="context-overrides-header">
          <span class="context-overrides-title">Detailed Tasks</span>
        </div>
        <div class="context-overrides-body" id="contextOverridesBody">
          <p style="color:#666;font-size:0.9em;margin:0 0 1em 0">Override provider or tier for specific tasks. Unset values use defaults.</p>
          <div id="contextGroups">Loading...</div>
        </div>
      </div>
    </section>

    <!-- API Keys Section -->
    <section class="settings-section" id="section-apikeys">
      <h2>API Keys</h2>
      <p class="settings-section-desc">Configure API keys for AI providers. Keys are stored in your journal config.</p>

      <div class="settings-field">
        <label for="field-env-google">Google AI (Gemini)</label>
        <div class="password-wrap">
          <input type="password" id="field-env-google" data-section="env" data-key="GOOGLE_API_KEY" placeholder="Enter API key">
          <button type="button" class="password-toggle" data-toggle="field-env-google" title="Show key">
            <span>&#128065;</span>
          </button>
        </div>
        <small>Primary provider for transcription and insights. <a href="https://aistudio.google.com/apikey" target="_blank">Get key</a></small>
      </div>

      <div class="settings-field">
        <label for="field-env-openai">OpenAI</label>
        <div class="password-wrap">
          <input type="password" id="field-env-openai" data-section="env" data-key="OPENAI_API_KEY" placeholder="Enter API key">
          <button type="button" class="password-toggle" data-toggle="field-env-openai" title="Show key">
            <span>&#128065;</span>
          </button>
        </div>
        <small>Alternative provider for chat and agents. <a href="https://platform.openai.com/api-keys" target="_blank">Get key</a></small>
      </div>

      <div class="settings-field">
        <label for="field-env-anthropic">Anthropic</label>
        <div class="password-wrap">
          <input type="password" id="field-env-anthropic" data-section="env" data-key="ANTHROPIC_API_KEY" placeholder="Enter API key">
          <button type="button" class="password-toggle" data-toggle="field-env-anthropic" title="Show key">
            <span>&#128065;</span>
          </button>
        </div>
        <small>Alternative provider for chat and agents. <a href="https://console.anthropic.com/settings/keys" target="_blank">Get key</a></small>
      </div>

      <div class="settings-field">
        <label for="field-env-revai">Rev.ai</label>
        <div class="password-wrap">
          <input type="password" id="field-env-revai" data-section="env" data-key="REVAI_ACCESS_TOKEN" placeholder="Enter access token">
          <button type="button" class="password-toggle" data-toggle="field-env-revai" title="Show token">
            <span>&#128065;</span>
          </button>
        </div>
        <small>Audio transcription for imported files. <a href="https://www.rev.ai/access_token" target="_blank">Get token</a></small>
      </div>
    </section>

    <!-- Transcription Section -->
    <section class="settings-section" id="section-transcription">
      <h2>Transcription</h2>
      <p class="settings-section-desc">Speech-to-text backend and processing settings.</p>

      <div class="settings-field">
        <label for="field-transcribe-backend">Backend</label>
        <select id="field-transcribe-backend">
          <!-- Options populated dynamically from /api/transcribe -->
        </select>
        <small>Speech-to-text engine to use for transcription</small>
      </div>

      <!-- Backend API key warning (shown when selected backend needs API key) -->
      <div id="backendKeyWarning" class="provider-key-warning" style="display:none">
        <span>&#9888;</span>
        <span id="backendKeyWarningText">API key not configured.</span>
        <a href="#" id="backendKeyLink">Configure in API Keys</a>
      </div>

      <!-- Whisper-specific settings -->
      <fieldset id="whisper-settings" class="backend-settings">
        <div class="settings-field">
          <label for="field-whisper-device">Device</label>
          <select id="field-whisper-device">
            <option value="auto" selected>Auto - Detect GPU if available</option>
            <option value="cpu">CPU - Use processor only</option>
            <option value="cuda">CUDA - Force NVIDIA GPU</option>
          </select>
          <small>Hardware to use for local transcription</small>
        </div>

        <div class="settings-field">
          <label for="field-whisper-model">Model</label>
          <select id="field-whisper-model">
            <option value="tiny.en">Tiny - Fastest</option>
            <option value="base.en">Base</option>
            <option value="small.en">Small</option>
            <option value="medium.en" selected>Medium (default)</option>
            <option value="large-v3-turbo">Large v3 Turbo</option>
            <option value="distil-large-v3">Distil Large v3</option>
          </select>
          <small>Model size - larger is more accurate but slower</small>
        </div>

        <div class="settings-field">
          <label for="field-whisper-compute">Compute Type</label>
          <select id="field-whisper-compute">
            <option value="default" selected>Default - Auto-select</option>
            <option value="float32">Float32 - Highest precision</option>
            <option value="float16">Float16 - Balanced</option>
            <option value="int8">Int8 - Fastest</option>
          </select>
          <small>Numeric precision for inference</small>
        </div>
      </fieldset>

      <!-- Rev.ai-specific settings -->
      <fieldset id="revai-settings" class="backend-settings" style="display:none">
        <div class="settings-field">
          <label for="field-revai-model">Model</label>
          <select id="field-revai-model">
            <option value="fusion" selected>Fusion - Best quality (default)</option>
            <option value="machine">Machine - Fast automated</option>
            <option value="low_cost">Low Cost - Budget option</option>
          </select>
          <small>Rev.ai transcription model</small>
        </div>
      </fieldset>

      <!-- Gemini-specific settings (informational only) -->
      <fieldset id="gemini-settings" class="backend-settings" style="display:none">
        <p class="settings-field-note">
          Gemini combines transcription and enrichment in a single API call, providing
          speaker diarization, emotion detection, and topic extraction automatically.
          Model selection is handled by the provider settings.
        </p>
      </fieldset>

      <!-- Shared settings -->
      <div class="settings-field" style="margin-top: 1.5em;">
        <div class="toggle-container" style="justify-content: flex-start; gap: 1em;">
          <label class="toggle-switch toggle-positive">
            <input type="checkbox" id="field-transcribe-enrich" data-section="transcribe" data-key="enrich">
            <span class="slider"></span>
          </label>
          <label for="field-transcribe-enrich" class="toggle-label" style="cursor: pointer;">Enrich Transcripts</label>
        </div>
        <small>Use AI to extract topics, correct transcription errors, and add descriptions</small>
      </div>

      <div class="settings-field">
        <div class="toggle-container" style="justify-content: flex-start; gap: 1em;">
          <label class="toggle-switch toggle-positive">
            <input type="checkbox" id="field-transcribe-preserve" data-section="transcribe" data-key="preserve_all">
            <span class="slider"></span>
          </label>
          <label for="field-transcribe-preserve" class="toggle-label" style="cursor: pointer;">Preserve Silent Recordings</label>
        </div>
        <small>Keep audio files even when no speech is detected</small>
      </div>

      <div class="settings-field">
        <div class="toggle-container" style="justify-content: flex-start; gap: 1em;">
          <label class="toggle-switch toggle-positive">
            <input type="checkbox" id="field-transcribe-noise-upgrade" data-section="transcribe" data-key="noise_upgrade">
            <span class="slider"></span>
          </label>
          <label for="field-transcribe-noise-upgrade" class="toggle-label" style="cursor: pointer;">Noise Upgrade</label>
        </div>
        <small>Automatically use Rev.ai for noisy recordings (requires Rev.ai token)</small>
      </div>
    </section>

    <!-- Observer Section -->
    <section class="settings-section" id="section-observer">
      <h2>Observer</h2>
      <p class="settings-section-desc">Configure capture behavior for the observer service.</p>

      <h3 style="margin: 1.5em 0 0.75em 0; font-size: 1em; color: #374151;">Terminal Capture</h3>
      <p style="color: #666; font-size: 0.9em; margin: 0 0 1em 0;">
        When your screen is idle, the observer can capture terminal content from active tmux sessions.
      </p>

      <div class="settings-field">
        <label>Enable Terminal Capture</label>
        <div style="display: flex; align-items: center; gap: 1em;">
          <label class="toggle-switch toggle-positive">
            <input type="checkbox" id="field-tmux-enabled">
            <span class="slider"></span>
          </label>
          <span style="color: #666; font-size: 0.9em;">Capture tmux sessions when screen is idle</span>
        </div>
      </div>

      <div class="settings-field" id="tmuxCaptureIntervalField">
        <label for="field-tmux-capture-interval">Capture Interval (seconds)</label>
        <input type="number" id="field-tmux-capture-interval" style="max-width: 100px;">
        <small id="tmuxCaptureIntervalHelp">How often to capture terminal content</small>
      </div>

      <p style="color: #888; font-size: 0.85em; margin-top: 1.5em; padding: 0.75em; background: #f8f9fa; border-radius: 4px;">
        Changes take effect on next observer restart.
      </p>
    </section>

    <!-- Vision Section -->
    <section class="settings-section" id="section-vision">
      <h2>Vision</h2>
      <p class="settings-section-desc">Screen analysis settings for observe-describe.</p>

      <div class="settings-field">
        <label for="field-max-extractions">Max Extractions (of 300 possible frames)</label>
        <input type="number" id="field-max-extractions" min="5" max="100" value="20" style="max-width: 100px;">
        <small>Maximum frames to extract detailed content from per 5 minute screen segment (big impact on token usage)</small>
      </div>

      <!-- Redaction Rules -->
      <div class="context-overrides expanded" id="visionRedaction">
        <div class="context-overrides-header" id="visionRedactionHeader">
          <span class="context-overrides-title">Redaction Rules</span>
          <span class="context-overrides-toggle">&#9660;</span>
        </div>
        <div class="context-overrides-body">
          <p style="color:#666;font-size:0.9em;margin:0 0 1em 0">Instructions the AI follows to redact sensitive content from screen analysis. Double-click a rule to edit it.</p>
          <div class="redact-list" id="redactRulesList"></div>
          <div class="redact-add-row">
            <input type="text" class="redact-add-input" id="redactAddInput" placeholder="Add a redaction rule..." maxlength="200">
            <button class="redact-add-btn" id="redactAddBtn">+ Add</button>
          </div>
          <div class="redact-validation" id="redactValidation" style="display:none"></div>
        </div>
      </div>

      <!-- Categories -->
      <div class="context-overrides expanded" id="visionCategories">
        <div class="context-overrides-header" id="visionCategoriesHeader">
          <span class="context-overrides-title">Categories</span>
          <span class="context-overrides-toggle">&#9660;</span>
        </div>
        <div class="context-overrides-body" id="visionCategoriesBody">
          <p style="color:#666;font-size:0.9em;margin:0 0 1em 0">Set importance and extraction rules for each screen category. Double-click guidance text to edit.</p>
          <div id="visionCategoryGroups">Loading...</div>
        </div>
      </div>
    </section>

    <!-- Insights Section -->
    <section class="settings-section" id="section-insights">
      <h2>Insights</h2>
      <p class="settings-section-desc">Configure which AI insights run and whether they extract events to your timeline.</p>

      <!-- Segment Insights -->
      <div class="insights-group expanded" id="segmentInsightsGroup">
        <div class="insights-group-header" id="segmentInsightsHeader">
          <span><span class="insights-group-title">Segment Insights</span><span class="insights-group-count" id="segmentInsightsCount"></span></span>
          <span class="insights-group-toggle">&#9660;</span>
        </div>
        <div class="insights-group-body" id="segmentInsightsBody">
          <p style="color:#666;font-size:0.85em;margin:0 0 0.75em 0">Run on each recording segment (5 minutes of audio/screen).</p>
          <div id="segmentInsightsList">Loading...</div>
        </div>
      </div>

      <!-- Daily Insights -->
      <div class="insights-group expanded" id="dailyInsightsGroup">
        <div class="insights-group-header" id="dailyInsightsHeader">
          <span><span class="insights-group-title">Daily Insights</span><span class="insights-group-count" id="dailyInsightsCount"></span></span>
          <span class="insights-group-toggle">&#9660;</span>
        </div>
        <div class="insights-group-body" id="dailyInsightsBody">
          <p style="color:#666;font-size:0.85em;margin:0 0 0.75em 0">Run once per day, synthesizing all segments.</p>
          <div id="dailyInsightsList">Loading...</div>
        </div>
      </div>
    </section>

    <!-- Security Section -->
    <section class="settings-section" id="section-security">
      <h2>Security</h2>
      <p class="settings-section-desc">Authentication and access control.</p>

      <div class="settings-field">
        <label for="field-password">Web Password</label>
        <div class="password-wrap">
          <input type="password" id="field-password" data-section="convey" data-key="password" placeholder="Enter password to protect web access">
          <button type="button" class="password-toggle" id="passwordToggle" title="Show password">
            <span id="passwordToggleIcon">&#128065;</span>
          </button>
        </div>
        <small>Set a password to protect the web interface. Leave empty to allow unauthenticated localhost access.</small>
      </div>
    </section>

    <!-- Facet Appearance Section -->
    <section class="settings-section" id="section-facet-appearance" data-requires-facet>
      <div class="facet-header">
        <h2>Appearance</h2>
        <div class="toggle-container">
          <span class="toggle-label" id="toggleLabel">Active</span>
          <label class="toggle-switch">
            <input type="checkbox" id="mutedToggle">
            <span class="slider"></span>
          </label>
        </div>
      </div>
      <p class="settings-section-desc">Customize how this facet appears in the interface.</p>

      <div class="settings-field">
        <label>Title</label>
        <div class="editable-field" id="facetTitleField">
          <span class="field-display" id="facetTitleDisplay">Loading...</span>
          <input type="text" class="field-input" id="facetTitleInput" style="display:none">
        </div>
        <small>Double-click to edit</small>
      </div>

      <div class="settings-field">
        <label>Description</label>
        <div class="editable-field" id="facetDescField">
          <span class="field-display" id="facetDescDisplay">No description set</span>
          <textarea class="field-input" id="facetDescInput" rows="3" style="display:none"></textarea>
        </div>
        <small>Double-click to edit</small>
      </div>

      <div class="settings-field">
        <label>Icon</label>
        <div class="emoji-display" id="emojiDisplay">&#128230;</div>
        <input type="text" id="emojiInput" class="emoji-input" maxlength="4" placeholder="Paste emoji" style="display:none">
        <small>Click to change emoji</small>
      </div>

      <div class="settings-field">
        <label>Theme Color</label>
        <div class="color-picker-trigger" id="colorTrigger">
          <div class="color-preview" id="colorPreview"></div>
          <span id="colorHexDisplay">#667eea</span>
        </div>
        <small>Click to choose a color</small>
      </div>
    </section>

    <!-- Facet Activities Section -->
    <section class="settings-section" id="section-facet-activities" data-requires-facet>
      <h2>Activities</h2>
      <p class="settings-section-desc">Configure which activities are tracked for this facet.</p>

      <!-- Attached Activities -->
      <div class="activities-section">
        <div class="activities-header">
          <span class="activities-title">Attached Activities</span>
          <span class="activities-count" id="attachedActivitiesCount"></span>
        </div>
        <div class="activities-list" id="attachedActivitiesList">
          <div class="activities-empty">No activities attached yet</div>
        </div>
      </div>

      <!-- Add Activities -->
      <div class="activities-section" style="margin-top: 1.5em;">
        <div class="activities-header">
          <span class="activities-title">Add Activity</span>
        </div>
        <div class="activities-add-panel">
          <div class="activities-defaults" id="defaultActivitiesList">
            Loading...
          </div>
          <div class="activities-custom">
            <button class="activities-add-custom-btn" id="addCustomActivityBtn">+ Add Custom Activity</button>
          </div>
        </div>
      </div>

      <!-- Custom Activity Modal -->
      <div id="customActivityModal" class="color-modal">
        <div class="color-modal-content" style="max-width: 400px;">
          <span class="color-close" id="customActivityClose">&times;</span>
          <h3>Add Custom Activity</h3>
          <div class="settings-field">
            <label for="customActivityName">Name</label>
            <input type="text" id="customActivityName" placeholder="e.g., Research">
          </div>
          <div class="settings-field">
            <label for="customActivityDesc">Description</label>
            <textarea id="customActivityDesc" rows="2" placeholder="Brief description of this activity"></textarea>
          </div>
          <div class="settings-field">
            <label for="customActivityIcon">Icon (emoji)</label>
            <input type="text" id="customActivityIcon" placeholder="e.g., 🔬" maxlength="4" style="max-width: 100px;">
          </div>
          <button class="save-color-btn" id="saveCustomActivityBtn">Add Activity</button>
        </div>
      </div>
    </section>

    <!-- Facet Activity Section -->
    <section class="settings-section" id="section-facet-activity" data-requires-facet>
      <h2>Activity Log</h2>
      <p class="settings-section-desc">Recent actions and changes to this facet.</p>

      <div class="log-panel">
        <div class="log-header">Action Log</div>
        <div class="log-entries" id="logEntries">
          <div class="log-empty">Loading...</div>
        </div>
        <div class="log-more" id="logMore" style="display:none">
          <button class="log-more-btn" id="logMoreBtn">Load older</button>
        </div>
      </div>
    </section>
  </div>
</div>

<!-- Color Picker Modal -->
<div id="colorPickerModal" class="color-modal">
  <div class="color-modal-content">
    <span class="color-close">&times;</span>
    <h3>Choose Theme Color</h3>
    <div class="color-swatches" id="colorSwatches"></div>
    <div class="custom-color">
      <label>Custom Color:</label>
      <div class="color-input-group">
        <input type="color" id="customColorPicker" value="#667eea">
        <input type="text" id="customColorInput" placeholder="#667eea" maxlength="7">
      </div>
    </div>
    <div class="color-preview-section">
      <h4>Preview</h4>
      <div class="modal-preview-pill" id="modalPreview">
        <span class="modal-preview-emoji" id="modalPreviewEmoji">&#128230;</span>
        <span class="modal-preview-title" id="modalPreviewTitle">Facet</span>
      </div>
    </div>
    <button class="save-color-btn" id="saveColorBtn">Apply Color</button>
  </div>
</div>

<script>
// ========== STATE ==========
let configData = null;
let facetConfig = null;
let saveTimeout = null;
let logNextCursor = null;
let insightsData = null;

// ========== NAVIGATION ==========
const VALID_SECTIONS = ['profile', 'providers', 'apikeys', 'transcription', 'observer', 'vision', 'insights', 'security', 'facet-appearance', 'facet-activities', 'facet-activity'];

function switchSection(sectionId, updateHash = true) {
  // Validate section exists
  if (!VALID_SECTIONS.includes(sectionId)) {
    sectionId = 'profile';
  }

  // Facet sections require a selected facet
  if (sectionId.startsWith('facet-') && !window.selectedFacet) {
    sectionId = 'profile';
  }

  // Update nav items
  document.querySelectorAll('.settings-nav-item').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.section === sectionId);
  });

  // Update mobile select
  document.getElementById('navSelect').value = sectionId;

  // Show/hide sections
  document.querySelectorAll('.settings-section').forEach(section => {
    section.classList.toggle('active', section.id === 'section-' + sectionId);
  });

  // Update URL hash
  if (updateHash) {
    history.replaceState(null, '', '#' + sectionId);
  }

  // Load facet data if switching to facet section
  if (sectionId.startsWith('facet-') && window.selectedFacet) {
    if (!facetConfig) {
      loadFacetConfig(window.selectedFacet);
    }
    if (sectionId === 'facet-activity') {
      loadLogs(window.selectedFacet);
    }
    if (sectionId === 'facet-activities') {
      loadActivities(window.selectedFacet);
    }
  }
}

// Desktop nav clicks
document.querySelectorAll('.settings-nav-item').forEach(btn => {
  btn.addEventListener('click', () => switchSection(btn.dataset.section));
});

// Mobile select change
document.getElementById('navSelect').addEventListener('change', (e) => {
  switchSection(e.target.value);
});

// Hash-based navigation
function initFromHash() {
  const hash = window.location.hash.slice(1);
  if (hash && VALID_SECTIONS.includes(hash)) {
    switchSection(hash, false);
  }
}

window.addEventListener('hashchange', () => {
  const hash = window.location.hash.slice(1);
  if (hash && VALID_SECTIONS.includes(hash)) {
    switchSection(hash, false);
  }
});

// Update facet nav visibility
function updateFacetNav() {
  const hasFacet = !!window.selectedFacet;
  const facetNavGroup = document.getElementById('facetNavGroup');
  const facetNavLabel = document.getElementById('facetNavLabel');
  const navSelectFacetGroup = document.getElementById('navSelectFacetGroup');

  facetNavGroup.style.display = hasFacet ? 'block' : 'none';
  navSelectFacetGroup.style.display = hasFacet ? 'block' : 'none';

  if (hasFacet && window.facetsData) {
    const facet = window.facetsData.find(f => f.name === window.selectedFacet);
    if (facet) {
      facetNavLabel.textContent = facet.title || window.selectedFacet;
    }
  }

  // Hide sections that require facet if none selected
  document.querySelectorAll('[data-requires-facet]').forEach(el => {
    if (!hasFacet && el.classList.contains('active')) {
      switchSection('profile');
    }
  });
}

// Listen for facet switches
window.addEventListener('facet.switch', (e) => {
  facetConfig = null; // Reset so it reloads
  activitiesData = null; // Reset activities too
  updateFacetNav();
  // If currently viewing a facet section, reload
  const activeSection = document.querySelector('.settings-section.active');
  if (activeSection && activeSection.dataset.requiresFacet !== undefined && e.detail.facet) {
    loadFacetConfig(e.detail.facet);
    if (activeSection.id === 'section-facet-activity') {
      loadLogs(e.detail.facet);
    }
    if (activeSection.id === 'section-facet-activities') {
      loadActivities(e.detail.facet);
    }
  }
});

// ========== CONFIG LOADING ==========
async function loadConfig() {
  try {
    // Load transcribe backends first (populates select options)
    await loadTranscribeBackends();

    const response = await fetch('api/config');
    configData = await response.json();
    populateFields(configData);
    checkShowSetup();
  } catch (err) {
    console.error('Error loading config:', err);
    notifyError( 'Load Failed', 'Error loading configuration');
  }
}

function populateFields(config) {
  // Identity fields
  const identity = config.identity || {};
  setValue('field-name', identity.name || '');
  setValue('field-preferred', identity.preferred || '');
  setValue('field-bio', identity.bio || '');
  setValue('field-aliases', Array.isArray(identity.aliases) ? identity.aliases.join(', ') : '');
  setValue('field-emails', Array.isArray(identity.email_addresses) ? identity.email_addresses.join(', ') : '');

  // Pronouns (convert object to string key)
  const pronouns = identity.pronouns || {};
  if (pronouns.subject && pronouns.object && pronouns.possessive && pronouns.reflexive) {
    setValue('field-pronouns', `${pronouns.subject}/${pronouns.object}/${pronouns.possessive}/${pronouns.reflexive}`);
  }

  // Timezone - auto-detect if empty
  if (!identity.timezone) {
    try {
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      setValue('field-timezone', tz);
      saveField(null, 'identity', 'timezone', tz);
    } catch (e) {}
  } else {
    setValue('field-timezone', identity.timezone);
  }

  // Transcribe - now with nested backend configs
  const transcribe = config.transcribe || {};
  const backend = transcribe.backend || 'whisper';
  setValue('field-transcribe-backend', backend);
  switchTranscribeBackend(backend, config);

  // Whisper settings (nested)
  const whisper = transcribe.whisper || {};
  setValue('field-whisper-device', whisper.device || 'auto');
  setValue('field-whisper-model', whisper.model || 'medium.en');
  setValue('field-whisper-compute', whisper.compute_type || 'default');

  // Rev.ai settings (nested)
  const revai = transcribe.revai || {};
  setValue('field-revai-model', revai.model || 'fusion');

  // Shared settings - enrich and noise_upgrade default to true when not set
  document.getElementById('field-transcribe-enrich').checked = transcribe.enrich !== false;
  document.getElementById('field-transcribe-preserve').checked = transcribe.preserve_all || false;
  document.getElementById('field-transcribe-noise-upgrade').checked = transcribe.noise_upgrade !== false;

  // Convey (password)
  const convey = config.convey || {};
  setValue('field-password', convey.password || '');

  // Env (API keys) - show status indicators
  // env = journal config status, system_env = shell/.env status
  const env = config.env || {};
  const sysEnv = config.system_env || {};
  updateEnvStatus('field-env-google', env.GOOGLE_API_KEY, sysEnv.GOOGLE_API_KEY);
  updateEnvStatus('field-env-openai', env.OPENAI_API_KEY, sysEnv.OPENAI_API_KEY);
  updateEnvStatus('field-env-anthropic', env.ANTHROPIC_API_KEY, sysEnv.ANTHROPIC_API_KEY);
  updateEnvStatus('field-env-revai', env.REVAI_ACCESS_TOKEN, sysEnv.REVAI_ACCESS_TOKEN);
}

function updateEnvStatus(fieldId, isJournalConfigured, isSystemConfigured) {
  const field = document.getElementById(fieldId);
  if (!field) return;

  // Update placeholder to indicate status
  if (isJournalConfigured) {
    field.placeholder = 'Key configured (enter new value to replace)';
  } else if (isSystemConfigured) {
    field.placeholder = 'Key available from system environment';
  } else {
    field.placeholder = 'Enter API key';
  }

  // Update label with status indicator
  const label = field.closest('.settings-field')?.querySelector('label');
  if (label) {
    // Remove existing status indicator
    const existingStatus = label.querySelector('.key-status');
    if (existingStatus) existingStatus.remove();

    if (isJournalConfigured) {
      const status = document.createElement('span');
      status.className = 'key-status key-status-journal';
      status.textContent = ' \u2713';
      label.appendChild(status);
    } else if (isSystemConfigured) {
      const status = document.createElement('span');
      status.className = 'key-status key-status-system';
      status.textContent = ' (system)';
      label.appendChild(status);
    }
  }
}

function setValue(id, value) {
  const el = document.getElementById(id);
  if (el) el.value = value;
}

// ========== GENERIC FIELD SAVING ==========
function setupAutoSave() {
  document.querySelectorAll('[data-section][data-key]').forEach(el => {
    el.addEventListener('change', () => handleFieldChange(el));
    el.addEventListener('blur', () => handleFieldChange(el));
  });
}

function handleFieldChange(el) {
  const section = el.dataset.section;
  const key = el.dataset.key;
  let value = el.type === 'checkbox' ? el.checked : el.value;

  // Transform special fields
  if (key === 'aliases' || key === 'email_addresses') {
    value = value.split(',').map(s => s.trim()).filter(s => s);
  } else if (key === 'pronouns' && value) {
    const parts = value.split('/');
    if (parts.length === 4) {
      value = { subject: parts[0], object: parts[1], possessive: parts[2], reflexive: parts[3] };
    } else {
      value = { subject: '', object: '', possessive: '', reflexive: '' };
    }
  }

  // Skip save if value unchanged (except env fields which are masked)
  if (section !== 'env') {
    const currentValue = configData?.[section]?.[key];
    if (JSON.stringify(currentValue) === JSON.stringify(value)) {
      return;
    }
  } else {
    // For env fields, skip if empty (user didn't enter anything)
    if (!value) return;
  }

  saveField(el, section, key, value);
}

function saveField(el, section, key, value) {
  clearTimeout(saveTimeout);
  saveTimeout = setTimeout(async () => {
    try {
      const response = await fetch('api/config', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ section, data: { [key]: value } })
      });
      const result = await response.json();
      if (result.success) {
        configData = result.config;
        if (el) showFieldStatus(el, 'saved');

        // For env fields, clear the input and update status indicator
        if (el && section === 'env') {
          el.value = '';
          updateEnvStatus(el.id, true, true);
        }
      } else {
        throw new Error(result.error);
      }
    } catch (err) {
      console.error('Save error:', err);
      if (el) showFieldStatus(el, 'error', err.message);
    }
  }, 500);
}

// Store original helper text and timeout per field
const fieldHelperText = new Map();
const fieldStatusTimeouts = new Map();

function showFieldStatus(el, type, message) {
  // Find the <small> helper text element in the same .settings-field
  const field = el.closest('.settings-field');
  if (!field) return;

  const small = field.querySelector('small');
  if (!small) return;

  // Store original text if not already stored
  if (!fieldHelperText.has(small)) {
    fieldHelperText.set(small, small.textContent);
  }

  // Clear any pending timeout for this field
  const existingTimeout = fieldStatusTimeouts.get(small);
  if (existingTimeout) {
    clearTimeout(existingTimeout);
  }

  // Remove previous status classes
  small.classList.remove('status-saved', 'status-error', 'status-fade');

  // Set status text and class
  if (type === 'saved') {
    small.textContent = 'Saved';
    small.classList.add('status-saved');
  } else {
    small.textContent = message || 'Error';
    small.classList.add('status-error');
  }

  // For saved status, fade back to original after delay
  if (type === 'saved') {
    const timeout = setTimeout(() => {
      small.classList.add('status-fade');
      setTimeout(() => {
        small.textContent = fieldHelperText.get(small);
        small.classList.remove('status-saved', 'status-fade');
      }, 300); // Match CSS transition duration
    }, 1500);
    fieldStatusTimeouts.set(small, timeout);
  }
  // Errors persist until value changes and triggers a new save
}

// ========== FACET CONFIG ==========
async function loadFacetConfig(facetName) {
  try {
    const response = await fetch(`/app/settings/api/facet/${facetName}`);
    const data = await response.json();
    if (data.error) throw new Error(data.error);

    facetConfig = data.config;
    populateFacetForm(facetName, data.config);
    setupFacetEditing();
  } catch (err) {
    console.error('Error loading facet config:', err);
    notifyError( 'Load Failed', 'Error loading facet configuration');
  }
}

function populateFacetForm(facetName, config) {
  const title = config.title || facetName;
  document.getElementById('facetTitleDisplay').textContent = title;
  document.getElementById('facetTitleInput').value = title;

  const desc = config.description || 'No description set';
  document.getElementById('facetDescDisplay').textContent = desc;
  document.getElementById('facetDescInput').value = config.description || '';

  document.getElementById('emojiDisplay').textContent = config.emoji || '\uD83D\uDCE6';

  const color = config.color || '#667eea';
  document.getElementById('colorPreview').style.backgroundColor = color;
  document.getElementById('colorHexDisplay').textContent = color;

  const isMuted = config.muted || false;
  document.getElementById('mutedToggle').checked = isMuted;
  document.getElementById('toggleLabel').textContent = isMuted ? 'Muted' : 'Active';
}

function setupFacetEditing() {
  setupDoubleTapEdit('facetTitleField', 'facetTitleDisplay', 'facetTitleInput', 'title');
  setupDoubleTapEdit('facetDescField', 'facetDescDisplay', 'facetDescInput', 'description');
  setupEmojiPicker();
  setupColorPicker();
  setupMutedToggle();
}

function setupDoubleTapEdit(fieldId, displayId, inputId, configKey) {
  const display = document.getElementById(displayId);
  const input = document.getElementById(inputId);
  let tapTimeout = null;

  display.onclick = () => {
    if (!tapTimeout) {
      tapTimeout = setTimeout(() => tapTimeout = null, 300);
    } else {
      clearTimeout(tapTimeout);
      tapTimeout = null;
      display.style.display = 'none';
      input.style.display = 'block';
      input.focus();
      input.select();
    }
  };

  input.onblur = () => {
    const value = input.value.trim();
    if (configKey === 'description' || value) {
      display.textContent = value || (configKey === 'description' ? 'No description set' : facetConfig.title);
      display.style.display = 'flex';
      input.style.display = 'none';
      saveFacetField(configKey, value, input);
    } else {
      input.value = display.textContent;
      display.style.display = 'flex';
      input.style.display = 'none';
    }
  };

  if (input.tagName !== 'TEXTAREA') {
    input.onkeydown = (e) => {
      if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
    };
  }
}

function setupEmojiPicker() {
  const display = document.getElementById('emojiDisplay');
  const input = document.getElementById('emojiInput');

  display.onclick = () => {
    input.style.display = 'block';
    input.focus();
  };

  input.onblur = () => {
    const value = input.value.trim();
    if (value && /\p{Emoji}/u.test(value)) {
      display.textContent = value;
      saveFacetField('emoji', value, input);
    }
    input.style.display = 'none';
    input.value = '';
  };

  input.onkeydown = (e) => {
    if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
  };
}

function setupColorPicker() {
  const modal = document.getElementById('colorPickerModal');
  const trigger = document.getElementById('colorTrigger');
  const closeBtn = document.querySelector('.color-close');
  const saveBtn = document.getElementById('saveColorBtn');
  const swatches = document.getElementById('colorSwatches');
  const picker = document.getElementById('customColorPicker');
  const hexInput = document.getElementById('customColorInput');

  let selectedColor = '#667eea';

  // Populate swatches
  const colors = ['#007bff','#28a745','#17a2b8','#ffc107','#6f42c1','#fd7e14','#e83e8c','#6c757d','#20c997','#ff5722','#9c27b0','#795548'];
  swatches.innerHTML = colors.map(c => `<div class="color-swatch" data-color="${c}" style="background:${c}"></div>`).join('');

  swatches.onclick = (e) => {
    if (e.target.classList.contains('color-swatch')) {
      selectedColor = e.target.dataset.color;
      updateColorUI(selectedColor);
    }
  };

  trigger.onclick = () => {
    selectedColor = facetConfig?.color || '#667eea';
    updateColorUI(selectedColor);
    modal.style.display = 'block';
  };

  closeBtn.onclick = () => modal.style.display = 'none';
  window.onclick = (e) => { if (e.target === modal) modal.style.display = 'none'; };

  picker.oninput = () => { selectedColor = picker.value; updateColorUI(selectedColor); };
  hexInput.oninput = () => {
    if (/^#[0-9A-Fa-f]{6}$/.test(hexInput.value)) {
      selectedColor = hexInput.value;
      updateColorUI(selectedColor);
    }
  };

  saveBtn.onclick = () => {
    if (/^#[0-9A-Fa-f]{6}$/.test(selectedColor)) {
      document.getElementById('colorPreview').style.backgroundColor = selectedColor;
      document.getElementById('colorHexDisplay').textContent = selectedColor;
      saveFacetField('color', selectedColor, null);
      modal.style.display = 'none';
    }
  };

  function updateColorUI(color) {
    picker.value = color;
    hexInput.value = color;
    document.querySelectorAll('.color-swatch').forEach(s => {
      s.classList.toggle('selected', s.dataset.color.toLowerCase() === color.toLowerCase());
    });
    // Update preview
    const preview = document.getElementById('modalPreview');
    preview.style.borderColor = color;
    preview.style.backgroundColor = color + '1a';
    document.getElementById('modalPreviewTitle').style.color = color;
    document.getElementById('modalPreviewEmoji').textContent = document.getElementById('emojiDisplay').textContent;
    document.getElementById('modalPreviewTitle').textContent = document.getElementById('facetTitleDisplay').textContent;
  }
}

function setupMutedToggle() {
  const toggle = document.getElementById('mutedToggle');
  toggle.onchange = () => {
    const muted = toggle.checked;
    document.getElementById('toggleLabel').textContent = muted ? 'Muted' : 'Active';
    saveFacetField('muted', muted, null);
  };
}

async function saveFacetField(field, value, triggerEl) {
  if (!window.selectedFacet) return;

  // Skip save if value unchanged
  if (JSON.stringify(facetConfig?.[field]) === JSON.stringify(value)) {
    return;
  }

  try {
    const response = await fetch(`/app/settings/api/facet/${window.selectedFacet}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ [field]: value })
    });
    const result = await response.json();
    if (result.success) {
      facetConfig = result.config;
      // Show inline status if we have a trigger element
      if (triggerEl) {
        showFieldStatus(triggerEl, 'saved');
      }
      // Prompt reload for changes that affect the facet bar
      if (field === 'title' || field === 'emoji' || field === 'color' || field === 'muted') {
        promptReload();
      }
    } else {
      throw new Error(result.error);
    }
  } catch (err) {
    console.error('Save error:', err);
    // For errors, use notification since they need attention and page won't reload
    notifyError( 'Save Failed', err.message);
  }
}

// ========== ACTIVITY LOG ==========
function loadLogs(facetName, cursor = null) {
  const url = cursor
    ? `/app/settings/api/facet/${facetName}/logs?cursor=${cursor}`
    : `/app/settings/api/facet/${facetName}/logs`;

  fetch(url)
    .then(r => r.json())
    .then(data => {
      renderLogDay(data, !cursor);
      logNextCursor = data.next_cursor;
      document.getElementById('logMore').style.display = logNextCursor ? 'block' : 'none';
    })
    .catch(err => {
      console.error('Error loading logs:', err);
      if (!cursor) {
        document.getElementById('logEntries').innerHTML = '<div class="log-empty">Error loading logs</div>';
      }
    });
}

function renderLogDay(data, isFirst) {
  const container = document.getElementById('logEntries');

  if (!data.day || !data.entries.length) {
    if (isFirst) container.innerHTML = '<div class="log-empty">No actions logged</div>';
    return;
  }

  if (isFirst) container.innerHTML = '';

  // Day separator
  const dayLabel = formatLogDay(data.day);
  container.innerHTML += `<div class="log-day"><span class="log-day-line"></span><span class="log-day-label">${dayLabel}</span><span class="log-day-line"></span></div>`;

  // Entries
  data.entries.forEach(entry => {
    const icon = entry.source === 'tool' ? '\uD83E\uDD16' : '\uD83D\uDC64';
    container.innerHTML += `<div class="log-row"><span class="log-icon">${icon}</span><span class="log-action">${entry.action}</span><span class="log-actor">${entry.actor}</span></div>`;
  });
}

function formatLogDay(day) {
  const today = new Date();
  const todayStr = today.toISOString().slice(0,10).replace(/-/g,'');
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toISOString().slice(0,10).replace(/-/g,'');

  if (day === todayStr) return 'Today';
  if (day === yesterdayStr) return 'Yesterday';

  const d = new Date(day.slice(0,4) + '-' + day.slice(4,6) + '-' + day.slice(6,8));
  return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

document.getElementById('logMoreBtn').onclick = () => {
  if (logNextCursor && window.selectedFacet) {
    loadLogs(window.selectedFacet, logNextCursor);
  }
};

// ========== SETUP / FIRST-RUN ==========
function checkShowSetup() {
  const hasFacets = window.facetsData && window.facetsData.length > 0;
  document.getElementById('setupSection').style.display = hasFacets ? 'none' : 'block';
}

document.getElementById('createPersonalBtn').onclick = async () => {
  const btn = document.getElementById('createPersonalBtn');
  btn.disabled = true;
  btn.textContent = 'Creating...';

  try {
    const response = await fetch('/app/settings/api/facet', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title: 'Personal', emoji: '\uD83C\uDFE0', color: '#007bff' })
    });
    const data = await response.json();
    if (data.success) {
      document.cookie = `selectedFacet=${data.facet}; path=/; SameSite=Lax`;
      window.location.href = '/app/home';
    } else {
      throw new Error(data.error);
    }
  } catch (err) {
    console.error('Error creating facet:', err);
    btn.disabled = false;
    btn.textContent = 'Create Personal Facet';
    notifyError( 'Creation Failed', err.message);
  }
};

// ========== PASSWORD/KEY TOGGLE ==========
// Handle all password toggle buttons (password field + API key fields)
document.querySelectorAll('.password-toggle').forEach(btn => {
  btn.onclick = () => {
    const targetId = btn.dataset.toggle || 'field-password';
    const input = document.getElementById(targetId);
    const icon = btn.querySelector('span');
    if (input && icon) {
      if (input.type === 'password') {
        input.type = 'text';
        icon.innerHTML = '&#128064;'; // eye with line
      } else {
        input.type = 'password';
        icon.innerHTML = '&#128065;'; // eye
      }
    }
  };
});

// ========== NOTIFICATIONS ==========
function notifyError(title, message) {
  if (window.AppServices?.notifications) {
    window.AppServices.notifications.show({
      app: 'settings',
      icon: '\u274C',
      title,
      message,
      dismissible: true,
      autoDismiss: 5000
    });
  }
}

let reloadPrompted = false;
function promptReload() {
  if (reloadPrompted) return;
  reloadPrompted = true;
  if (window.AppServices?.notifications) {
    window.AppServices.notifications.show({
      app: 'settings',
      icon: '\uD83D\uDD04',
      title: 'Reload to apply',
      message: 'Click to update facet bar',
      action: window.location.pathname,
      dismissible: true
    });
  }
}

// ========== PROVIDERS ==========
let providersData = null;

async function loadProviders() {
  try {
    const response = await fetch('api/providers');
    providersData = await response.json();
    if (providersData.error) throw new Error(providersData.error);
    populateProviders(providersData);
  } catch (err) {
    console.error('Error loading providers:', err);
    document.getElementById('providerStatus').textContent = 'Error loading providers';
  }
}

function populateProviders(data) {
  // Populate provider dropdown from registry
  const providerSelect = document.getElementById('field-provider');
  providerSelect.innerHTML = '';
  if (data.providers) {
    for (const p of data.providers) {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.label;
      providerSelect.appendChild(opt);
    }
  }

  // Populate backup provider dropdown
  const backupSelect = document.getElementById('field-backup-provider');
  backupSelect.innerHTML = '';
  if (data.providers) {
    for (const p of data.providers) {
      const opt = document.createElement('option');
      opt.value = p.name;
      opt.textContent = p.label;
      backupSelect.appendChild(opt);
    }
  }

  // Set default provider and tier
  providerSelect.value = data.default.provider;
  backupSelect.value = data.backup.provider;
  document.getElementById('field-tier').value = data.default.tier;

  // Update API key warning
  updateProviderKeyWarning(data.default.provider, data.api_keys);
  updateBackupProviderKeyWarning(data.backup.provider, data.api_keys);

  // Update status text
  document.getElementById('providerStatus').textContent = '';

  // Populate context overrides
  renderContextGroups(data);
}

function updateProviderKeyWarning(provider, apiKeys) {
  const warning = document.getElementById('providerKeyWarning');
  const link = document.getElementById('providerKeyLink');

  if (!apiKeys[provider]) {
    warning.style.display = 'flex';
    link.onclick = (e) => {
      e.preventDefault();
      switchSection('apikeys');
    };
  } else {
    warning.style.display = 'none';
  }
}

function updateBackupProviderKeyWarning(provider, apiKeys) {
  const warning = document.getElementById('backupProviderKeyWarning');
  const link = document.getElementById('backupProviderKeyLink');

  if (!apiKeys[provider]) {
    warning.style.display = 'flex';
    link.onclick = (e) => {
      e.preventDefault();
      switchSection('apikeys');
    };
  } else {
    warning.style.display = 'none';
  }
}

function renderContextGroups(data) {
  const container = document.getElementById('contextGroups');
  const contexts = data.context_defaults;
  const overrides = data.contexts || {};
  const defaultTier = data.default.tier;
  const providers = data.providers || [];

  // Group by group name
  const groups = {};
  for (const [pattern, ctx] of Object.entries(contexts)) {
    const group = ctx.group;
    if (!groups[group]) groups[group] = [];
    groups[group].push({ pattern, ...ctx });
  }

  // Build provider options HTML
  function buildProviderOptions(selectedProvider) {
    let opts = '<option value="">Default</option>';
    for (const p of providers) {
      const sel = selectedProvider === p.name ? 'selected' : '';
      opts += `<option value="${p.name}" ${sel}>${p.label}</option>`;
    }
    return opts;
  }

  // Render groups
  let html = '';
  for (const [groupName, items] of Object.entries(groups)) {
    html += `<div class="context-group">`;
    html += `<div class="context-group-label">${groupName}</div>`;

    for (const item of items) {
      const override = overrides[item.pattern];
      const hasOverride = !!override;
      // Check if built-in tier differs from user's default tier
      const builtInTier = item.tier;
      const showBuiltIn = !override?.tier && builtInTier !== defaultTier;

      html += `<div class="context-item" data-pattern="${item.pattern}">`;
      html += `<span class="context-label">${item.label}</span>`;
      html += `<div class="context-value">`;

      // Provider select - built dynamically from registry
      html += `<select class="context-select context-provider" data-pattern="${item.pattern}">`;
      html += buildProviderOptions(override?.provider);
      html += `</select>`;

      // Tier select - show built-in tier if it differs from default
      html += `<select class="context-select context-tier" data-pattern="${item.pattern}">`;
      html += `<option value="">Default</option>`;
      html += `<option value="1" ${override?.tier === 1 || (showBuiltIn && builtInTier === 1) ? 'selected' : ''}>Best</option>`;
      html += `<option value="2" ${override?.tier === 2 || (showBuiltIn && builtInTier === 2) ? 'selected' : ''}>Average</option>`;
      html += `<option value="3" ${override?.tier === 3 || (showBuiltIn && builtInTier === 3) ? 'selected' : ''}>Fast</option>`;
      html += `</select>`;

      // Action area (reset button or save indicator)
      html += `<span class="context-action" data-pattern="${item.pattern}">`;
      if (hasOverride) {
        html += `<button class="context-reset" data-pattern="${item.pattern}" title="Reset to default">&times;</button>`;
      }
      html += `</span>`;

      html += `</div></div>`;
    }
    html += `</div>`;
  }

  container.innerHTML = html;
  setupContextEventListeners();
}

function setupContextEventListeners() {
  // Provider select changes
  document.querySelectorAll('.context-provider').forEach(select => {
    select.addEventListener('change', () => {
      const pattern = select.dataset.pattern;
      const tierSelect = document.querySelector(`.context-tier[data-pattern="${pattern}"]`);
      saveContextOverride(pattern, select.value || null, tierSelect.value ? parseInt(tierSelect.value) : null);
    });
  });

  // Tier select changes
  document.querySelectorAll('.context-tier').forEach(select => {
    select.addEventListener('change', () => {
      const pattern = select.dataset.pattern;
      const providerSelect = document.querySelector(`.context-provider[data-pattern="${pattern}"]`);
      saveContextOverride(pattern, providerSelect.value || null, select.value ? parseInt(select.value) : null);
    });
  });

  // Reset buttons
  document.querySelectorAll('.context-reset').forEach(btn => {
    btn.addEventListener('click', () => {
      const pattern = btn.dataset.pattern;
      saveContextOverride(pattern, null, null, true);
    });
  });
}

async function saveContextOverride(pattern, provider, tier, remove = false) {
  try {
    const contexts = {};
    if (remove) {
      contexts[pattern] = null;
    } else if (provider || tier) {
      contexts[pattern] = {};
      if (provider) contexts[pattern].provider = provider;
      if (tier) contexts[pattern].tier = tier;
    } else {
      // Both empty means remove
      contexts[pattern] = null;
    }

    const response = await fetch('api/providers', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ contexts })
    });
    const result = await response.json();
    if (result.error) throw new Error(result.error);

    providersData = result;

    // Show save feedback and update action area
    const actionArea = document.querySelector(`.context-action[data-pattern="${pattern}"]`);
    if (actionArea) {
      const hasOverride = !!(result.contexts && result.contexts[pattern]);
      if (remove) {
        // Re-render needed when resetting to restore built-in tier selection
        renderContextGroups(result);
      } else {
        // Show checkmark, then update to show/hide reset button
        actionArea.innerHTML = `<span class="context-saved">\u2713</span>`;
        setTimeout(() => {
          const saved = actionArea.querySelector('.context-saved');
          if (saved) saved.classList.add('fade');
          setTimeout(() => {
            if (hasOverride) {
              actionArea.innerHTML = `<button class="context-reset" data-pattern="${pattern}" title="Reset to default">&times;</button>`;
              // Re-attach click handler for the new reset button
              actionArea.querySelector('.context-reset')?.addEventListener('click', () => {
                saveContextOverride(pattern, null, null, true);
              });
            } else {
              actionArea.innerHTML = '';
            }
          }, 300);
        }, 1000);
      }
    }
  } catch (err) {
    console.error('Error saving context override:', err);
    notifyError('Save Failed', err.message);
  }
}

// Provider change handlers
document.getElementById('field-provider').addEventListener('change', async () => {
  const provider = document.getElementById('field-provider').value;
  try {
    const response = await fetch('api/providers', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ default: { provider } })
    });
    const result = await response.json();
    if (result.error) throw new Error(result.error);

    providersData = result;
    updateProviderKeyWarning(provider, result.api_keys);
    showFieldStatus(document.getElementById('field-provider'), 'saved');
  } catch (err) {
    console.error('Error saving provider:', err);
    showFieldStatus(document.getElementById('field-provider'), 'error', err.message);
  }
});

document.getElementById('field-backup-provider').addEventListener('change', async () => {
  const provider = document.getElementById('field-backup-provider').value;
  try {
    const response = await fetch('api/providers', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ backup: { provider } })
    });
    const result = await response.json();
    if (result.error) throw new Error(result.error);

    providersData = result;
    updateBackupProviderKeyWarning(provider, result.api_keys);
    showFieldStatus(document.getElementById('field-backup-provider'), 'saved');
  } catch (err) {
    console.error('Error saving backup provider:', err);
    showFieldStatus(document.getElementById('field-backup-provider'), 'error', err.message);
  }
});

document.getElementById('field-tier').addEventListener('change', async () => {
  const tier = parseInt(document.getElementById('field-tier').value);
  try {
    const response = await fetch('api/providers', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ default: { tier } })
    });
    const result = await response.json();
    if (result.error) throw new Error(result.error);

    providersData = result;
    showFieldStatus(document.getElementById('field-tier'), 'saved');
  } catch (err) {
    console.error('Error saving tier:', err);
    showFieldStatus(document.getElementById('field-tier'), 'error', err.message);
  }
});

// ========== TRANSCRIPTION ==========
// Backend metadata loaded from API
let transcribeBackends = [];
let transcribeApiKeys = {};

async function loadTranscribeBackends() {
  try {
    const response = await fetch('api/transcribe');
    const data = await response.json();
    transcribeBackends = data.backends || [];
    transcribeApiKeys = data.api_keys || {};

    // Populate the backend select
    const select = document.getElementById('field-transcribe-backend');
    if (select) {
      select.innerHTML = '';
      for (const backend of transcribeBackends) {
        const option = document.createElement('option');
        option.value = backend.name;
        option.textContent = backend.label;
        select.appendChild(option);
      }
    }

    return data;
  } catch (err) {
    console.error('Error loading transcribe backends:', err);
    return null;
  }
}

function switchTranscribeBackend(backend, config) {
  // Show/hide backend-specific fieldsets
  document.getElementById('whisper-settings').style.display = backend === 'whisper' ? 'block' : 'none';
  document.getElementById('revai-settings').style.display = backend === 'revai' ? 'block' : 'none';
  document.getElementById('gemini-settings').style.display = backend === 'gemini' ? 'block' : 'none';

  // Find the backend metadata
  const backendInfo = transcribeBackends.find(b => b.name === backend);
  const warning = document.getElementById('backendKeyWarning');
  const warningText = document.getElementById('backendKeyWarningText');

  if (warning && backendInfo) {
    const envKey = backendInfo.env_key;
    // Show warning if backend requires API key and it's not configured
    if (envKey && !transcribeApiKeys[backend]) {
      warningText.textContent = `${envKey} not configured.`;
      warning.style.display = 'flex';
    } else {
      warning.style.display = 'none';
    }
  } else if (warning) {
    warning.style.display = 'none';
  }

  // Disable enrich toggle for gemini (it has integrated enrichment)
  const enrichCheckbox = document.getElementById('field-transcribe-enrich');
  const enrichField = enrichCheckbox?.closest('.settings-field');
  if (enrichCheckbox && enrichField) {
    const isGemini = backend === 'gemini';
    enrichCheckbox.disabled = isGemini;
    enrichField.style.opacity = isGemini ? '0.5' : '1';
    enrichField.title = isGemini ? 'Gemini includes integrated enrichment' : '';
  }
}

// Backend selector change handler
document.getElementById('field-transcribe-backend').addEventListener('change', async (e) => {
  const backend = e.target.value;
  switchTranscribeBackend(backend, configData);

  try {
    const response = await fetch('api/config', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ section: 'transcribe', data: { backend } })
    });
    const result = await response.json();
    if (result.success) {
      configData = result.config;
      showFieldStatus(e.target, 'saved');
    } else {
      throw new Error(result.error);
    }
  } catch (err) {
    console.error('Error saving backend:', err);
    showFieldStatus(e.target, 'error', err.message);
  }
});

// Backend key warning link
document.getElementById('backendKeyLink')?.addEventListener('click', (e) => {
  e.preventDefault();
  switchSection('apikeys');
});

// Whisper settings change handlers
['field-whisper-device', 'field-whisper-model', 'field-whisper-compute'].forEach(id => {
  document.getElementById(id)?.addEventListener('change', async (e) => {
    const key = id === 'field-whisper-device' ? 'device' :
                id === 'field-whisper-model' ? 'model' : 'compute_type';
    const value = e.target.value;

    try {
      const response = await fetch('api/config', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ section: 'transcribe', data: { whisper: { [key]: value } } })
      });
      const result = await response.json();
      if (result.success) {
        configData = result.config;
        showFieldStatus(e.target, 'saved');
      } else {
        throw new Error(result.error);
      }
    } catch (err) {
      console.error('Error saving whisper setting:', err);
      showFieldStatus(e.target, 'error', err.message);
    }
  });
});

// Rev.ai settings change handlers
document.getElementById('field-revai-model')?.addEventListener('change', async (e) => {
  const value = e.target.value;

  try {
    const response = await fetch('api/config', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ section: 'transcribe', data: { revai: { model: value } } })
    });
    const result = await response.json();
    if (result.success) {
      configData = result.config;
      showFieldStatus(e.target, 'saved');
    } else {
      throw new Error(result.error);
    }
  } catch (err) {
    console.error('Error saving revai setting:', err);
    showFieldStatus(e.target, 'error', err.message);
  }
});

// ========== OBSERVER ==========
let observeData = null;

async function loadObserve() {
  try {
    const response = await fetch('api/observe');
    observeData = await response.json();
    if (observeData.error) throw new Error(observeData.error);
    populateObserve(observeData);
  } catch (err) {
    console.error('Error loading observe config:', err);
  }
}

function populateObserve(data) {
  const tmux = data.tmux || {};
  const defaults = data.defaults?.tmux || { enabled: true, capture_interval: 5, capture_interval_min: 1, capture_interval_max: 60 };

  // Set current values
  document.getElementById('field-tmux-enabled').checked = tmux.enabled;
  document.getElementById('field-tmux-capture-interval').value = tmux.capture_interval;

  // Configure input constraints from API defaults
  const captureIntervalInput = document.getElementById('field-tmux-capture-interval');
  captureIntervalInput.min = defaults.capture_interval_min;
  captureIntervalInput.max = defaults.capture_interval_max;

  // Update helper text with default value
  const helpText = document.getElementById('tmuxCaptureIntervalHelp');
  if (helpText) {
    helpText.textContent = `How often to capture terminal content (default: ${defaults.capture_interval}s)`;
  }

  updateTmuxCaptureIntervalVisibility();
}

function updateTmuxCaptureIntervalVisibility() {
  const enabled = document.getElementById('field-tmux-enabled').checked;
  document.getElementById('tmuxCaptureIntervalField').style.opacity = enabled ? '1' : '0.5';
  document.getElementById('field-tmux-capture-interval').disabled = !enabled;
}

async function saveObserveSetting(key, value) {
  const tmuxData = {};
  tmuxData[key] = value;

  try {
    const response = await fetch('api/observe', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ tmux: tmuxData })
    });
    const result = await response.json();
    if (result.error) throw new Error(result.error);
    observeData = result;
    return true;
  } catch (err) {
    console.error('Error saving observe setting:', err);
    return false;
  }
}

// Event listeners for observer settings
document.getElementById('field-tmux-enabled').addEventListener('change', async function() {
  const enabled = this.checked;
  updateTmuxCaptureIntervalVisibility();

  const success = await saveObserveSetting('enabled', enabled);
  showFieldStatus(this, success ? 'saved' : 'error', success ? 'Saved' : 'Error saving');
});

document.getElementById('field-tmux-capture-interval').addEventListener('change', async function() {
  const defaults = observeData?.defaults?.tmux || { capture_interval: 5, capture_interval_min: 1, capture_interval_max: 60 };
  let captureInterval = parseInt(this.value, 10);

  // Clamp to valid range
  if (isNaN(captureInterval) || captureInterval < defaults.capture_interval_min) {
    captureInterval = defaults.capture_interval;
  } else if (captureInterval > defaults.capture_interval_max) {
    captureInterval = defaults.capture_interval_max;
  }
  this.value = captureInterval;

  const success = await saveObserveSetting('capture_interval', captureInterval);
  showFieldStatus(this, success ? 'saved' : 'error', success ? 'Saved' : 'Error saving');
});

// ========== VISION ==========
let visionData = null;

async function loadVision() {
  try {
    const response = await fetch('api/vision');
    visionData = await response.json();
    if (visionData.error) throw new Error(visionData.error);
    populateVision(visionData);
  } catch (err) {
    console.error('Error loading vision:', err);
    document.getElementById('visionCategoryGroups').textContent = 'Error loading categories';
  }
}

function populateVision(data) {
  // Set max extractions
  document.getElementById('field-max-extractions').value = data.max_extractions;

  // Render redaction rules
  renderRedactRules(data);

  // Render categories
  renderVisionCategories(data);
}

const IMPORTANCE_LEVELS = ['high', 'normal', 'low', 'ignore'];
const IMPORTANCE_LABELS = { high: 'High Priority', normal: 'Normal', low: 'Low Priority', ignore: 'Ignored' };

function renderVisionCategories(data) {
  const container = document.getElementById('visionCategoryGroups');
  const defaults = data.category_defaults;
  const overrides = data.categories || {};

  // Group by effective importance level
  const groups = { high: [], normal: [], low: [], ignore: [] };
  for (const [name, cat] of Object.entries(defaults)) {
    const override = overrides[name] || {};
    const defaultImportance = cat.importance || 'normal';
    const importance = override.importance || defaultImportance;
    groups[importance].push({ name, ...cat, currentImportance: importance });
  }

  // Render importance sections in order
  let html = '';
  for (const level of IMPORTANCE_LEVELS) {
    const items = groups[level].sort((a, b) => a.label.localeCompare(b.label));
    const isFirst = level === 'high';
    const isLast = level === 'ignore';

    html += `<div class="importance-section importance-${level}">`;
    html += `<div class="importance-section-header">${IMPORTANCE_LABELS[level]}</div>`;

    if (items.length === 0) {
      html += `<div class="importance-section-empty">No categories</div>`;
    } else {
      for (const item of items) {
        const override = overrides[item.name] || {};
        const extraction = override.extraction || '';
        const defaultExtraction = item.extraction || '';

        html += `<div class="vision-category-item" data-category="${item.name}" data-importance="${level}">`;
        html += `<div class="context-item" style="margin-bottom:0.25em;">`;
        html += `<span class="context-label">${item.label}</span>`;
        html += `<div class="context-value">`;

        // Move buttons
        html += `<div class="vision-move-buttons">`;
        html += `<button class="vision-move-btn vision-move-up" data-category="${item.name}" title="Move up" ${isFirst ? 'disabled' : ''}>↑</button>`;
        html += `<button class="vision-move-btn vision-move-down" data-category="${item.name}" title="Move down" ${isLast ? 'disabled' : ''}>↓</button>`;
        html += `</div>`;

        // Reset button
        html += `<span class="context-action" data-category="${item.name}">`;
        if (override.importance || override.extraction) {
          html += `<button class="context-reset vision-reset" data-category="${item.name}" title="Reset to default">&times;</button>`;
        }
        html += `</span>`;

        html += `</div></div>`;

        // Extraction text (double-click to edit, disabled when importance is ignore)
        const isIgnored = level === 'ignore';
        const effectiveExtraction = extraction || defaultExtraction;
        const isOverride = !!extraction;
        html += `<div class="vision-extraction" data-category="${item.name}" style="padding-left:0.5em;">`;
        if (isIgnored) {
          html += `<span class="vision-extraction-display vision-extraction-disabled">Disabled for ignored categories</span>`;
        } else if (effectiveExtraction) {
          html += `<span class="vision-extraction-display${isOverride ? '' : ' vision-extraction-default'}" data-category="${item.name}" data-default="${escapeAttr(defaultExtraction)}">${escapeAttr(effectiveExtraction)}</span>`;
        } else {
          html += `<span class="vision-extraction-display vision-extraction-empty" data-category="${item.name}" data-default="">No extraction guidance</span>`;
        }
        html += `<input type="text" class="vision-extraction-input" data-category="${item.name}" value="${escapeAttr(extraction)}" data-default="${escapeAttr(defaultExtraction)}" style="display:none;">`;
        html += `</div>`;

        html += `</div>`;
      }
    }
    html += `</div>`;
  }

  container.innerHTML = html;
  setupVisionEventListeners();
}

function escapeAttr(str) {
  return str.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function setupVisionEventListeners() {
  // Move up/down buttons
  document.querySelectorAll('.vision-move-up').forEach(btn => {
    btn.addEventListener('click', () => {
      const category = btn.dataset.category;
      const item = btn.closest('.vision-category-item');
      const currentLevel = item.dataset.importance;
      const currentIndex = IMPORTANCE_LEVELS.indexOf(currentLevel);
      if (currentIndex > 0) {
        const newLevel = IMPORTANCE_LEVELS[currentIndex - 1];
        item.classList.add('moving');
        const extractionInput = document.querySelector(`.vision-extraction-input[data-category="${category}"]`);
        saveVisionCategory(category, newLevel, extractionInput.value);
      }
    });
  });

  document.querySelectorAll('.vision-move-down').forEach(btn => {
    btn.addEventListener('click', () => {
      const category = btn.dataset.category;
      const item = btn.closest('.vision-category-item');
      const currentLevel = item.dataset.importance;
      const currentIndex = IMPORTANCE_LEVELS.indexOf(currentLevel);
      if (currentIndex < IMPORTANCE_LEVELS.length - 1) {
        const newLevel = IMPORTANCE_LEVELS[currentIndex + 1];
        item.classList.add('moving');
        const extractionInput = document.querySelector(`.vision-extraction-input[data-category="${category}"]`);
        saveVisionCategory(category, newLevel, extractionInput.value);
      }
    });
  });

  // Double-click to edit extraction guidance
  document.querySelectorAll('.vision-extraction-display[data-category]').forEach(display => {
    let tapTimeout = null;
    display.addEventListener('click', () => {
      if (!tapTimeout) {
        tapTimeout = setTimeout(() => tapTimeout = null, 300);
      } else {
        clearTimeout(tapTimeout);
        tapTimeout = null;
        // Switch to edit mode
        const category = display.dataset.category;
        const input = document.querySelector(`.vision-extraction-input[data-category="${category}"]`);
        const defaultVal = display.dataset.default || '';
        // If showing default, populate input with it for easy editing
        if (display.classList.contains('vision-extraction-default') || display.classList.contains('vision-extraction-empty')) {
          input.value = defaultVal;
        }
        display.style.display = 'none';
        input.style.display = 'block';
        input.focus();
        input.select();
      }
    });
  });

  // Blur to save and return to display mode
  document.querySelectorAll('.vision-extraction-input').forEach(input => {
    input.addEventListener('blur', () => {
      const category = input.dataset.category;
      const display = document.querySelector(`.vision-extraction-display[data-category="${category}"]`);
      const item = document.querySelector(`.vision-category-item[data-category="${category}"]`);
      const currentLevel = item.dataset.importance;
      const value = input.value.trim();
      const defaultVal = input.dataset.default || '';

      // Update display
      if (value) {
        display.textContent = value;
        display.classList.remove('vision-extraction-default', 'vision-extraction-empty');
      } else if (defaultVal) {
        display.textContent = defaultVal;
        display.classList.remove('vision-extraction-empty');
        display.classList.add('vision-extraction-default');
      } else {
        display.textContent = 'No extraction guidance';
        display.classList.remove('vision-extraction-default');
        display.classList.add('vision-extraction-empty');
      }

      // Switch back to display mode
      input.style.display = 'none';
      display.style.display = 'block';

      // Save
      saveVisionCategory(category, currentLevel, value);
    });

    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        input.blur();
      } else if (e.key === 'Escape') {
        // Cancel edit - restore original value
        const category = input.dataset.category;
        const override = visionData?.categories?.[category]?.extraction || '';
        input.value = override;
        input.blur();
      }
    });
  });

  // Reset buttons
  document.querySelectorAll('.vision-reset').forEach(btn => {
    btn.addEventListener('click', () => {
      const category = btn.dataset.category;
      saveVisionCategory(category, null, null, true);
    });
  });

  // Max extractions change
  document.getElementById('field-max-extractions').addEventListener('change', saveMaxExtractions);
}

async function saveVisionCategory(category, importance, extraction, remove = false) {
  try {
    const categories = {};
    if (remove) {
      categories[category] = null;
    } else {
      categories[category] = {};
      // Only save importance if it differs from category default
      const defaultImportance = visionData?.category_defaults?.[category]?.importance || 'normal';
      if (importance && importance !== defaultImportance) {
        categories[category].importance = importance;
      }
      if (extraction) {
        categories[category].extraction = extraction;
      }
      // If both are default/empty, remove the override
      if (!categories[category].importance && !categories[category].extraction) {
        categories[category] = null;
      }
    }

    const response = await fetch('api/vision', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ categories })
    });

    const result = await response.json();
    if (result.error) throw new Error(result.error);

    // Refresh to update reset buttons
    visionData = result;
    renderVisionCategories(result);
  } catch (err) {
    console.error('Error saving vision category:', err);
    notifyError('Save Failed', err.message);
  }
}

async function saveMaxExtractions() {
  const input = document.getElementById('field-max-extractions');
  const value = parseInt(input.value);

  if (isNaN(value) || value < 5 || value > 100) {
    input.value = visionData?.max_extractions || 20;
    return;
  }

  try {
    const response = await fetch('api/vision', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ max_extractions: value })
    });

    const result = await response.json();
    if (result.error) throw new Error(result.error);

    visionData = result;
    showFieldStatus(input, 'saved');
  } catch (err) {
    console.error('Error saving max extractions:', err);
    showFieldStatus(input, 'error', err.message);
  }
}

function renderRedactRules(data) {
  const container = document.getElementById('redactRulesList');
  const rules = data.redact || [];

  if (rules.length === 0) {
    container.innerHTML = '<div class="redact-empty">No redaction rules configured</div>';
    return;
  }

  container.innerHTML = rules.map((rule, index) => `
    <div class="redact-item" data-index="${index}">
      <span class="redact-text" data-index="${index}">${escapeHtml(rule)}</span>
      <input type="text" class="redact-input" data-index="${index}" value="${escapeHtml(rule)}" maxlength="200" style="display:none">
      <button class="redact-remove" data-index="${index}" title="Remove">&times;</button>
    </div>
  `).join('');

  setupRedactListeners();
}

function setupRedactListeners() {
  // Double-click to edit (tap-timeout pattern matching vision categories)
  document.querySelectorAll('.redact-text').forEach(display => {
    let tapTimeout = null;
    display.addEventListener('click', () => {
      if (!tapTimeout) {
        tapTimeout = setTimeout(() => tapTimeout = null, 300);
      } else {
        clearTimeout(tapTimeout);
        tapTimeout = null;
        const index = display.dataset.index;
        const input = document.querySelector(`.redact-input[data-index="${index}"]`);
        display.style.display = 'none';
        input.style.display = 'block';
        input.focus();
        input.select();
      }
    });
  });

  // Edit input: blur saves, Enter commits, Escape cancels
  document.querySelectorAll('.redact-input').forEach(input => {
    input.addEventListener('blur', () => {
      const index = parseInt(input.dataset.index);
      const display = document.querySelector(`.redact-text[data-index="${index}"]`);
      const newValue = input.value.trim();

      input.style.display = 'none';
      display.style.display = 'block';

      if (!newValue) {
        // Empty = remove the rule
        removeRedactRule(index);
        return;
      }

      if (newValue.length > 200) {
        showRedactValidation('Rule must be 200 characters or less');
        input.value = display.textContent;
        return;
      }

      const rules = [...(visionData?.redact || [])];
      if (rules[index] !== newValue) {
        rules[index] = newValue;
        saveRedactRules(rules);
      }
    });

    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        input.blur();
      } else if (e.key === 'Escape') {
        const index = parseInt(input.dataset.index);
        input.value = (visionData?.redact || [])[index] || '';
        input.blur();
      }
    });
  });

  // Remove buttons
  document.querySelectorAll('.redact-remove').forEach(btn => {
    btn.addEventListener('click', () => {
      const index = parseInt(btn.dataset.index);
      removeRedactRule(index);
    });
  });
}

function removeRedactRule(index) {
  const rules = [...(visionData?.redact || [])];
  rules.splice(index, 1);
  saveRedactRules(rules);
}

async function saveRedactRules(rules) {
  try {
    const response = await fetch('api/vision', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ redact: rules })
    });

    const result = await response.json();
    if (result.error) throw new Error(result.error);

    visionData = result;
    renderRedactRules(result);
  } catch (err) {
    console.error('Error saving redaction rules:', err);
    notifyError('Save Failed', err.message);
  }
}

function showRedactValidation(message) {
  const el = document.getElementById('redactValidation');
  el.textContent = message;
  el.style.display = 'block';
  setTimeout(() => { el.style.display = 'none'; }, 3000);
}

document.getElementById('redactAddBtn').addEventListener('click', () => {
  addRedactRule();
});

document.getElementById('redactAddInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    addRedactRule();
  }
});

function addRedactRule() {
  const input = document.getElementById('redactAddInput');
  const value = input.value.trim();

  if (!value) return;

  if (value.length > 200) {
    showRedactValidation('Rule must be 200 characters or less');
    return;
  }

  const rules = [...(visionData?.redact || [])];

  if (rules.length >= 50) {
    showRedactValidation('Maximum of 50 rules allowed');
    return;
  }

  rules.push(value);
  input.value = '';
  saveRedactRules(rules);
}

document.getElementById('visionRedactionHeader').addEventListener('click', () => {
  document.getElementById('visionRedaction').classList.toggle('expanded');
});

// Toggle vision categories expansion
document.getElementById('visionCategoriesHeader').addEventListener('click', () => {
  document.getElementById('visionCategories').classList.toggle('expanded');
});

// ========== INSIGHTS ==========

async function loadInsights() {
  try {
    const response = await fetch('api/generators');
    insightsData = await response.json();
    if (insightsData.error) throw new Error(insightsData.error);
    populateInsights(insightsData);
  } catch (err) {
    console.error('Error loading insights:', err);
    document.getElementById('segmentInsightsList').textContent = 'Error loading insights';
    document.getElementById('dailyInsightsList').textContent = 'Error loading insights';
  }
}

function populateInsights(data) {
  // Update counts
  const segmentEnabled = data.segment.filter(i => !i.disabled).length;
  const dailyEnabled = data.daily.filter(i => !i.disabled).length;
  document.getElementById('segmentInsightsCount').textContent = `(${segmentEnabled}/${data.segment.length} enabled)`;
  document.getElementById('dailyInsightsCount').textContent = `(${dailyEnabled}/${data.daily.length} enabled)`;

  // Render lists
  document.getElementById('segmentInsightsList').innerHTML = renderInsightsList(data.segment);
  document.getElementById('dailyInsightsList').innerHTML = renderInsightsList(data.daily);

  // Setup event listeners
  setupInsightsEventListeners();
}

function renderInsightsList(insights) {
  if (insights.length === 0) {
    return '<div style="color:#999;font-style:italic;padding:0.5em;">No insights</div>';
  }

  // Group by source
  const groups = {};
  for (const insight of insights) {
    const source = insight.source === 'system' ? 'System' : (insight.app || 'App');
    if (!groups[source]) groups[source] = [];
    groups[source].push(insight);
  }

  let html = '';
  const sortedSources = Object.keys(groups).sort((a, b) => {
    // System first, then alphabetically
    if (a === 'System') return -1;
    if (b === 'System') return 1;
    return a.localeCompare(b);
  });

  for (const source of sortedSources) {
    const sourceInsights = groups[source];
    html += `<div class="insight-source-group">`;
    if (sortedSources.length > 1 || source !== 'System') {
      html += `<div class="insight-source-label">${source}</div>`;
    }

    for (const insight of sourceInsights) {
      const isDisabled = insight.disabled;
      const hasExtraction = insight.has_extraction;
      const extractEnabled = insight.extract !== false;

      html += `<div class="insight-row${isDisabled ? ' insight-disabled' : ''}" data-insight="${insight.key}">`;
      html += `<div class="insight-info">`;
      html += `<div class="insight-title">${escapeAttr(insight.title)}</div>`;
      if (insight.description) {
        html += `<div class="insight-desc">${escapeAttr(insight.description)}</div>`;
      }
      html += `</div>`;

      html += `<div class="insight-controls">`;

      // Extract toggle (only if insight supports extraction)
      if (hasExtraction) {
        html += `<div class="insight-toggle-group">`;
        html += `<span class="insight-toggle-label">Extract</span>`;
        html += `<label class="insight-toggle">`;
        html += `<input type="checkbox" data-insight="${insight.key}" data-field="extract" ${extractEnabled ? 'checked' : ''} ${isDisabled ? 'disabled' : ''}>`;
        html += `<span class="slider"></span>`;
        html += `</label>`;
        html += `</div>`;
      }

      // Enabled toggle
      html += `<div class="insight-toggle-group">`;
      html += `<span class="insight-toggle-label">Enabled</span>`;
      html += `<label class="insight-toggle">`;
      html += `<input type="checkbox" data-insight="${insight.key}" data-field="disabled" ${!isDisabled ? 'checked' : ''}>`;
      html += `<span class="slider"></span>`;
      html += `</label>`;
      html += `</div>`;

      html += `</div>`;
      html += `</div>`;
    }
    html += `</div>`;
  }

  return html;
}

function setupInsightsEventListeners() {
  // Handle toggle changes
  document.querySelectorAll('.insight-row input[type="checkbox"]').forEach(input => {
    input.addEventListener('change', async (e) => {
      const insightKey = e.target.dataset.insight;
      const field = e.target.dataset.field;
      const row = e.target.closest('.insight-row');

      if (field === 'disabled') {
        // Enabled toggle: checked = enabled = disabled:false
        const disabled = !e.target.checked;
        await saveInsightSetting(insightKey, 'disabled', disabled);

        // Update row styling and disable/enable other toggles
        row.classList.toggle('insight-disabled', disabled);
        const extractToggle = row.querySelector('input[data-field="extract"]');
        if (extractToggle) {
          extractToggle.disabled = disabled;
        }
      } else if (field === 'extract') {
        await saveInsightSetting(insightKey, 'extract', e.target.checked);
      }
    });
  });
}

async function saveInsightSetting(insightKey, field, value) {
  try {
    const payload = {
      [insightKey]: { [field]: value }
    };

    const response = await fetch('api/generators', {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    const result = await response.json();
    if (result.error) throw new Error(result.error);

    // Update local state
    insightsData = result;

    // Update counts
    const segmentEnabled = result.segment.filter(i => !i.disabled).length;
    const dailyEnabled = result.daily.filter(i => !i.disabled).length;
    document.getElementById('segmentInsightsCount').textContent = `(${segmentEnabled}/${result.segment.length} enabled)`;
    document.getElementById('dailyInsightsCount').textContent = `(${dailyEnabled}/${result.daily.length} enabled)`;

  } catch (err) {
    console.error('Error saving insight setting:', err);
    // Revert the toggle on error
    loadInsights();
  }
}

// Toggle insights groups expansion
document.getElementById('segmentInsightsHeader').addEventListener('click', () => {
  document.getElementById('segmentInsightsGroup').classList.toggle('expanded');
});
document.getElementById('dailyInsightsHeader').addEventListener('click', () => {
  document.getElementById('dailyInsightsGroup').classList.toggle('expanded');
});

// ========== ACTIVITIES ==========
let activitiesData = null;

async function loadActivities(facetName) {
  if (!facetName) return;

  try {
    const response = await fetch(`/app/settings/api/facet/${facetName}/activities`);
    activitiesData = await response.json();
    if (activitiesData.error) throw new Error(activitiesData.error);
    renderActivities(activitiesData);
  } catch (err) {
    console.error('Error loading activities:', err);
    document.getElementById('attachedActivitiesList').innerHTML = '<div class="activities-empty">Error loading activities</div>';
  }
}

function renderActivities(data) {
  const attachedList = document.getElementById('attachedActivitiesList');
  const defaultsList = document.getElementById('defaultActivitiesList');
  const countEl = document.getElementById('attachedActivitiesCount');

  const attached = data.activities || [];
  const defaults = data.defaults || [];

  // Render attached activities
  if (attached.length === 0) {
    attachedList.innerHTML = '<div class="activities-empty">No activities attached yet. Add activities below.</div>';
    countEl.textContent = '';
  } else {
    countEl.textContent = `(${attached.length})`;
    attachedList.innerHTML = attached.map(a => `
      <div class="activity-item" data-id="${a.id}">
        <span class="activity-icon">${a.icon || '📌'}</span>
        <div class="activity-info">
          <div class="activity-name">${escapeHtml(a.name)}</div>
          <div class="activity-desc activity-desc-editable" data-id="${a.id}" title="Double-click to edit">${escapeHtml(a.description) || '<em>No description</em>'}</div>
        </div>
        <div class="activity-controls">
          <select class="activity-priority" data-id="${a.id}">
            <option value="high" ${a.priority === 'high' ? 'selected' : ''}>High</option>
            <option value="normal" ${a.priority === 'normal' ? 'selected' : ''}>Normal</option>
            <option value="low" ${a.priority === 'low' ? 'selected' : ''}>Low</option>
          </select>
          <button class="activity-remove" data-id="${a.id}" title="Remove">&times;</button>
        </div>
      </div>
    `).join('');

    // Set up event listeners for attached activities
    setupAttachedActivityListeners();
  }

  // Render default activities as chips (exclude already attached)
  const attachedIds = new Set(attached.map(a => a.id));
  const availableDefaults = defaults.filter(d => !attachedIds.has(d.id));

  if (availableDefaults.length === 0 && attached.length > 0) {
    defaultsList.innerHTML = '<span style="color:#888;font-size:0.85em;">All default activities attached</span>';
  } else {
    defaultsList.innerHTML = defaults.map(d => {
      const isAttached = attachedIds.has(d.id);
      return `
        <span class="activity-chip ${isAttached ? 'activity-chip-attached' : ''}" data-id="${d.id}" ${isAttached ? '' : 'title="Click to add"'}>
          <span class="activity-chip-icon">${d.icon || '📌'}</span>
          <span>${escapeHtml(d.name)}</span>
        </span>
      `;
    }).join('');

    // Set up click handlers for chips
    defaultsList.querySelectorAll('.activity-chip:not(.activity-chip-attached)').forEach(chip => {
      chip.addEventListener('click', () => addDefaultActivity(chip.dataset.id));
    });
  }
}

function setupAttachedActivityListeners() {
  // Priority change
  document.querySelectorAll('.activity-priority').forEach(select => {
    select.addEventListener('change', async () => {
      const activityId = select.dataset.id;
      const priority = select.value;
      await updateActivity(activityId, { priority });
    });
  });

  // Remove button
  document.querySelectorAll('.activity-remove').forEach(btn => {
    btn.addEventListener('click', async () => {
      const activityId = btn.dataset.id;
      await removeActivity(activityId);
    });
  });

  // Double-click description to edit
  document.querySelectorAll('.activity-desc-editable').forEach(desc => {
    let tapTimeout = null;
    desc.addEventListener('click', () => {
      if (!tapTimeout) {
        tapTimeout = setTimeout(() => tapTimeout = null, 300);
      } else {
        clearTimeout(tapTimeout);
        tapTimeout = null;
        startEditDescription(desc);
      }
    });
  });
}

function startEditDescription(descEl) {
  const activityId = descEl.dataset.id;
  const currentText = descEl.textContent.trim();
  const isPlaceholder = descEl.querySelector('em') !== null;

  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'activity-desc-input';
  input.value = isPlaceholder ? '' : currentText;
  input.style.cssText = 'width:100%;padding:0.3em;font-size:0.85em;border:1px solid var(--facet-color,#667eea);border-radius:4px;';

  descEl.style.display = 'none';
  descEl.parentNode.insertBefore(input, descEl.nextSibling);
  input.focus();
  input.select();

  const finishEdit = async () => {
    const newDesc = input.value.trim();
    input.remove();
    descEl.style.display = '';
    descEl.innerHTML = newDesc ? escapeHtml(newDesc) : '<em>No description</em>';

    if (newDesc !== currentText && !(isPlaceholder && !newDesc)) {
      await updateActivity(activityId, { description: newDesc });
    }
  };

  input.addEventListener('blur', finishEdit);
  input.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
    if (e.key === 'Escape') { input.value = isPlaceholder ? '' : currentText; input.blur(); }
  });
}

async function addDefaultActivity(activityId) {
  if (!window.selectedFacet) return;

  try {
    const response = await fetch(`/app/settings/api/facet/${window.selectedFacet}/activities`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id: activityId })
    });
    const result = await response.json();
    if (result.error) throw new Error(result.error);

    // Reload activities
    await loadActivities(window.selectedFacet);
  } catch (err) {
    console.error('Error adding activity:', err);
    notifyError('Add Failed', err.message);
  }
}

async function updateActivity(activityId, updates) {
  if (!window.selectedFacet) return;

  try {
    const response = await fetch(`/app/settings/api/facet/${window.selectedFacet}/activities/${activityId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates)
    });
    const result = await response.json();
    if (result.error) throw new Error(result.error);
  } catch (err) {
    console.error('Error updating activity:', err);
    notifyError('Update Failed', err.message);
    // Reload to revert
    await loadActivities(window.selectedFacet);
  }
}

async function removeActivity(activityId) {
  if (!window.selectedFacet) return;

  try {
    const response = await fetch(`/app/settings/api/facet/${window.selectedFacet}/activities/${activityId}`, {
      method: 'DELETE'
    });
    const result = await response.json();
    if (result.error) throw new Error(result.error);

    // Reload activities
    await loadActivities(window.selectedFacet);
  } catch (err) {
    console.error('Error removing activity:', err);
    notifyError('Remove Failed', err.message);
  }
}

// Custom activity modal
document.getElementById('addCustomActivityBtn').addEventListener('click', () => {
  document.getElementById('customActivityModal').style.display = 'block';
  document.getElementById('customActivityName').value = '';
  document.getElementById('customActivityDesc').value = '';
  document.getElementById('customActivityIcon').value = '';
  document.getElementById('customActivityName').focus();
});

document.getElementById('customActivityClose').addEventListener('click', () => {
  document.getElementById('customActivityModal').style.display = 'none';
});

document.getElementById('saveCustomActivityBtn').addEventListener('click', async () => {
  const name = document.getElementById('customActivityName').value.trim();
  const description = document.getElementById('customActivityDesc').value.trim();
  const icon = document.getElementById('customActivityIcon').value.trim();

  if (!name) {
    notifyError('Validation Error', 'Name is required');
    return;
  }

  if (!window.selectedFacet) return;

  try {
    const response = await fetch(`/app/settings/api/facet/${window.selectedFacet}/activities`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, description, icon: icon || undefined })
    });
    const result = await response.json();
    if (result.error) throw new Error(result.error);

    document.getElementById('customActivityModal').style.display = 'none';
    await loadActivities(window.selectedFacet);
  } catch (err) {
    console.error('Error adding custom activity:', err);
    notifyError('Add Failed', err.message);
  }
});

// Close modal on outside click
window.addEventListener('click', (e) => {
  const modal = document.getElementById('customActivityModal');
  if (e.target === modal) modal.style.display = 'none';
});

function escapeHtml(str) {
  if (!str) return '';
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
}

// ========== INIT ==========
updateFacetNav();
initFromHash();
loadConfig();
loadProviders();
loadObserve();
loadVision();
loadInsights();
setupAutoSave();

// If facet is selected on load, load its config
if (window.selectedFacet) {
  loadFacetConfig(window.selectedFacet);
}
</script>
