<style>
/* Live Dashboard Layout */
.live-dashboard {
  padding: 1em;
  max-width: 1400px;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  gap: 1em;
}

/* Vitals Bar (Full Width) */
.vitals-bar {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-radius: 12px;
  padding: 1.5em;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.vitals-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5em;
}

.vitals-title {
  font-size: 1.2em;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5em;
}

.vitals-status {
  background: rgba(255,255,255,0.2);
  padding: 0.4em 0.8em;
  border-radius: 20px;
  font-size: 0.9em;
  display: flex;
  align-items: center;
  gap: 0.5em;
}

.vitals-content {
  display: flex;
  flex-wrap: wrap;
  gap: 1.5em;
  font-size: 0.95em;
}

.vitals-section {
  display: flex;
  flex-direction: column;
  gap: 0.3em;
}

.vitals-label {
  opacity: 0.8;
  font-size: 0.85em;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.vitals-value {
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.5em;
}

.service-dots {
  display: flex;
  gap: 0.4em;
  flex-wrap: wrap;
}

.service-dot {
  display: inline-flex;
  align-items: center;
  gap: 0.3em;
  background: rgba(255,255,255,0.15);
  padding: 0.2em 0.6em;
  border-radius: 12px;
  font-size: 0.85em;
}

.service-dot.crashed {
  background: rgba(248, 113, 113, 0.3);
}

.status-indicator {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

.status-indicator.active { background: #4ade80; }
.status-indicator.crashed { background: #f87171; }
.status-indicator.restarting { background: #fbbf24; }
.status-indicator.inactive { background: #9ca3af; }

/* Observe Card (Prominent) */
.observe-card {
  background: white;
  border-radius: 12px;
  padding: 1.5em;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  border-left: 4px solid #10b981;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1em;
}

.card-title {
  font-size: 1.1em;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 0.5em;
}

.live-badge {
  background: #dc2626;
  color: white;
  padding: 0.2em 0.6em;
  border-radius: 12px;
  font-size: 0.75em;
  display: flex;
  align-items: center;
  gap: 0.3em;
  animation: pulse 2s infinite;
}

.live-badge.idle {
  background: #6b7280;
  animation: none;
}

.live-badge.tmux {
  background: #8b5cf6;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.6; }
}

.observe-content {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 1em;
}

.observe-section {
  display: flex;
  flex-direction: column;
  gap: 0.4em;
}

.observe-section-title {
  font-size: 0.85em;
  color: #6b7280;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-weight: 500;
}

.observe-section-value {
  font-size: 1em;
  color: #111827;
  font-weight: 500;
}

.observe-section-detail {
  font-size: 0.85em;
  color: #6b7280;
  padding-left: 1em;
}

/* Remote Observers Card */
.remotes-card {
  background: white;
  border-radius: 12px;
  padding: 1.5em;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  border-left: 4px solid #8b5cf6;
}

.remotes-card.hidden {
  display: none;
}

.remotes-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 1em;
}

.remote-card {
  background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
  border-radius: 8px;
  padding: 1em;
  display: flex;
  flex-direction: column;
  gap: 0.4em;
  border: 2px solid transparent;
}

.remote-card.active {
  background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%);
  border-color: #8b5cf6;
}

.remote-card.stale {
  background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
  border-color: #f59e0b;
}

.remote-card-name {
  font-size: 0.95em;
  font-weight: 600;
  color: #111827;
}

.remote-card-host {
  font-size: 0.8em;
  color: #6b7280;
}

.remote-card-status {
  font-size: 0.85em;
  color: #374151;
}

/* Activity Grids Container */
.activity-grids {
  display: flex;
  flex-direction: column;
  gap: 1em;
}

.activity-section {
  background: white;
  border-radius: 12px;
  padding: 1.5em;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.activity-section.hidden {
  display: none;
}

.activity-section-header {
  font-size: 1em;
  font-weight: 600;
  color: #374151;
  margin-bottom: 1em;
  display: flex;
  align-items: center;
  gap: 0.5em;
}

.activity-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
  gap: 1em;
}

/* Agent/Import Cards (Square) */
.activity-card {
  background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
  border-radius: 8px;
  padding: 1em;
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  border: 2px solid transparent;
  transition: all 0.3s ease;
  cursor: pointer;
  min-height: 140px;
}

.activity-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.activity-card.agent-active {
  background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
  border-color: #3b82f6;
}

.activity-card.import-active {
  background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
  border-color: #f59e0b;
}

.activity-card.import-error {
  background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
  border-color: #ef4444;
}

.activity-card-id {
  font-size: 0.75em;
  color: #6b7280;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
}

.activity-card-name {
  font-size: 0.95em;
  font-weight: 600;
  color: #111827;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.activity-card-state {
  font-size: 0.85em;
  color: #374151;
  display: flex;
  align-items: center;
  gap: 0.3em;
}

.activity-card-error {
  font-size: 0.75em;
  color: #dc2626;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.activity-card-elapsed {
  font-size: 0.8em;
  color: #6b7280;
  margin-top: auto;
}

.activity-card-provider {
  font-size: 0.75em;
  color: #6b7280;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.activity-card-progress {
  width: 100%;
  height: 4px;
  background: rgba(0,0,0,0.1);
  border-radius: 2px;
  overflow: hidden;
}

.activity-card-progress-bar {
  height: 100%;
  background: #3b82f6;
  transition: width 0.3s ease;
}

/* Events Card */
.events-card {
  background: white;
  border-radius: 12px;
  padding: 1.5em;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.events-card.paused {
  border-left: 4px solid #f59e0b;
}

.events-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1em;
}

.events-title {
  font-size: 1.1em;
  font-weight: 600;
}

.events-controls {
  display: flex;
  align-items: center;
  gap: 1em;
}

.pause-btn {
  background: #3b82f6;
  color: white;
  border: none;
  padding: 0.5em 1em;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85em;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 0.4em;
  transition: background 0.2s;
}

.pause-btn:hover {
  background: #2563eb;
}

.pause-btn.paused {
  background: #f59e0b;
}

.pause-btn.paused:hover {
  background: #d97706;
}

.missed-count {
  font-size: 0.85em;
  color: #f59e0b;
  font-weight: 500;
}

.event-log {
  height: 400px;
  overflow-y: auto;
  font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
  font-size: 12px;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  padding: 0.5em;
  background: #f9fafb;
}

.event-line {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 3px 0;
  border-bottom: 1px solid #f3f4f6;
  color: #374151;
}

.event-line:last-child {
  border-bottom: none;
}

.event-line.error {
  color: #dc2626;
  background: #fef2f2;
}

.event-log:empty::before {
  content: 'Waiting for events...';
  color: #9ca3af;
  font-style: italic;
}

/* Stale heartbeats list */
.stale-list {
  font-size: 0.85em;
  opacity: 0.9;
}
</style>

<div class="live-dashboard">
  <!-- Vitals Bar -->
  <div class="vitals-bar">
    <div class="vitals-header">
      <div class="vitals-title">
        SYSTEM VITALS
      </div>
      <div class="vitals-status" id="vitalsStatus">
        <span class="status-indicator active"></span>
        <span>All Systems Go</span>
      </div>
    </div>
    <div class="vitals-content">
      <div class="vitals-section">
        <div class="vitals-label">Services</div>
        <div class="vitals-value">
          <div class="service-dots" id="serviceDots">
            <div class="service-dot">
              <span class="status-indicator inactive"></span>
              <span>Waiting...</span>
            </div>
          </div>
        </div>
      </div>
      <div class="vitals-section">
        <div class="vitals-label">Agents</div>
        <div class="vitals-value" id="agentsValue">
          <span>0 running</span>
        </div>
      </div>
      <div class="vitals-section">
        <div class="vitals-label">Tasks</div>
        <div class="vitals-value" id="tasksValue">
          <span>0 active</span>
        </div>
      </div>
      <div class="vitals-section">
        <div class="vitals-label">Health</div>
        <div class="vitals-value" id="healthValue">
          <span>Waiting for status...</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Observe Card -->
  <div class="observe-card">
    <div class="card-header">
      <div class="card-title">
        OBSERVATION STATUS
      </div>
      <div class="live-badge idle" id="observeModeBadge">
        <span id="observeModeLabel">Waiting...</span>
      </div>
    </div>
    <div class="observe-content">
      <div class="observe-section">
        <div class="observe-section-title">Screencast</div>
        <div class="observe-section-value" id="screencastStatus">Waiting...</div>
        <div class="observe-section-detail" id="screencastDetail"></div>
      </div>
      <div class="observe-section">
        <div class="observe-section-title">Tmux</div>
        <div class="observe-section-value" id="tmuxStatus">Waiting...</div>
        <div class="observe-section-detail" id="tmuxDetail"></div>
      </div>
      <div class="observe-section">
        <div class="observe-section-title">Audio</div>
        <div class="observe-section-value" id="audioStatus">Waiting...</div>
        <div class="observe-section-detail" id="audioDetail"></div>
      </div>
      <div class="observe-section">
        <div class="observe-section-title">Activity</div>
        <div class="observe-section-value" id="activityStatus">Waiting...</div>
        <div class="observe-section-detail" id="activityDetail"></div>
      </div>
      <div class="observe-section">
        <div class="observe-section-title">Describe</div>
        <div class="observe-section-value" id="describeStatus">Idle</div>
        <div class="observe-section-detail" id="describeDetail"></div>
      </div>
      <div class="observe-section">
        <div class="observe-section-title">Transcribe</div>
        <div class="observe-section-value" id="transcribeStatus">Idle</div>
        <div class="observe-section-detail" id="transcribeDetail"></div>
      </div>
    </div>
  </div>

  <!-- Remote Observers Card -->
  <div class="remotes-card hidden" id="remotesCard">
    <div class="card-header">
      <div class="card-title">
        REMOTE OBSERVERS
      </div>
    </div>
    <div class="remotes-grid" id="remotesGrid"></div>
  </div>

  <!-- Activity Grids -->
  <div class="activity-grids">
    <!-- Cortex Agents -->
    <div class="activity-section hidden" id="cortexSection">
      <div class="activity-section-header">
        AGENTS
      </div>
      <div class="activity-grid" id="cortexGrid"></div>
    </div>

    <!-- Importers -->
    <div class="activity-section hidden" id="importerSection">
      <div class="activity-section-header">
        IMPORTS
      </div>
      <div class="activity-grid" id="importerGrid"></div>
    </div>
  </div>

  <!-- Events Card -->
  <div class="events-card" id="eventsCard">
    <div class="events-header">
      <div class="events-title">EVENTS</div>
      <div class="events-controls">
        <span class="missed-count" id="missedCount" style="display: none;"></span>
        <button class="pause-btn" id="pauseBtn">
          <span>||</span>
          <span>Pause</span>
        </button>
      </div>
    </div>
    <div id="eventLog" class="event-log"></div>
  </div>
</div>

<script>
(function(){
  // State management
  const state = {
    services: new Map(),        // Running services
    crashed: new Map(),         // Crashed services (separate from running)
    tasks: [],
    health: null,
    agents: new Map(),
    agentCount: 0,              // Quick count from cortex.status
    imports: new Map(),
    remotes: new Map(),         // Remote observer status by host
    observe: {
      mode: null,               // Current observe mode
      screencast: null,
      tmux: null,
      audio: null,
      activity: null,
      describe: null,
      transcribe: null
    },
    eventsPaused: false,
    missedEvents: 0
  };

  // DOM elements
  const elements = {
    serviceDots: document.getElementById('serviceDots'),
    agentsValue: document.getElementById('agentsValue'),
    tasksValue: document.getElementById('tasksValue'),
    healthValue: document.getElementById('healthValue'),
    vitalsStatus: document.getElementById('vitalsStatus'),
    observeModeBadge: document.getElementById('observeModeBadge'),
    observeModeLabel: document.getElementById('observeModeLabel'),
    screencastStatus: document.getElementById('screencastStatus'),
    screencastDetail: document.getElementById('screencastDetail'),
    tmuxStatus: document.getElementById('tmuxStatus'),
    tmuxDetail: document.getElementById('tmuxDetail'),
    audioStatus: document.getElementById('audioStatus'),
    audioDetail: document.getElementById('audioDetail'),
    activityStatus: document.getElementById('activityStatus'),
    activityDetail: document.getElementById('activityDetail'),
    describeStatus: document.getElementById('describeStatus'),
    describeDetail: document.getElementById('describeDetail'),
    transcribeStatus: document.getElementById('transcribeStatus'),
    transcribeDetail: document.getElementById('transcribeDetail'),
    remotesCard: document.getElementById('remotesCard'),
    remotesGrid: document.getElementById('remotesGrid'),
    cortexSection: document.getElementById('cortexSection'),
    cortexGrid: document.getElementById('cortexGrid'),
    importerSection: document.getElementById('importerSection'),
    importerGrid: document.getElementById('importerGrid'),
    eventLog: document.getElementById('eventLog'),
    eventsCard: document.getElementById('eventsCard'),
    pauseBtn: document.getElementById('pauseBtn'),
    missedCount: document.getElementById('missedCount')
  };

  // Utility functions
  function formatElapsed(seconds) {
    if (seconds < 60) return `${seconds}s`;
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${minutes}m ${secs}s`;
  }

  function formatDuration(ms) {
    return formatElapsed(Math.floor(ms / 1000));
  }

  function truncate(str, len) {
    if (!str) return '';
    return str.length > len ? str.substring(0, len) + '...' : str;
  }

  function getAgentId(id) {
    return String(id).slice(-4);
  }

  // Client-side elapsed time updater
  let elapsedTimer = null;
  function startElapsedTimer() {
    if (elapsedTimer) return;
    elapsedTimer = setInterval(() => {
      // Update agent elapsed times based on start timestamp
      let needsUpdate = false;
      const now = Date.now();
      state.agents.forEach((agent, id) => {
        if (agent.startTs && agent.event !== 'finish' && agent.event !== 'error') {
          agent.elapsed_seconds = Math.floor((now - agent.startTs) / 1000);
          needsUpdate = true;
        }
      });
      if (needsUpdate) {
        updateCortexGrid();
      }
    }, 1000);
  }

  // Update vitals bar
  function updateVitals() {
    // Combine running and crashed services
    const allServices = [];

    // Running services first
    state.services.forEach((info, name) => {
      allServices.push({ name, info, crashed: false });
    });

    // Then crashed services
    state.crashed.forEach((info, name) => {
      allServices.push({ name, info, crashed: true });
    });

    if (allServices.length > 0) {
      const servicesHtml = allServices.map(({ name, info, crashed }) => {
        const statusClass = crashed ? 'crashed' : 'active';
        const dotClass = crashed ? 'service-dot crashed' : 'service-dot';
        const restartInfo = crashed && info.restart_attempts ? ` (${info.restart_attempts}x)` : '';
        return `
          <div class="${dotClass}">
            <span class="status-indicator ${statusClass}"></span>
            <span>${name}${restartInfo}</span>
          </div>
        `;
      }).join('');
      elements.serviceDots.innerHTML = servicesHtml;
    }

    // Agents count
    elements.agentsValue.innerHTML = `<span>${state.agentCount} running</span>`;

    // Tasks
    const taskCount = state.tasks.length;
    elements.tasksValue.innerHTML = `<span>${taskCount} active</span>`;

    // Health with stale heartbeat names
    if (state.health) {
      const staleHeartbeats = state.health.stale_heartbeats || [];
      const staleCount = staleHeartbeats.length;
      const hasCrashed = state.crashed.size > 0;

      if (staleCount > 0) {
        const staleNames = staleHeartbeats.join(', ');
        elements.healthValue.innerHTML = `
          <span style="color: #f59e0b;">! ${staleCount} stale</span>
          <span class="stale-list">(${staleNames})</span>
        `;
        updateVitalsStatus('warning');
      } else if (hasCrashed) {
        elements.healthValue.innerHTML = `<span style="color: #f87171;">! Services crashed</span>`;
        updateVitalsStatus('error');
      } else {
        elements.healthValue.innerHTML = `<span>OK</span>`;
        updateVitalsStatus('ok');
      }
    }
  }

  function updateVitalsStatus(status) {
    const vitalsStatus = elements.vitalsStatus;
    if (status === 'ok') {
      vitalsStatus.innerHTML = `
        <span class="status-indicator active"></span>
        <span>All Systems Go</span>
      `;
    } else if (status === 'warning') {
      vitalsStatus.innerHTML = `
        <span class="status-indicator restarting"></span>
        <span>Warnings</span>
      `;
    } else if (status === 'error') {
      vitalsStatus.innerHTML = `
        <span class="status-indicator crashed"></span>
        <span>Issues Detected</span>
      `;
    }
  }

  // Update observe mode badge
  function updateObserveMode() {
    const mode = state.observe.mode;
    const badge = elements.observeModeBadge;
    const label = elements.observeModeLabel;

    if (mode === 'screencast') {
      badge.className = 'live-badge';
      label.textContent = 'Recording';
    } else if (mode === 'tmux') {
      badge.className = 'live-badge tmux';
      label.textContent = 'Tmux';
    } else if (mode === 'idle') {
      badge.className = 'live-badge idle';
      label.textContent = 'Idle';
    } else {
      badge.className = 'live-badge idle';
      label.textContent = 'Waiting...';
    }
  }

  // Update observe card
  function updateObserve() {
    const obs = state.observe;

    // Update mode badge
    updateObserveMode();

    // Screencast
    if (obs.screencast) {
      const recording = obs.screencast.recording;
      if (recording) {
        const streams = obs.screencast.streams || [];
        const elapsed = obs.screencast.window_elapsed_seconds || 0;
        const streamCount = streams.length;
        const label = streamCount === 1 ? 'monitor' : 'monitors';
        elements.screencastStatus.textContent = `${elapsed}s (${streamCount} ${label})`;
        if (streamCount > 0) {
          elements.screencastDetail.textContent = streams
            .map(s => `${s.position || 'unknown'} ${s.connector || 'unknown'}`)
            .join(', ');
        } else {
          elements.screencastDetail.textContent = '';
        }
      } else {
        elements.screencastStatus.textContent = 'Idle';
        elements.screencastDetail.textContent = '';
      }
    }

    // Tmux
    if (obs.tmux) {
      if (obs.tmux.capturing) {
        const captures = obs.tmux.captures || 0;
        const sessions = obs.tmux.sessions || [];
        const elapsed = obs.tmux.window_elapsed_seconds || 0;
        elements.tmuxStatus.textContent = `${elapsed}s (${captures} captures)`;
        if (sessions.length > 0) {
          elements.tmuxDetail.textContent = sessions.join(', ');
        } else {
          elements.tmuxDetail.textContent = '';
        }
      } else {
        elements.tmuxStatus.textContent = 'Idle';
        elements.tmuxDetail.textContent = '';
      }
    }

    // Audio
    if (obs.audio) {
      const hits = obs.audio.threshold_hits || 0;
      const willSave = obs.audio.will_save ? ' (saving)' : '';
      elements.audioStatus.textContent = `${hits} hits${willSave}`;
      elements.audioDetail.textContent = '';
    }

    // Activity
    if (obs.activity) {
      const idleMs = obs.activity.idle_time_ms || 0;
      if (obs.activity.power_save) {
        elements.activityStatus.textContent = 'Power save';
      } else if (obs.activity.screen_locked) {
        elements.activityStatus.textContent = 'Locked';
      } else if (obs.activity.sink_muted) {
        elements.activityStatus.textContent = 'Muted';
      } else {
        elements.activityStatus.textContent = `Idle: ${Math.floor(idleMs/1000)}s`;
      }
      elements.activityDetail.textContent = '';
    }

    // Helper for describe/transcribe status (running is an object {file, ref}, not array)
    function updateProcessorStatus(processor, statusEl, detailEl) {
      if (!processor) return;

      const isRunning = !!processor.running;
      const queued = processor.queued?.length || 0;

      if (isRunning && queued > 0) {
        statusEl.textContent = `Running (+${queued} queued)`;
      } else if (isRunning) {
        statusEl.textContent = 'Running';
      } else if (queued > 0) {
        statusEl.textContent = `Queued: ${queued}`;
      } else {
        statusEl.textContent = 'Idle';
      }

      // Show current file being processed
      if (isRunning && processor.running.file) {
        const file = processor.running.file.split('/').pop();
        detailEl.textContent = truncate(file, 30);
      } else {
        detailEl.textContent = '';
      }
    }

    updateProcessorStatus(obs.describe, elements.describeStatus, elements.describeDetail);
    updateProcessorStatus(obs.transcribe, elements.transcribeStatus, elements.transcribeDetail);
  }

  // Update remote observers
  function updateRemotes() {
    if (state.remotes.size === 0) {
      elements.remotesCard.classList.add('hidden');
      return;
    }

    elements.remotesCard.classList.remove('hidden');
    const now = Date.now();

    const html = Array.from(state.remotes.values()).map(info => {
      // Consider stale if no update in 30 seconds
      const isStale = (now - info.lastSeen) > 30000;
      const cardClass = isStale ? 'remote-card stale' : 'remote-card active';

      return `
        <div class="${cardClass}">
          <div class="remote-card-name">${info.name}</div>
          <div class="remote-card-host">${info.platform}</div>
          <div class="remote-card-status">${info.mode}${isStale ? ' (stale)' : ''}</div>
        </div>
      `;
    }).join('');

    elements.remotesGrid.innerHTML = html;
  }

  // Update cortex grid
  function updateCortexGrid() {
    const activeAgents = Array.from(state.agents.values()).filter(a => a.event !== 'finish' && a.event !== 'error');

    if (activeAgents.length === 0) {
      elements.cortexSection.classList.add('hidden');
      return;
    }

    elements.cortexSection.classList.remove('hidden');

    const html = activeAgents.map(agent => {
      const stateIcon = agent.event === 'thinking' ? '~' :
                       (agent.event === 'tool_start' || agent.event === 'tool_end') ? '#' : 'o';
      const elapsed = agent.elapsed_seconds ? formatElapsed(agent.elapsed_seconds) : '0s';

      return `
        <div class="activity-card agent-active" data-agent-id="${agent.agent_id}">
          <div class="activity-card-id">...${getAgentId(agent.agent_id)}</div>
          <div class="activity-card-name">${agent.persona || 'default'}</div>
          <div class="activity-card-state">${stateIcon} ${agent.event || 'unknown'}</div>
          <div class="activity-card-elapsed">${elapsed}</div>
          <div class="activity-card-provider">${agent.provider || 'unknown'}</div>
        </div>
      `;
    }).join('');

    elements.cortexGrid.innerHTML = html;
  }

  // Update importer grid
  function updateImporterGrid() {
    const activeImports = Array.from(state.imports.values()).filter(i => i.event !== 'completed');

    if (activeImports.length === 0) {
      elements.importerSection.classList.add('hidden');
      return;
    }

    elements.importerSection.classList.remove('hidden');

    const html = activeImports.map(imp => {
      const isError = imp.event === 'error';
      const cardClass = isError ? 'import-error' : 'import-active';
      const progress = imp.stage === 'initialization' ? 25 :
                      imp.stage === 'transcribing' ? 50 :
                      imp.stage === 'segmenting' ? 75 : 90;
      const elapsed = imp.elapsed_ms ? formatDuration(imp.elapsed_ms) : '0s';

      let errorHtml = '';
      if (isError && imp.error) {
        errorHtml = `<div class="activity-card-error">${truncate(imp.error, 40)}</div>`;
      }

      return `
        <div class="activity-card ${cardClass}" data-import-id="${imp.import_id}">
          <div class="activity-card-id">...${getAgentId(imp.import_id)}</div>
          <div class="activity-card-name">${truncate(imp.input_file || 'import', 20)}</div>
          <div class="activity-card-state">${isError ? '! ' : ''}${imp.stage || 'processing'}</div>
          ${errorHtml}
          <div class="activity-card-progress">
            <div class="activity-card-progress-bar" style="width: ${progress}%"></div>
          </div>
          <div class="activity-card-elapsed">${elapsed}</div>
          <div class="activity-card-provider">${imp.file_type || 'unknown'}</div>
        </div>
      `;
    }).join('');

    elements.importerGrid.innerHTML = html;
  }

  // Pause/resume event stream
  function togglePause() {
    state.eventsPaused = !state.eventsPaused;

    if (state.eventsPaused) {
      // Paused
      elements.pauseBtn.classList.add('paused');
      elements.pauseBtn.innerHTML = '<span>|></span><span>Resume</span>';
      elements.eventsCard.classList.add('paused');
      state.missedEvents = 0;
      elements.missedCount.style.display = 'none';
    } else {
      // Resumed
      elements.pauseBtn.classList.remove('paused');
      elements.pauseBtn.innerHTML = '<span>||</span><span>Pause</span>';
      elements.eventsCard.classList.remove('paused');
      state.missedEvents = 0;
      elements.missedCount.style.display = 'none';
    }
  }

  // Append to event log
  function appendEvent(msg) {
    if (state.eventsPaused) {
      state.missedEvents++;
      elements.missedCount.textContent = `${state.missedEvents} missed`;
      elements.missedCount.style.display = 'inline';
      return;
    }

    const line = document.createElement('div');
    line.className = 'event-line';

    // Highlight error events
    if (msg.event === 'error' || (msg.event === 'exit' && msg.exit_code !== 0)) {
      line.className = 'event-line error';
    }

    line.textContent = JSON.stringify(msg);
    elements.eventLog.appendChild(line);

    // Auto-scroll to bottom
    elements.eventLog.scrollTop = elements.eventLog.scrollHeight;

    // Limit to last 100 events
    while (elements.eventLog.children.length > 100) {
      elements.eventLog.removeChild(elements.eventLog.firstChild);
    }
  }

  // Event handlers by tract
  function handleSupervisorEvent(msg) {
    if (msg.event === 'status') {
      // Update running services
      if (msg.services) {
        state.services.clear();
        msg.services.forEach(svc => {
          state.services.set(svc.name, svc);
        });
      }

      // Update crashed services (separate array)
      if (msg.crashed) {
        state.crashed.clear();
        msg.crashed.forEach(svc => {
          state.crashed.set(svc.name, svc);
        });
      } else {
        state.crashed.clear();
      }

      // Update tasks
      state.tasks = msg.tasks || [];

      // Update health
      state.health = {
        stale_heartbeats: msg.stale_heartbeats || []
      };

      updateVitals();
    }
  }

  function handleCortexEvent(msg) {
    // Handle status event first (no agent_id at top level)
    if (msg.event === 'status') {
      // Update agent count for vitals
      state.agentCount = msg.running_agents || 0;

      // Status event contains array of agents
      if (msg.agents) {
        // Clear agents not in status (they finished)
        const activeIds = new Set(msg.agents.map(a => a.agent_id));
        state.agents.forEach((_, id) => {
          if (!activeIds.has(id)) {
            state.agents.delete(id);
          }
        });

        // Update/add agents from status
        msg.agents.forEach(agent => {
          const existing = state.agents.get(agent.agent_id) || {};
          state.agents.set(agent.agent_id, {
            ...existing,
            agent_id: agent.agent_id,
            persona: agent.persona,
            provider: agent.provider,
            elapsed_seconds: agent.elapsed_seconds,
            event: existing.event || 'thinking'
          });
        });
      }

      updateVitals();
      updateCortexGrid();
      return;
    }

    // Individual agent events require agent_id
    const agentId = msg.agent_id;
    if (!agentId) return;

    // Track start time for client-side elapsed updates
    const existing = state.agents.get(agentId) || {};
    const startTs = msg.event === 'start' ? msg.ts : existing.startTs;

    state.agents.set(agentId, {
      ...existing,
      agent_id: agentId,
      persona: msg.persona || existing.persona,
      provider: msg.provider || existing.provider,
      event: msg.event,
      ts: msg.ts,
      startTs: startTs
    });

    // Start elapsed timer when first agent appears
    if (state.agents.size > 0) {
      startElapsedTimer();
    }

    // Remove finished/error agents after delay
    if (msg.event === 'finish' || msg.event === 'error') {
      setTimeout(() => {
        state.agents.delete(agentId);
        updateCortexGrid();
      }, 5000);
    }

    updateCortexGrid();
  }

  function handleObserveEvent(msg) {
    if (msg.event === 'status') {
      // Check if this is from a remote observer (has "remote" field added by relay)
      const remote = msg.remote;
      if (remote) {
        // Track remote observer
        state.remotes.set(remote, {
          name: remote,
          platform: msg.platform || 'unknown',
          mode: msg.mode || 'unknown',
          lastSeen: Date.now()
        });
        updateRemotes();
      }

      // Update local observe state (merge fields, don't overwrite all)
      if (msg.mode !== undefined) state.observe.mode = msg.mode;
      if (msg.screencast !== undefined) state.observe.screencast = msg.screencast;
      if (msg.tmux !== undefined) state.observe.tmux = msg.tmux;
      if (msg.audio !== undefined) state.observe.audio = msg.audio;
      if (msg.activity !== undefined) state.observe.activity = msg.activity;
      if (msg.describe !== undefined) state.observe.describe = msg.describe;
      if (msg.transcribe !== undefined) state.observe.transcribe = msg.transcribe;

      updateObserve();
    }
  }

  function handleImporterEvent(msg) {
    const importId = msg.import_id;
    if (!importId) return;

    if (msg.event === 'started') {
      state.imports.set(importId, {
        import_id: importId,
        input_file: msg.input_file,
        file_type: msg.file_type,
        stage: msg.stage,
        event: 'started',
        elapsed_ms: 0
      });
    } else if (msg.event === 'status') {
      const existing = state.imports.get(importId) || {};
      state.imports.set(importId, {
        ...existing,
        stage: msg.stage,
        elapsed_ms: msg.elapsed_ms,
        event: 'status'
      });
    } else if (msg.event === 'completed') {
      const existing = state.imports.get(importId) || {};
      state.imports.set(importId, {
        ...existing,
        event: msg.event
      });

      // Remove after delay
      setTimeout(() => {
        state.imports.delete(importId);
        updateImporterGrid();
      }, 5000);
    } else if (msg.event === 'error') {
      const existing = state.imports.get(importId) || {};
      state.imports.set(importId, {
        ...existing,
        event: 'error',
        error: msg.error || 'Unknown error'
      });

      // Keep error visible longer
      setTimeout(() => {
        state.imports.delete(importId);
        updateImporterGrid();
      }, 15000);
    }

    updateImporterGrid();
  }

  // Logs events are displayed in the event log via appendEvent
  // Error highlighting is handled there based on event type

  // Main event handler
  function handleEvent(msg) {
    appendEvent(msg);

    const tract = msg.tract;
    if (tract === 'supervisor') handleSupervisorEvent(msg);
    else if (tract === 'cortex') handleCortexEvent(msg);
    else if (tract === 'observe') handleObserveEvent(msg);
    else if (tract === 'importer') handleImporterEvent(msg);
    // logs tract events are displayed in event log via appendEvent
  }

  // Event listeners
  elements.pauseBtn.addEventListener('click', togglePause);

  // Listen to all Callosum events
  window.appEvents.listen('*', handleEvent);
})();
</script>
