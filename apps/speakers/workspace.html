{# Speaker voiceprint management - sentence-based view #}

<style>
/* Speakers app styles - all classes prefixed with .spk- */

.spk-wrap {
  max-width: 1200px;
  margin: 0 auto;
  padding: 16px 24px;
}

.spk-layout {
  display: grid;
  grid-template-columns: 280px 1fr;
  gap: 24px;
  min-height: 400px;
}

/* Segment list panel */
.spk-segments {
  background: #fff;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
  overflow: hidden;
}

.spk-segments-header {
  padding: 12px 16px;
  border-bottom: 1px solid #e5e7eb;
  font-weight: 600;
  font-size: 14px;
  color: #374151;
}

.spk-segments-list {
  max-height: 500px;
  overflow-y: auto;
}

.spk-segment {
  padding: 12px 16px;
  border-bottom: 1px solid #f3f4f6;
  cursor: pointer;
  transition: background 0.15s;
}

.spk-segment:hover {
  background: #f9fafb;
}

.spk-segment.active {
  background: #eff6ff;
  border-left: 3px solid #3b82f6;
}

.spk-segment-time {
  font-weight: 500;
  font-size: 14px;
  color: #1f2937;
}

.spk-segment-meta {
  font-size: 12px;
  color: #6b7280;
  margin-top: 4px;
}

.spk-segment-sources {
  display: flex;
  gap: 6px;
  margin-top: 6px;
  flex-wrap: wrap;
}

.spk-source-badge {
  display: inline-block;
  padding: 2px 8px;
  background: #e5e7eb;
  border-radius: 12px;
  font-size: 11px;
  color: #4b5563;
}

.spk-empty {
  padding: 24px;
  text-align: center;
  color: #9ca3af;
  font-size: 14px;
}

/* Detail panel */
.spk-detail {
  background: #fff;
  border-radius: 12px;
  border: 1px solid #e5e7eb;
  padding: 20px;
}

.spk-detail-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 16px;
}

.spk-detail-title {
  font-size: 18px;
  font-weight: 600;
  color: #1f2937;
}

/* Source tabs */
.spk-source-tabs {
  display: flex;
  gap: 8px;
  margin-bottom: 16px;
  border-bottom: 1px solid #e5e7eb;
  padding-bottom: 12px;
}

.spk-source-tab {
  padding: 6px 14px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 13px;
  cursor: pointer;
  background: #fff;
  color: #374151;
  transition: all 0.15s;
}

.spk-source-tab:hover {
  background: #f9fafb;
}

.spk-source-tab.active {
  background: #3b82f6;
  border-color: #3b82f6;
  color: #fff;
}

/* Audio player */
.spk-audio-player {
  margin-bottom: 20px;
  padding: 12px;
  background: #f9fafb;
  border-radius: 8px;
}

.spk-audio-player audio {
  width: 100%;
}

/* Sentence list */
.spk-sentences {
  margin-top: 16px;
}

.spk-sentences-title {
  font-size: 14px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 12px;
}

.spk-sentence {
  display: grid;
  grid-template-columns: 60px 1fr auto;
  gap: 12px;
  padding: 12px;
  border-bottom: 1px solid #f3f4f6;
  align-items: start;
}

.spk-sentence:hover {
  background: #fafafa;
}

.spk-sentence.spk-playing {
  background: #eff6ff;
  border-left: 3px solid #3b82f6;
  margin-left: -3px;
}

.spk-sentence-time {
  font-family: monospace;
  font-size: 12px;
  color: #6b7280;
  padding-top: 2px;
}

.spk-sentence-text {
  font-size: 14px;
  color: #1f2937;
  line-height: 1.5;
}

.spk-sentence-match {
  font-size: 12px;
  margin-top: 4px;
}

.spk-match-label {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 11px;
}

.spk-match-high {
  background: #dcfce7;
  color: #166534;
}

.spk-match-med {
  background: #fef9c3;
  color: #854d0e;
}

.spk-match-low {
  background: #f3f4f6;
  color: #6b7280;
}

.spk-no-match {
  color: #9ca3af;
  font-style: italic;
  font-size: 11px;
}

/* Sentence actions */
.spk-sentence-actions {
  display: flex;
  gap: 6px;
  align-items: center;
}

.spk-btn {
  padding: 4px 10px;
  border: none;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
  transition: background 0.15s;
}

.spk-btn-icon {
  padding: 4px 8px;
  background: #f3f4f6;
  color: #374151;
}

.spk-btn-icon:hover {
  background: #e5e7eb;
}

.spk-btn-primary {
  background: #3b82f6;
  color: #fff;
}

.spk-btn-primary:hover {
  background: #2563eb;
}

.spk-btn-primary:disabled {
  background: #93c5fd;
  cursor: not-allowed;
}

.spk-select-small {
  padding: 4px 8px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-size: 12px;
  background: #fff;
  min-width: 120px;
}

/* Create entity inline form */
.spk-inline-form {
  display: none;
  margin-top: 8px;
  padding: 12px;
  background: #f9fafb;
  border-radius: 6px;
  border: 1px solid #e5e7eb;
}

.spk-inline-form.visible {
  display: block;
}

.spk-form-row {
  margin-bottom: 8px;
}

.spk-form-row label {
  display: block;
  font-size: 11px;
  font-weight: 500;
  color: #6b7280;
  margin-bottom: 2px;
}

.spk-form-row input,
.spk-form-row select {
  width: 100%;
  padding: 6px 10px;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  font-size: 12px;
}

.spk-form-actions {
  display: flex;
  gap: 6px;
  margin-top: 8px;
}

/* Status messages */
.spk-status {
  padding: 6px 10px;
  border-radius: 4px;
  font-size: 12px;
  margin-top: 8px;
}

.spk-status-success {
  background: #dcfce7;
  color: #166534;
}

.spk-status-error {
  background: #fee2e2;
  color: #991b1b;
}

/* Facet indicator */
.spk-facet-badge {
  display: inline-block;
  padding: 4px 10px;
  background: var(--facet-bg, #e5e7eb);
  border: 1px solid var(--facet-color, #d1d5db);
  border-radius: 16px;
  font-size: 12px;
  color: var(--facet-color, #6b7280);
}
</style>

<div class="spk-wrap">
  <div class="spk-layout">
    <!-- Segment list -->
    <div class="spk-segments">
      <div class="spk-segments-header">
        Segments
      </div>
      <div class="spk-segments-list" id="spkSegmentList">
        <div class="spk-empty">Loading...</div>
      </div>
    </div>

    <!-- Detail panel -->
    <div class="spk-detail" id="spkDetail">
      <div class="spk-empty">
        Select a segment to view sentences
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const day = '{{ day }}';
  const segmentList = document.getElementById('spkSegmentList');
  const detailPanel = document.getElementById('spkDetail');

  let segments = [];
  let selectedSegment = null;
  let selectedSource = null;
  let audioPlayer = null;
  let currentSentences = [];  // Sentence data with offsets for time tracking
  let playingSentenceId = null;  // Currently playing/highlighted sentence

  // Load segments on page load
  loadSegments();

  // Listen for hash changes
  window.addEventListener('hashchange', () => {
    const hash = window.location.hash.slice(1);
    if (hash) selectSegmentByKey(hash);
  });

  // Listen for facet changes
  window.addEventListener('facet.switch', () => {
    if (selectedSegment && selectedSource) {
      loadSentences(selectedSegment, selectedSource);
    }
  });

  function loadSegments() {
    fetch(`/app/speakers/api/segments/${day}`)
      .then(r => r.json())
      .then(data => {
        segments = data.segments || [];
        renderSegmentList();

        // Auto-select from hash after loading
        if (window.location.hash) {
          selectSegmentByKey(window.location.hash.slice(1));
        }
      })
      .catch(() => {
        segmentList.innerHTML = '<div class="spk-empty">Failed to load segments</div>';
      });
  }

  function renderSegmentList() {
    if (segments.length === 0) {
      segmentList.innerHTML = '<div class="spk-empty">No segments with embeddings found for this day</div>';
      return;
    }

    segmentList.innerHTML = segments.map(seg => `
      <div class="spk-segment${selectedSegment?.key === seg.key ? ' active' : ''}" data-key="${seg.key}">
        <div class="spk-segment-time">${seg.start} - ${seg.end}</div>
        <div class="spk-segment-meta">${formatDuration(seg.duration)}</div>
        <div class="spk-segment-sources">
          ${seg.sources.map(s => `<span class="spk-source-badge">${formatSource(s)}</span>`).join('')}
        </div>
      </div>
    `).join('');

    // Add click handlers
    segmentList.querySelectorAll('.spk-segment').forEach(el => {
      el.addEventListener('click', () => {
        const seg = segments.find(s => s.key === el.dataset.key);
        if (seg) {
          window.location.hash = seg.key;
          selectSegment(seg);
        }
      });
    });
  }

  function selectSegmentByKey(key) {
    const seg = segments.find(s => s.key === key);
    if (seg) selectSegment(seg);
  }

  function selectSegment(seg) {
    selectedSegment = seg;
    selectedSource = seg.sources[0] || null;
    renderSegmentList();
    renderDetail(seg);
  }

  function renderDetail(seg) {
    if (!seg.sources.length) {
      detailPanel.innerHTML = '<div class="spk-empty">No audio sources found</div>';
      return;
    }

    let html = `
      <div class="spk-detail-header">
        <div class="spk-detail-title">${seg.start} - ${seg.end}</div>
        <span class="spk-facet-badge" id="spkFacetBadge"></span>
      </div>
    `;

    // Source tabs (if multiple sources)
    if (seg.sources.length > 1) {
      html += `
        <div class="spk-source-tabs">
          ${seg.sources.map(s => `
            <button class="spk-source-tab${s === selectedSource ? ' active' : ''}" data-source="${s}">
              ${formatSource(s)}
            </button>
          `).join('')}
        </div>
      `;
    }

    // Audio player placeholder
    html += '<div class="spk-audio-player" id="spkAudioContainer"></div>';

    // Sentences placeholder
    html += '<div class="spk-sentences" id="spkSentences"><div class="spk-empty">Loading...</div></div>';

    detailPanel.innerHTML = html;

    // Setup tab handlers
    detailPanel.querySelectorAll('.spk-source-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        selectedSource = tab.dataset.source;
        detailPanel.querySelectorAll('.spk-source-tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        loadSentences(seg, selectedSource);
      });
    });

    // Load sentences for first source
    loadSentences(seg, selectedSource);
  }

  function loadSentences(seg, source) {
    const container = document.getElementById('spkSentences');
    container.innerHTML = '<div class="spk-empty">Loading...</div>';

    fetch(`/app/speakers/api/sentences/${day}/${seg.key}/${source}`)
      .then(r => r.json())
      .then(data => {
        if (data.error) {
          container.innerHTML = `<div class="spk-empty">${escapeHtml(data.error)}</div>`;
          return;
        }
        renderSentences(data);
      })
      .catch(() => {
        container.innerHTML = '<div class="spk-empty">Failed to load sentences</div>';
      });
  }

  function renderSentences(data) {
    const { sentences, all_entities, audio_file, facet, source } = data;

    // Store sentences for time-based tracking
    currentSentences = sentences;
    playingSentenceId = null;

    // Update facet badge
    const badge = document.getElementById('spkFacetBadge');
    if (badge) badge.textContent = facet;

    // Setup audio player
    const audioContainer = document.getElementById('spkAudioContainer');
    if (audio_file) {
      audioContainer.innerHTML = `
        <audio id="spkAudio" controls preload="metadata">
          <source src="${audio_file}" type="audio/flac">
        </audio>
      `;
      audioPlayer = document.getElementById('spkAudio');
      setupAudioListeners();
    } else {
      audioContainer.innerHTML = '<div class="spk-empty">No audio file available</div>';
      audioPlayer = null;
    }

    // Render sentences
    const container = document.getElementById('spkSentences');

    if (sentences.length === 0) {
      container.innerHTML = '<div class="spk-empty">No sentences with embeddings found</div>';
      return;
    }

    container.innerHTML = `
      <div class="spk-sentences-title">Sentences (${sentences.length})</div>
      ${sentences.map(s => renderSentence(s, all_entities)).join('')}
    `;

    // Setup event handlers
    setupSentenceHandlers(facet, source);
  }

  function setupAudioListeners() {
    if (!audioPlayer) return;

    audioPlayer.addEventListener('timeupdate', () => {
      updateActiveSentence(audioPlayer.currentTime);
    });

    audioPlayer.addEventListener('play', () => {
      // Update button to pause icon for currently playing sentence
      if (playingSentenceId !== null) {
        const btn = detailPanel.querySelector(`.spk-sentence[data-id="${playingSentenceId}"] .spk-play-btn`);
        if (btn) btn.innerHTML = '&#9208;';  // Pause icon
      }
    });

    audioPlayer.addEventListener('pause', () => {
      // Update button back to play icon
      if (playingSentenceId !== null) {
        const btn = detailPanel.querySelector(`.spk-sentence[data-id="${playingSentenceId}"] .spk-play-btn`);
        if (btn) btn.innerHTML = '&#9654;';  // Play icon
      }
    });

    audioPlayer.addEventListener('ended', () => {
      // Clear playing state
      if (playingSentenceId !== null) {
        const row = detailPanel.querySelector(`.spk-sentence[data-id="${playingSentenceId}"]`);
        if (row) {
          row.classList.remove('spk-playing');
          row.querySelector('.spk-play-btn').innerHTML = '&#9654;';
        }
        playingSentenceId = null;
      }
    });
  }

  function updateActiveSentence(currentTime) {
    // Find the sentence that contains the current playback time
    let activeSentence = null;
    for (let i = 0; i < currentSentences.length; i++) {
      const s = currentSentences[i];
      const nextOffset = currentSentences[i + 1]?.offset ?? Infinity;
      if (currentTime >= s.offset && currentTime < nextOffset) {
        activeSentence = s;
        break;
      }
    }

    const newId = activeSentence?.id ?? null;
    if (newId === playingSentenceId) return;  // No change

    // Remove highlight from previous sentence
    if (playingSentenceId !== null) {
      const prevRow = detailPanel.querySelector(`.spk-sentence[data-id="${playingSentenceId}"]`);
      if (prevRow) {
        prevRow.classList.remove('spk-playing');
        prevRow.querySelector('.spk-play-btn').innerHTML = '&#9654;';
      }
    }

    // Add highlight to new sentence
    playingSentenceId = newId;
    if (playingSentenceId !== null) {
      const newRow = detailPanel.querySelector(`.spk-sentence[data-id="${playingSentenceId}"]`);
      if (newRow) {
        newRow.classList.add('spk-playing');
        if (!audioPlayer.paused) {
          newRow.querySelector('.spk-play-btn').innerHTML = '&#9208;';
        }
        // Scroll into view if needed
        newRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }
    }
  }

  function renderSentence(sentence, allEntities) {
    const timeStr = formatOffset(sentence.offset);
    const match = sentence.match;
    let matchHtml = '<span class="spk-no-match">No match</span>';

    if (match) {
      const scorePct = Math.round(match.score * 100);
      const scoreClass = match.score >= 0.7 ? 'high' : match.score >= 0.5 ? 'med' : 'low';
      matchHtml = `<span class="spk-match-label spk-match-${scoreClass}">${escapeHtml(match.entity)} ${scorePct}%</span>`;
    }

    return `
      <div class="spk-sentence" data-id="${sentence.id}" data-offset="${sentence.offset}">
        <div class="spk-sentence-time">${timeStr}</div>
        <div class="spk-sentence-content">
          <div class="spk-sentence-text">${escapeHtml(sentence.text)}</div>
          <div class="spk-sentence-match">${matchHtml}</div>
          <div class="spk-inline-form" id="form-${sentence.id}">
            <div class="spk-form-row">
              <label>Name</label>
              <input type="text" class="spk-new-name" placeholder="e.g., John Smith">
            </div>
            <div class="spk-form-row">
              <label>Type</label>
              <select class="spk-new-type">
                <option value="Person">Person</option>
                <option value="Contact">Contact</option>
              </select>
            </div>
            <div class="spk-form-actions">
              <button class="spk-btn spk-btn-icon spk-cancel-create">Cancel</button>
              <button class="spk-btn spk-btn-primary spk-confirm-create">Create</button>
            </div>
          </div>
          <div class="spk-status-container" id="status-${sentence.id}"></div>
        </div>
        <div class="spk-sentence-actions">
          <button class="spk-btn spk-btn-icon spk-play-btn" title="Play from here">&#9654;</button>
          <select class="spk-select-small spk-entity-select">
            <option value="">Save to...</option>
            ${allEntities.map(e => `<option value="${escapeHtml(e)}">${escapeHtml(e)}</option>`).join('')}
            <option value="__new__">+ New entity</option>
          </select>
          <button class="spk-btn spk-btn-primary spk-save-btn" disabled>Save</button>
        </div>
      </div>
    `;
  }

  function setupSentenceHandlers(facet, source) {
    // Play/Pause button
    detailPanel.querySelectorAll('.spk-play-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const row = btn.closest('.spk-sentence');
        const sentenceId = parseInt(row.dataset.id);
        const offset = parseFloat(row.dataset.offset);

        if (!audioPlayer) return;

        // If clicking the currently playing sentence, toggle play/pause
        if (sentenceId === playingSentenceId && !audioPlayer.paused) {
          audioPlayer.pause();
        } else {
          // Seek to this sentence and play
          audioPlayer.currentTime = offset;
          audioPlayer.play();
        }
      });
    });

    // Entity select
    detailPanel.querySelectorAll('.spk-entity-select').forEach(select => {
      select.addEventListener('change', () => {
        const row = select.closest('.spk-sentence');
        const saveBtn = row.querySelector('.spk-save-btn');
        const form = row.querySelector('.spk-inline-form');

        if (select.value === '__new__') {
          form.classList.add('visible');
          saveBtn.disabled = true;
        } else {
          form.classList.remove('visible');
          saveBtn.disabled = !select.value;
        }
      });
    });

    // Save button
    detailPanel.querySelectorAll('.spk-save-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const row = btn.closest('.spk-sentence');
        const sentenceId = parseInt(row.dataset.id);
        const entityName = row.querySelector('.spk-entity-select').value;

        if (!entityName || entityName === '__new__') return;

        saveVoiceprint(facet, entityName, source, sentenceId, row);
      });
    });

    // Create form handlers
    detailPanel.querySelectorAll('.spk-cancel-create').forEach(btn => {
      btn.addEventListener('click', () => {
        const row = btn.closest('.spk-sentence');
        const form = row.querySelector('.spk-inline-form');
        const select = row.querySelector('.spk-entity-select');
        form.classList.remove('visible');
        select.value = '';
      });
    });

    detailPanel.querySelectorAll('.spk-confirm-create').forEach(btn => {
      btn.addEventListener('click', () => {
        const row = btn.closest('.spk-sentence');
        const sentenceId = parseInt(row.dataset.id);
        const form = row.querySelector('.spk-inline-form');
        const name = form.querySelector('.spk-new-name').value.trim();
        const type = form.querySelector('.spk-new-type').value;

        if (!name) {
          showStatus(row, 'Please enter a name', 'error');
          return;
        }

        createEntityWithVoiceprint(facet, type, name, source, sentenceId, row);
      });
    });
  }

  function saveVoiceprint(facet, entityName, source, sentenceId, row) {
    fetch('/app/speakers/api/save-voiceprint', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        facet,
        entity_name: entityName,
        day,
        segment_key: selectedSegment.key,
        source,
        sentence_id: sentenceId,
      }),
    })
      .then(r => r.json())
      .then(data => {
        if (data.error) {
          showStatus(row, data.error, 'error');
        } else {
          showStatus(row, `Saved to ${entityName}`, 'success');
          // Reload to refresh matches
          setTimeout(() => loadSentences(selectedSegment, selectedSource), 1500);
        }
      })
      .catch(() => {
        showStatus(row, 'Failed to save', 'error');
      });
  }

  function createEntityWithVoiceprint(facet, type, name, source, sentenceId, row) {
    fetch('/app/speakers/api/create-entity-voiceprint', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        facet,
        type,
        name,
        description: '',
        day,
        segment_key: selectedSegment.key,
        source,
        sentence_id: sentenceId,
      }),
    })
      .then(r => r.json())
      .then(data => {
        if (data.error) {
          showStatus(row, data.error, 'error');
        } else {
          showStatus(row, `Created ${name}`, 'success');
          const form = row.querySelector('.spk-inline-form');
          form.classList.remove('visible');
          // Reload to refresh matches and entity list
          setTimeout(() => loadSentences(selectedSegment, selectedSource), 1500);
        }
      })
      .catch(() => {
        showStatus(row, 'Failed to create', 'error');
      });
  }

  function showStatus(row, message, type) {
    const container = row.querySelector('.spk-status-container');
    container.innerHTML = `<div class="spk-status spk-status-${type}">${escapeHtml(message)}</div>`;
    setTimeout(() => { container.innerHTML = ''; }, 3000);
  }

  function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    if (mins === 0) return `${secs}s`;
    return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
  }

  function formatOffset(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  function formatSource(source) {
    // mic_audio -> Mic, sys_audio -> System
    if (source === 'mic_audio') return 'Mic';
    if (source === 'sys_audio') return 'System';
    return source.replace('_audio', '');
  }

  function escapeHtml(str) {
    if (!str) return '';
    return String(str)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;');
  }
})();
</script>
