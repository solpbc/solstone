{# Chat app background service - manages badge, submenu, and real-time notifications #}

AppServices.register('chat', {
  unreadCount: {{ unread_count|default(0) }},
  activeChatId: null,
  facetCounts: {},

  // Recent chats cache - sorted: unread first, then by timestamp
  recentChats: [
    {% if recent_chats %}
    {% for chat in recent_chats %}
    {
      chat_id: '{{ chat.chat_id }}',
      title: {{ chat.title|default('(untitled)')|tojson }},
      ts: {{ chat.ts|default(0) }},
      unread: {{ 'true' if chat.unread else 'false' }},
      facet: {{ chat.facet|default(none)|tojson }}
    }{{ ',' if not loop.last else '' }}
    {% endfor %}
    {% endif %}
  ],

  initialize() {
    // Set badge from unread count
    if (this.unreadCount > 0) {
      AppServices.badges.app.set('chat', this.unreadCount);
    }

    // Build initial facet counts from unread chats
    for (const chat of this.recentChats) {
      if (chat.unread && chat.facet) {
        this.facetCounts[chat.facet] = (this.facetCounts[chat.facet] || 0) + 1;
      }
    }

    // Build initial submenu
    this.rebuildSubmenu();

    // Update facet badges if chat app is active
    this.updateFacetBadges();

    // Listen for cortex events
    appEvents.listen('cortex', (e) => this.handleCortexEvent(e));
  },

  // Rebuild submenu from recentChats cache
  // Shows fixed nav items at top, then top 5 recent chats
  rebuildSubmenu() {
    const sorted = [...this.recentChats]
      .sort((a, b) => {
        if (a.unread !== b.unread) return a.unread ? -1 : 1;
        return b.ts - a.ts;
      })
      .slice(0, 5);

    const items = [
      // Fixed navigation items
      { id: 'new', label: 'New Chat', href: '/app/chat#', order: -1 },
      // Recent chats
      ...sorted.map((chat, i) => ({
        id: chat.chat_id,
        label: chat.title || '(untitled)',
        href: `/app/chat#${chat.chat_id}`,
        badge: chat.unread ? 'â—' : null,
        order: i,
        facet: chat.facet
      }))
    ];

    AppServices.submenus.set('chat', items);
  },

  // Called by workspace to track which chat is being viewed
  setActiveAgent(chatId) {
    this.activeChatId = chatId;
  },

  // Handle cortex finish/error events
  async handleCortexEvent(e) {
    if (e.event !== 'finish' && e.event !== 'error') return;

    // Find chat by agent_id (handles both new chats and continuations)
    try {
      const resp = await fetch(`/app/chat/api/agent/${e.agent_id}/chat`);
      if (!resp.ok) return; // Not a chat agent

      const chat = await resp.json();
      const chatId = chat.chat_id;

      // Skip if user is actively viewing this chat
      if (this.activeChatId === chatId) return;

      // Skip if already processed (chat already has unread flag from send_message)
      if (chat.unread) return;

      // Mark as unread for new completion
      chat.unread = true;

      // Update state
      this.unreadCount++;
      if (chat.facet) {
        this.facetCounts[chat.facet] = (this.facetCounts[chat.facet] || 0) + 1;
      }

      // Add to cache (or update if exists)
      const existingIndex = this.recentChats.findIndex(c => c.chat_id === chatId);
      const chatData = {
        chat_id: chatId,
        title: chat.title || '(untitled)',
        ts: chat.ts || Date.now(),
        unread: true,
        facet: chat.facet
      };

      if (existingIndex >= 0) {
        this.recentChats[existingIndex] = chatData;
      } else {
        this.recentChats.unshift(chatData);
        // Keep cache bounded
        if (this.recentChats.length > 20) {
          this.recentChats = this.recentChats.slice(0, 20);
        }
      }

      // Update app badge
      AppServices.badges.app.set('chat', this.unreadCount);

      // Rebuild submenu
      this.rebuildSubmenu();

      // Update facet badges if chat app is active
      this.updateFacetBadges();

      // Show notification
      const isError = e.event === 'error';
      AppServices.notifications.show({
        app: 'chat',
        icon: isError ? 'âŒ' : 'ðŸ’¬',
        title: isError ? 'Chat Error' : 'Chat Complete',
        message: chatData.title,
        action: `/app/chat#${chatId}`,
        facet: chat.facet,
        autoDismiss: 5000
      });

    } catch (err) {
      console.error('Failed to handle chat event:', err);
    }
  },

  // Update facet badges (only when chat app is active)
  updateFacetBadges() {
    if (!window.location.pathname.startsWith('/app/chat')) return;

    for (const [facet, count] of Object.entries(this.facetCounts)) {
      if (count > 0) {
        AppServices.badges.facet.set(facet, count);
      } else {
        AppServices.badges.facet.clear(facet);
      }
    }
  },

  // Called from workspace when user views a chat
  markRead(chatId, facet) {
    // Update unread count
    this.unreadCount = Math.max(0, this.unreadCount - 1);

    // Update facet count
    if (facet && this.facetCounts[facet]) {
      this.facetCounts[facet] = Math.max(0, this.facetCounts[facet] - 1);
    }

    // Update chat in cache (mark as read, don't remove)
    const chat = this.recentChats.find(c => c.chat_id === chatId);
    if (chat) {
      chat.unread = false;
    }

    // Update app badge
    if (this.unreadCount > 0) {
      AppServices.badges.app.set('chat', this.unreadCount);
    } else {
      AppServices.badges.app.clear('chat');
    }

    // Rebuild submenu (chat moves down, loses badge)
    this.rebuildSubmenu();

    // Update facet badges
    this.updateFacetBadges();
  }
});
