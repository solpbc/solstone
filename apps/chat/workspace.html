<style>
#messages {
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  padding: 1em;
}
.message {margin-bottom:0.75em; padding:0.75em 1em; border-radius:12px; max-width:75%; box-shadow:0 1px 3px rgba(0,0,0,0.1); animation:fadeInUp 0.3s ease-out; position:relative;}
.from-user {background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; align-self:flex-end; margin-left:20%;}
.from-bot {background:#fff; border:1px solid #e0e0e0; align-self:flex-start; margin-right:20%;}
.copy-markdown-btn {position:absolute; top:0.5em; right:0.5em; background:rgba(0,0,0,0.05); border:1px solid rgba(0,0,0,0.1); border-radius:4px; padding:0.25em 0.5em; cursor:pointer; opacity:0; transition:opacity 0.2s; font-size:0.9em; color:#666;}
.copy-markdown-btn:hover {background:rgba(0,0,0,0.1); color:#333;}
.from-bot:hover .copy-markdown-btn {opacity:1;}
.copy-markdown-btn.copied {background:#4caf50; color:white; border-color:#4caf50;}
.copy-markdown-btn-bottom {position:relative; display:block; margin-bottom:0.75em; margin-top:-0.5em; margin-left:0; padding-left:0; text-align:left; align-self:flex-start; max-width:75%; margin-right:20%;}
.copy-markdown-btn-bottom button {background:transparent; border:1px solid rgba(0,0,0,0.15); border-radius:6px; padding:0.4em 0.5em; cursor:pointer; font-size:1em; color:#666; transition:all 0.2s; line-height:1;}
.copy-markdown-btn-bottom button:hover {background:rgba(0,0,0,0.05); border-color:rgba(0,0,0,0.25);}
.copy-markdown-btn-bottom button.copied {background:#4caf50; color:white; border-color:#4caf50;}
.copy-user-btn-bottom {position:relative; display:flex; gap:0.3em; justify-content:flex-end; margin-bottom:0.75em; margin-top:-0.5em; margin-right:0; padding-right:0; text-align:right; align-self:flex-end; max-width:75%; margin-left:20%;}
.copy-user-btn-bottom button {background:transparent; border:1px solid rgba(255,255,255,0.3); border-radius:6px; padding:0.4em 0.5em; cursor:pointer; font-size:1em; color:rgba(255,255,255,0.7); transition:all 0.2s; line-height:1; display:inline-flex; align-items:center; justify-content:center;}
.copy-user-btn-bottom button:hover {background:rgba(255,255,255,0.1); border-color:rgba(255,255,255,0.5); color:rgba(255,255,255,0.9);}
.copy-user-btn-bottom button.copied {background:#4caf50; color:white; border-color:#4caf50;}
@keyframes fadeInUp {from{opacity:0;transform:translateY(10px);}to{opacity:1;transform:translateY(0);}}
#messages .event-card{background:#fff4e5;border:1px solid #f0ad4e;border-radius:6px;padding:0.5em 0.75em;margin-bottom:0.75em;font-size:0.85em;max-width:80%;align-self:flex-start;cursor:help;transition:all 0.2s;}
#messages .event-card:hover{background:#fff0d4;border-color:#e09e3a;transform:translateY(-1px);box-shadow:0 2px 4px rgba(0,0,0,0.1);}
#messages .event-card a{text-decoration:none;color:#007bff;}
#messages .event-card a:hover{text-decoration:underline;}
#messages .tool-placard{background:#e3f2fd;border:1px solid #2196f3;border-radius:6px;padding:0.4em 0.6em;margin-bottom:0.5em;font-size:0.8em;max-width:60%;align-self:flex-start;cursor:help;transition:all 0.2s;}
#messages .tool-placard:hover{background:#d1e8fc;border-color:#1976d2;transform:translateY(-1px);}
#messages .tool-placard .tool-name{font-weight:bold;color:#1976d2;}
#messages .tool-placard .tool-status{font-size:0.9em;color:#666;margin-left:0.5em;}
#messages .tool-placard.completed{background:#e8f5e9;border-color:#4caf50;}
#messages .tool-placard.completed:hover{background:#d4f0d7;}
#messages .tool-placard.completed .tool-name{color:#2e7d32;}
#messages .agent-update{background:#fff3e0;border:1px solid #ff9800;border-radius:6px;padding:0.4em 0.6em;margin-bottom:0.5em;font-size:0.8em;max-width:60%;align-self:flex-start;color:#e65100;font-style:italic;transition:all 0.2s;}
#messages .agent-update:hover{background:#ffe8cc;}
#messages .thinking-card{background:#f8f4ff;border:1px solid #9c27b0;border-radius:6px;padding:0.5em 0.75em;margin-bottom:0.75em;font-size:0.85em;max-width:80%;align-self:flex-start;cursor:pointer;transition:all 0.2s;}
#messages .thinking-card:hover{background:#f3e5f5;transform:translateY(-1px);box-shadow:0 2px 4px rgba(0,0,0,0.05);}
#messages .thinking-card .thinking-label{font-weight:bold;color:#7b1fa2;margin-bottom:0.25em;}
#messages .thinking-card .thinking-content{color:#333;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
#messages .thinking-card.expanded .thinking-content{white-space:pre-wrap;overflow:visible;text-overflow:clip;}
.message h1,.message h2,.message h3,.message h4,.message h5,.message h6 {margin:0.5em 0 0.3em 0;}
.message p {margin:0.3em 0;}
.message ul,.message ol {margin:0.3em 0; padding-left:1.5em;}
.message code {background:rgba(0,0,0,0.1); padding:0.1em 0.3em; border-radius:3px; font-size:0.9em;}
.from-user code {background:rgba(255,255,255,0.2);}
.message pre {background:rgba(0,0,0,0.1); padding:0.5em; border-radius:4px; overflow-x:auto; margin:0.5em 0;}
.from-user pre {background:rgba(255,255,255,0.15);}
.message pre code {background:none; padding:0;}
.message blockquote {margin:0.5em 0; padding-left:1em; border-left:3px solid rgba(0,0,0,0.2);}
.from-user blockquote {border-left-color:rgba(255,255,255,0.4);}
@keyframes typingBounce {0%,80%,100%{transform:scale(0.8);opacity:0.5;}40%{transform:scale(1);opacity:1;}}
.activity-indicator {align-self:flex-start; padding:0.75em 1em; background:#f0f0f0; border-radius:12px; margin-bottom:0.5em; max-width:80px; display:none;}
.activity-indicator.active {display:flex; align-items:center; gap:4px; animation:fadeInUp 0.3s ease-out;}
.activity-indicator span {width:8px; height:8px; background:#999; border-radius:50%; animation:typingBounce 1.4s infinite ease-in-out;}
.activity-indicator span:nth-child(1) {animation-delay:-0.32s;}
.activity-indicator span:nth-child(2) {animation-delay:-0.16s;}
</style>

<div id="messages"></div>

<script src="{{ vendor_lib('marked') }}"></script>
<script>
const sendUrl = '{{ url_for('app:chat.send_message') }}';
const historyUrl = '{{ url_for('app:chat.chat_history') }}';
const clearUrl = '{{ url_for('app:chat.clear_history') }}';
const agentUrl = '{{ url_for('app:chat.agent_events', agent_id='AGENT_ID') }}';
const messagesDiv = document.getElementById('messages');
const searchBase = '{{ url_for('app:search.index') }}';

// Wait for app bar to load
let form, input, backendToggle, currentBackend;

function initAppBarControls() {
  form = document.getElementById('chatInputForm');
  input = document.getElementById('chatMessageInput');
  backendToggle = document.getElementById('chatBackendToggle');
  currentBackend = backendToggle.dataset.backend || 'anthropic';

  // Backend toggle cycle: anthropic -> google -> openai -> anthropic
  const backends = {
    anthropic: { next: 'google', label: 'Claude' },
    google: { next: 'openai', label: 'Gemini' },
    openai: { next: 'anthropic', label: 'ChatGPT' }
  };

  backendToggle.addEventListener('click', () => {
    const next = backends[currentBackend].next;
    currentBackend = next;
    backendToggle.dataset.backend = next;
    backendToggle.textContent = backends[next].label;
    backendToggle.title = `Click to change backend (current: ${backends[next].label})`;
  });

  // Setup form submission
  setupFormHandlers();

  input.focus();
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initAppBarControls);
} else {
  initAppBarControls();
}

// Deduplication using agent_id:ts as key
const processedEventIds = new Set();

function shouldSkipEvent(event) {
  if (!event || !event.agent_id || !event.ts) {
    return false;
  }
  const eventKey = `${event.agent_id}:${event.ts}`;
  if (processedEventIds.has(eventKey)) {
    return true;
  }
  processedEventIds.add(eventKey);
  return false;
}

function resetEventTracking() {
  processedEventIds.clear();
}

// Single source of truth for event rendering
function enrichEvent(event) {
  const enriched = {...event};

  // Render finish events
  if (event.event === 'finish') {
    const resultText = event.result || '';
    enriched.html = marked.parse(resultText, {
      breaks: true,  // nl2br equivalent
      gfm: true      // GitHub Flavored Markdown
    });
    enriched.rawMarkdown = resultText;
  }

  // Render error events
  else if (event.event === 'error') {
    const errorMsg = event.error || 'Unknown error';
    const trace = event.trace || '';
    const errorText = trace
      ? `‚ùå **Error**: ${errorMsg}\n\n\`\`\`\n${trace}\n\`\`\``
      : `‚ùå **Error**: ${errorMsg}`;
    enriched.html = marked.parse(errorText, {breaks: true, gfm: true});
    enriched.rawMarkdown = errorText;
    enriched.result = errorText;
  }

  return enriched;
}

// Parse URL parameters
const urlParams = new URLSearchParams(window.location.search);

// Unified state management
let currentAgentId = null;
let isComplete = false;
let headerInfo = null; // {startTs, prompt}

// Create persistent activity indicator
const activityIndicator = document.createElement('div');
activityIndicator.className = 'activity-indicator';
activityIndicator.id = 'activityIndicator';
activityIndicator.innerHTML = '<span></span><span></span><span></span>';

// Activity indicator state
let eventProcessingActive = false;
let eventTimeout = null;
let chatControlsInitialized = false;

function showActivityIndicator() {
  if (!document.getElementById('activityIndicator')) {
    messagesDiv.appendChild(activityIndicator);
  }
  activityIndicator.classList.add('active');
  eventProcessingActive = true;

  // Auto-scroll to keep activity indicator in view
  requestAnimationFrame(() => {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  });

  // Clear any existing timeout
  if (eventTimeout) {
    clearTimeout(eventTimeout);
    eventTimeout = null;
  }
}

function forceHideActivityIndicator() {
  // Force hide without delay
  if (eventTimeout) {
    clearTimeout(eventTimeout);
    eventTimeout = null;
  }
  activityIndicator.classList.remove('active');
  eventProcessingActive = false;
}

function ensureActivityIndicatorAtBottom() {
  // Ensure activity indicator is always the last element
  if (!activityIndicator.parentNode) {
    messagesDiv.appendChild(activityIndicator);
  } else if (activityIndicator.parentNode === messagesDiv && messagesDiv.lastElementChild !== activityIndicator) {
    messagesDiv.appendChild(activityIndicator);
  }
}

function addEventCard(text, url, event){
  const div=document.createElement('div');
  div.className='event-card';
  const a=document.createElement('a');
  a.href=url;
  a.textContent=text;
  div.appendChild(a);  // This line was missing!

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Track tool calls by ID to update them when complete
// Limit to prevent memory leaks
const toolPlacards = {};
const MAX_TOOL_PLACARDS = 100;

// Track agent switches - only show when switching between agents
let previousAgent = null;

// Clean up old tool placards when limit reached
function cleanupOldPlacards() {
  const keys = Object.keys(toolPlacards);
  if (keys.length > MAX_TOOL_PLACARDS) {
    // Remove oldest entries (first half)
    const toRemove = keys.slice(0, Math.floor(keys.length / 2));
    toRemove.forEach(key => delete toolPlacards[key]);
  }
}

function addToolPlacard(toolName, event, callId){
  const div=document.createElement('div');
  div.className='tool-placard';

  const nameSpan=document.createElement('span');
  nameSpan.className='tool-name';
  nameSpan.textContent='üîß ' + toolName;
  div.appendChild(nameSpan);

  const statusSpan=document.createElement('span');
  statusSpan.className='tool-status';
  statusSpan.textContent='(running...)';
  div.appendChild(statusSpan);

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;

  // Store reference to update later
  if(callId){
    toolPlacards[callId] = {div, statusSpan};
    cleanupOldPlacards();  // Clean up if too many
  }
  return div;
}

function completeToolPlacard(callId, result){
  if(toolPlacards[callId]){
    const {div, statusSpan} = toolPlacards[callId];
    div.classList.add('completed');
    statusSpan.textContent = '‚úì';

    // Update title attribute with result
    if(result && div.title){
      const resultText = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
      div.title += '\n\n=== Result ===\n' + resultText;
    }

    delete toolPlacards[callId];
  }
}

function addAgentUpdate(agentName){
  // Only show agent switch if we're actually switching from one agent to another
  if(previousAgent && previousAgent !== agentName){
    const div=document.createElement('div');
    div.className='agent-update';
    div.textContent=`‚Üí Switched from ${previousAgent} to ${agentName} agent`;
    messagesDiv.insertBefore(div, activityIndicator);
    ensureActivityIndicatorAtBottom();
    messagesDiv.scrollTop=messagesDiv.scrollHeight;
  }
  previousAgent = agentName;
}

function addThinkingCard(summary, model){
  const div=document.createElement('div');
  div.className='thinking-card';

  const label=document.createElement('div');
  label.className='thinking-label';
  label.textContent=`üí≠ Thinking (${model})`;
  div.appendChild(label);

  const content=document.createElement('div');
  content.className='thinking-content';
  content.textContent=summary;
  div.appendChild(content);

  div.addEventListener('click', () => {
    div.classList.toggle('expanded');
  });

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Header management
function updateHeader() {
  if (!headerInfo) return;

  let header = document.getElementById('chatHeader');
  if (!header) {
    header = document.createElement('div');
    header.id = 'chatHeader';
    header.style.cssText = 'background:#e3f2fd;border-bottom:2px solid #2196f3;padding:0.75rem 1rem;margin:0;color:#1565c0;text-align:center;font-size:0.95em;';
    messagesDiv.parentElement.insertBefore(header, messagesDiv);
  }

  const startDate = new Date(headerInfo.startTs);
  const timeStr = startDate.toLocaleTimeString('en-US', {hour: 'numeric', minute: '2-digit'});
  const dateStr = startDate.toLocaleDateString('en-US', {month: 'short', day: 'numeric'});

  let headerText = `Chat ‚Ä¢ Started ${timeStr} on ${dateStr}`;

  // Add duration if complete
  if (isComplete && headerInfo.endTs) {
    const durationMs = headerInfo.endTs - headerInfo.startTs;
    const seconds = Math.floor(durationMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;

    if (minutes > 0) {
      headerText += ` ‚Ä¢ Completed in ${minutes}m ${remainingSeconds}s`;
    } else {
      headerText += ` ‚Ä¢ Completed in ${seconds}s`;
    }
  }

  header.textContent = headerText;
}

// Unified agent loading function
async function loadAgent(agentId) {
  currentAgentId = agentId;
  isComplete = false;
  headerInfo = null;
  resetEventTracking();

  // Clear messages but keep activity indicator
  messagesDiv.innerHTML = '';
  messagesDiv.appendChild(activityIndicator);
  Object.keys(toolPlacards).forEach(key => delete toolPlacards[key]);
  previousAgent = null;

  // Fetch existing events from disk
  const url = agentUrl.replace('AGENT_ID', agentId);
  try {
    const response = await fetch(url);
    if (!response.ok) {
      showError(`Failed to load agent: ${response.statusText}`);
      return;
    }

    const data = await response.json();
    const events = data.events || [];
    isComplete = data.is_complete || false;

    // Process historical events
    for (const event of events) {
      const enriched = enrichEvent(event);
      if (!shouldSkipEvent(enriched)) {
        processEvent(enriched);
      }
    }

    // Show activity indicator if not complete
    if (!isComplete) {
      showActivityIndicator();
    } else {
      forceHideActivityIndicator();

      // Check if we can continue the conversation
      const finishEvent = events.find(e => e.event === 'finish');
      if (finishEvent && finishEvent.conversation_id && input) {
        input.disabled = false;
        input.placeholder = 'Continue conversation...';
        input.dataset.continueAgent = agentId;
      }
    }

  } catch (error) {
    showError(`Failed to load agent: ${error.message}`);
  }
}

// Store raw markdown for each bot message
const messageMarkdown = new WeakMap();

function addMessage(text, cls, isHtml=false, rawMarkdown=null){
  const div=document.createElement('div');
  div.className='message '+cls;

  // Use HTML for bot messages if provided, otherwise plain text
  if(isHtml && cls === 'from-bot'){
    div.innerHTML = text;

    // Store raw markdown if provided
    if(rawMarkdown) {
      messageMarkdown.set(div, rawMarkdown);
    }

    // Add top copy button for bot messages
    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-markdown-btn';
    copyBtn.innerHTML = 'üìã';
    copyBtn.onclick = (e) => {
      e.stopPropagation();
      copyMessageMarkdown(div, copyBtn);
    };
    div.appendChild(copyBtn);
  } else {
    div.textContent = text;

    // Store plain text for user messages
    if(cls === 'from-user') {
      messageMarkdown.set(div, text);
    }
  }

  messagesDiv.insertBefore(div, activityIndicator);

  // Add bottom copy button AFTER the message div for bot messages
  if(isHtml && cls === 'from-bot' && rawMarkdown){
    const bottomCopyWrapper = document.createElement('div');
    bottomCopyWrapper.className = 'copy-markdown-btn-bottom';
    const bottomCopyBtn = document.createElement('button');
    bottomCopyBtn.innerHTML = 'üìã';
    bottomCopyBtn.title = 'Copy to clipboard';
    bottomCopyBtn.onclick = (e) => {
      e.stopPropagation();
      copyMessageMarkdown(div, bottomCopyBtn);
    };
    bottomCopyWrapper.appendChild(bottomCopyBtn);
    messagesDiv.insertBefore(bottomCopyWrapper, activityIndicator);
  }

  // Add bottom copy button for user messages
  if(cls === 'from-user'){
    const userCopyWrapper = document.createElement('div');
    userCopyWrapper.className = 'copy-user-btn-bottom';

    // Recycle button (reuse message)
    const recycleBtn = document.createElement('button');
    recycleBtn.innerHTML = '‚ôªÔ∏è';
    recycleBtn.title = 'Reuse this message';
    recycleBtn.onclick = (e) => {
      e.stopPropagation();
      reuseMessage(div);
    };
    userCopyWrapper.appendChild(recycleBtn);

    // Copy button
    const userCopyBtn = document.createElement('button');
    userCopyBtn.innerHTML = 'üìã';
    userCopyBtn.title = 'Copy to clipboard';
    userCopyBtn.onclick = (e) => {
      e.stopPropagation();
      copyMessageMarkdown(div, userCopyBtn);
    };
    userCopyWrapper.appendChild(userCopyBtn);

    messagesDiv.insertBefore(userCopyWrapper, activityIndicator);
  }

  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

function copyMessageMarkdown(messageDiv, copyBtn) {
  const markdown = messageMarkdown.get(messageDiv);
  if(!markdown) return;

  navigator.clipboard.writeText(markdown).then(() => {
    // Show success feedback
    copyBtn.innerHTML = '‚úì';
    copyBtn.classList.add('copied');

    // Reset after 2 seconds
    setTimeout(() => {
      copyBtn.innerHTML = 'üìã';
      copyBtn.classList.remove('copied');
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy:', err);
    copyBtn.innerHTML = '‚ùå';
    setTimeout(() => {
      copyBtn.innerHTML = 'üìã';
    }, 2000);
  });
}

function reuseMessage(messageDiv) {
  const text = messageMarkdown.get(messageDiv);
  if(!text) return;

  // Clear the current chat
  messagesDiv.innerHTML='';
  Object.keys(toolPlacards).forEach(key => delete toolPlacards[key]);
  messagesDiv.appendChild(activityIndicator);
  previousAgent = null;
  currentAgentId = null;
  isComplete = false;
  headerInfo = null;
  forceHideActivityIndicator();
  resetEventTracking();

  // Clear backend history
  fetch(clearUrl, {method:'POST'}).catch(err => console.error('Failed to clear history:', err));

  // Remove header if it exists
  const header = document.getElementById('chatHeader');
  if(header) header.remove();

  // Enable the form and pre-fill
  if(input) {
    input.disabled = false;
    input.placeholder = 'Send a message...';
    input.value = text;
    input.focus();

    // Auto-resize the textarea
    input.style.height = 'auto';
    input.style.height = input.scrollHeight + 'px';
  }
}

function setupFormHandlers() {
  // Enter key to submit
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      form.requestSubmit();
    }
  });

  // Form submission
  form.onsubmit = async e => {
    e.preventDefault();
    const text = input.value.trim();
    if (!text) return;

    input.value = '';
    input.disabled = true;

    // Check if continuing from previous agent
    const continueAgentId = input.dataset.continueAgent;
    delete input.dataset.continueAgent;

    const payload = { message: text, backend: currentBackend };
    if (continueAgentId) {
      payload['continue'] = continueAgentId;
    }

    const r = await fetch(sendUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

    if (r.ok) {
      const d = await r.json();
      // Load the agent (will fetch initial events and subscribe to WebSocket)
      await loadAgent(d.agent_id);
    } else {
      input.disabled = false;
      let err = 'Error';
      try { const d = await r.json(); err = d.error || err; } catch { };
      if (window.showError) showError(err);
    }
  };
}

async function loadHistory(){
  const r=await fetch(historyUrl);
  if(!r.ok)return;
  const d=await r.json();
  for(const m of d.history){
    addMessage(m.text,m.role==='user'?'from-user':'from-bot');
  }
}


// Unified event handler for both live and historical events
function processEvent(event) {
  switch(event.event) {
    case 'start':
      // Set up header info and show user message
      headerInfo = {
        startTs: event.ts,
        prompt: event.prompt
      };
      updateHeader();
      addMessage(event.prompt || '', 'from-user');
      break;

    case 'tool_start':
      handleToolStart(event);
      break;

    case 'tool_end':
      completeToolPlacard(event.call_id, event.result);
      break;

    case 'thinking':
      addThinkingCard(event.summary, event.model || 'unknown');
      break;

    case 'agent_updated':
      addAgentUpdate(event.agent || 'unknown');
      break;

    case 'finish':
      // Add final message
      if(event.html){
        addMessage(event.html, 'from-bot', true, event.rawMarkdown);
      }

      // Mark as complete
      isComplete = true;
      if (headerInfo) {
        headerInfo.endTs = event.ts;
        updateHeader();
      }
      forceHideActivityIndicator();

      // Enable continuation if available
      if(event.conversation_id && input){
        input.disabled = false;
        input.placeholder = 'Continue conversation...';
        input.dataset.continueAgent = event.agent_id;
      }
      break;

    case 'error':
      // Display error message
      if(event.html){
        addMessage(event.html, 'from-bot', true, event.rawMarkdown);
      }

      // Mark as complete (failed)
      isComplete = true;
      if (headerInfo) {
        headerInfo.endTs = event.ts;
        updateHeader();
      }
      forceHideActivityIndicator();
      break;
  }
}

// Handle tool_start events
function handleToolStart(event) {
  const {tool, args, call_id} = event;

  // Handle search tools with special event cards
  if(args && args.query) {
    // Determine which index is being searched
    let idx = 'summaries';
    let indexName = 'Summaries';
    if(tool.includes('event')) {
      idx = 'events';
      indexName = 'Events';
    } else if(tool.includes('transcript')) {
      idx = 'transcripts';
      indexName = 'Transcripts';
    }

    // Extract date from query if present (format: YYYYMMDD or YYYY-MM-DD)
    let dateStr = '';
    const dateMatch = args.query.match(/\b(\d{8}|\d{4}-\d{2}-\d{2})\b/);
    if(dateMatch) {
      const dateRaw = dateMatch[1].replace(/-/g, '');
      const month = parseInt(dateRaw.substring(4, 6), 10);
      const day = parseInt(dateRaw.substring(6, 8), 10);
      dateStr = ` on ${month}/${day}`;
    }

    // Build search URL
    const q = args.query + (idx === 'summaries' ? '' : ' index:' + idx);
    const url = searchBase + '#q=' + encodeURIComponent(q);

    // Create descriptive text
    const searchText = `Searching ${indexName} for "${args.query}"${dateStr}`;
    addEventCard(searchText, url, event);
    return;
  }

  // Handle get_resource tool
  if(tool === 'get_resource' && args && args.uri) {
    const resourceCard = createResourceCard(args.uri);
    if(resourceCard) {
      addEventCard(resourceCard.text, resourceCard.url, event);
      return;
    }
  }

  // Default: show tool placard
  addToolPlacard(tool, event, call_id);
}

// Create resource card for get_resource tool
function createResourceCard(uri) {
  // Helper to format date from YYYYMMDD to M/D
  function formatDate(dateStr) {
    const month = parseInt(dateStr.substring(4, 6), 10);
    const day = parseInt(dateStr.substring(6, 8), 10);
    return `${month}/${day}`;
  }

  // Helper to format time from HHMMSS to HH:MM
  function formatTime(timeStr) {
    const hours = timeStr.substring(0, 2);
    const minutes = timeStr.substring(2, 4);
    return `${hours}:${minutes}`;
  }

  // Parse journal://summary/20250815/meetings format
  let match = uri.match(/journal:\/\/summary\/(\d{8})\/(.+)/);
  if(match) {
    const date = match[1];
    const topic = match[2];
    const dateStr = formatDate(date);
    const topicDisplay = topic.charAt(0).toUpperCase() + topic.slice(1);

    return {
      text: `Reading ${topicDisplay} Summary from ${dateStr}`,
      url: `/calendar/${date}#${topic}`
    };
  }

  // Parse journal://transcripts/{mode}/20250726/090000/45 format
  match = uri.match(/journal:\/\/transcripts\/(full|audio|screen)\/(\d{8})\/(\d{6})\/(\d+)/);
  if(match) {
    const mode = match[1];
    const date = match[2];
    const time = match[3];
    const length = match[4];
    const dateStr = formatDate(date);
    const timeStr = formatTime(time);

    const modeText = mode === 'full' ? 'full' : mode === 'audio' ? 'audio-only' : 'screen-only';

    return {
      text: `Loading ${length}-minute ${modeText} transcript from ${dateStr} at ${timeStr}`,
      url: `/calendar/${date}`
    };
  }

  // Parse journal://media/20250726/audio_090000.flac or screenshot_090000.png format
  match = uri.match(/journal:\/\/media\/(\d{8})\/(.+)/);
  if(match) {
    const date = match[1];
    const filename = match[2];
    const dateStr = formatDate(date);

    // Determine media type from filename
    let description = filename;
    if(filename.includes('audio') || filename.endsWith('.flac')) {
      const timeMatch = filename.match(/(\d{6})/);
      if(timeMatch) {
        description = `audio recording from ${formatTime(timeMatch[1])}`;
      }
    } else if(filename.includes('screenshot') || filename.endsWith('.png')) {
      const timeMatch = filename.match(/(\d{6})/);
      if(timeMatch) {
        description = `screenshot from ${formatTime(timeMatch[1])}`;
      }
    }

    return {
      text: `Loading ${description} (${dateStr})`,
      url: `/calendar/${date}`
    };
  }

  // Fallback for unknown journal:// formats
  if(uri.startsWith('journal://')) {
    return {
      text: `Fetching journal resource: ${uri}`,
      url: '#'
    };
  }

  return null;
}


// Initialize WebSocket listener and controls
(function initChatControls(){
  if(chatControlsInitialized) return;
  chatControlsInitialized = true;

  // Global WebSocket listener for cortex events
  appEvents.listen('cortex', e => {
    // Only process events for our current agent
    if (!currentAgentId || e.agent_id !== currentAgentId) {
      return;
    }

    // Stop listening once complete
    if (isComplete) {
      return;
    }

    // Deduplicate and enrich
    if (shouldSkipEvent(e)) {
      return;
    }

    const enriched = enrichEvent(e);
    processEvent(enriched);
  });
})();

// Load agent from URL parameter if present
const agentParam = urlParams.get('agent');
if (agentParam && /^\d+$/.test(agentParam)) {
  loadAgent(agentParam);
}
</script>
