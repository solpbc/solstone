<style>
#messages {
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  overflow-x: hidden;
}

/* Base message styles */
.message {
  margin-bottom: 0.75em;
  padding: 0.75em 1em;
  border-radius: 12px;
  max-width: 75%;
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
  animation: fadeInUp 0.3s ease-out;
  position: relative;
}

/* User messages - use facet theme colors */
.from-user {
  background: var(--facet-color, #667eea);
  color: white;
  align-self: flex-end;
  margin-left: 20%;
}

/* Bot messages */
.from-bot {
  background: #fff;
  border: 1px solid #e0e0e0;
  align-self: flex-start;
  margin-right: 20%;
}

/* Action buttons - integrated into message, hover-only, small */
.message-actions {
  position: absolute;
  bottom: 0.4em;
  display: flex;
  gap: 0.25em;
  opacity: 0;
  transition: opacity 0.15s;
}
.from-user .message-actions { left: 0.5em; }
.from-bot .message-actions { right: 0.5em; }
.message:hover .message-actions { opacity: 1; }

.message-actions button {
  background: transparent;
  border: none;
  padding: 0.2em;
  cursor: pointer;
  font-size: 0.7em;
  opacity: 0.5;
  transition: opacity 0.15s;
  line-height: 1;
}
.message-actions button:hover { opacity: 1; }
.from-user .message-actions button { color: rgba(255,255,255,0.9); }
.from-bot .message-actions button { color: #666; }
.message-actions button.copied { opacity: 1; color: #4caf50; }

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Event cards, tool placards, etc */
#messages .event-card {
  background: #fff4e5;
  border: 1px solid #f0ad4e;
  border-radius: 6px;
  padding: 0.5em 0.75em;
  margin-bottom: 0.75em;
  font-size: 0.85em;
  max-width: 80%;
  align-self: flex-start;
  cursor: help;
  transition: all 0.2s;
}
#messages .event-card:hover {
  background: #fff0d4;
  border-color: #e09e3a;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
#messages .event-card a { text-decoration: none; color: #007bff; }
#messages .event-card a:hover { text-decoration: underline; }

#messages .tool-placard {
  background: #e3f2fd;
  border: 1px solid #2196f3;
  border-radius: 6px;
  padding: 0.4em 0.6em;
  margin-bottom: 0.5em;
  font-size: 0.8em;
  max-width: 60%;
  align-self: flex-start;
  cursor: help;
  transition: all 0.2s;
}
#messages .tool-placard:hover {
  background: #d1e8fc;
  border-color: #1976d2;
  transform: translateY(-1px);
}
#messages .tool-placard .tool-name { font-weight: bold; color: #1976d2; }
#messages .tool-placard .tool-status { font-size: 0.9em; color: #666; margin-left: 0.5em; }
#messages .tool-placard.completed { background: #e8f5e9; border-color: #4caf50; }
#messages .tool-placard.completed:hover { background: #d4f0d7; }
#messages .tool-placard.completed .tool-name { color: #2e7d32; }

#messages .agent-update {
  background: #fff3e0;
  border: 1px solid #ff9800;
  border-radius: 6px;
  padding: 0.4em 0.6em;
  margin-bottom: 0.5em;
  font-size: 0.8em;
  max-width: 60%;
  align-self: flex-start;
  color: #e65100;
  font-style: italic;
  transition: all 0.2s;
}
#messages .agent-update:hover { background: #ffe8cc; }

#messages .thinking-card {
  background: #f8f4ff;
  border: 1px solid #9c27b0;
  border-radius: 6px;
  padding: 0.5em 0.75em;
  margin-bottom: 0.75em;
  font-size: 0.85em;
  max-width: 80%;
  align-self: flex-start;
  cursor: pointer;
  transition: all 0.2s;
}
#messages .thinking-card:hover {
  background: #f3e5f5;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
#messages .thinking-card .thinking-label { font-weight: bold; color: #7b1fa2; margin-bottom: 0.25em; }
#messages .thinking-card .thinking-content { color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#messages .thinking-card.expanded .thinking-content { white-space: pre-wrap; overflow: visible; text-overflow: clip; }

/* Message content typography */
.message h1, .message h2, .message h3, .message h4, .message h5, .message h6 { margin: 0.5em 0 0.3em 0; }
.message p { margin: 0.3em 0; }
.message ul, .message ol { margin: 0.3em 0; padding-left: 1.5em; }
.message code { background: rgba(0,0,0,0.1); padding: 0.1em 0.3em; border-radius: 3px; font-size: 0.9em; }
.from-user code { background: rgba(255,255,255,0.2); }
.message pre { background: rgba(0,0,0,0.1); padding: 0.5em; border-radius: 4px; overflow-x: auto; margin: 0.5em 0; }
.from-user pre { background: rgba(255,255,255,0.15); }
.message pre code { background: none; padding: 0; }
.message blockquote { margin: 0.5em 0; padding-left: 1em; border-left: 3px solid rgba(0,0,0,0.2); }
.from-user blockquote { border-left-color: rgba(255,255,255,0.4); }

/* Activity indicator - uses facet color */
@keyframes typingBounce {
  0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
  40% { transform: scale(1); opacity: 1; }
}
.activity-indicator {
  align-self: flex-start;
  padding: 0.5em 0.75em;
  background: var(--facet-bg, #f0f0f0);
  border-radius: 12px;
  margin-bottom: 0.5em;
  display: none;
}
.activity-indicator.active {
  display: flex;
  align-items: center;
  gap: 4px;
  animation: fadeInUp 0.3s ease-out;
}
.activity-indicator span {
  width: 6px;
  height: 6px;
  background: var(--facet-color, #999);
  border-radius: 50%;
  animation: typingBounce 1.4s infinite ease-in-out;
}
.activity-indicator span:nth-child(1) { animation-delay: -0.32s; }
.activity-indicator span:nth-child(2) { animation-delay: -0.16s; }
</style>

<div class="workspace-content">
  <div id="messages"></div>
</div>

<script src="{{ vendor_lib('marked') }}"></script>
<script>
const sendUrl = '{{ url_for('app:chat.send_message') }}';
const clearUrl = '{{ url_for('app:chat.clear_history') }}';
const agentUrl = '{{ url_for('app:chat.agent_events', agent_id='AGENT_ID') }}';
const messagesDiv = document.getElementById('messages');
const searchBase = '{{ url_for('app:search.index') }}';

// Simple error display - adds error message to chat
function showError(message) {
  const div = document.createElement('div');
  div.className = 'message from-bot';
  div.innerHTML = `<strong style="color:#c62828">Error:</strong> ${message}`;
  messagesDiv.appendChild(div);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;

  // Re-enable input so user can retry
  if (input) {
    input.disabled = false;
    input.placeholder = 'Send a message...';
    input.focus();
  }
}

// Wait for app bar to load
let form, input, backendToggle, currentBackend;

function initAppBarControls() {
  form = document.getElementById('chatInputForm');
  input = document.getElementById('chatMessageInput');
  backendToggle = document.getElementById('chatBackendToggle');

  if (!form || !input || !backendToggle) {
    console.error('Chat controls not found');
    return;
  }

  currentBackend = backendToggle.dataset.backend || 'anthropic';

  // Backend toggle cycle
  const backends = {
    anthropic: { next: 'google', label: 'Claude' },
    google: { next: 'openai', label: 'Gemini' },
    openai: { next: 'anthropic', label: 'GPT-4' }
  };

  backendToggle.addEventListener('click', () => {
    currentBackend = backends[currentBackend].next;
    backendToggle.dataset.backend = currentBackend;
    backendToggle.textContent = backends[currentBackend].label;
  });

  setupFormHandlers();
  input.focus();
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', initAppBarControls);
} else {
  initAppBarControls();
}

// Deduplication using agent_id:ts as key
const processedEventIds = new Set();
const MAX_EVENT_IDS = 500;

function shouldSkipEvent(event) {
  if (!event || !event.agent_id || !event.ts) {
    return false;
  }
  const eventKey = `${event.agent_id}:${event.ts}`;
  if (processedEventIds.has(eventKey)) {
    return true;
  }
  processedEventIds.add(eventKey);

  // Prevent memory leak - clear old entries if too many
  if (processedEventIds.size > MAX_EVENT_IDS) {
    const entries = Array.from(processedEventIds);
    entries.slice(0, 100).forEach(e => processedEventIds.delete(e));
  }
  return false;
}

function resetEventTracking() {
  processedEventIds.clear();
}

// Single source of truth for event rendering
function enrichEvent(event) {
  const enriched = {...event};

  // Render finish events
  if (event.event === 'finish') {
    const resultText = event.result || '';
    enriched.html = marked.parse(resultText, {
      breaks: true,  // nl2br equivalent
      gfm: true      // GitHub Flavored Markdown
    });
    enriched.rawMarkdown = resultText;
  }

  // Render error events
  else if (event.event === 'error') {
    const errorMsg = event.error || 'Unknown error';
    const trace = event.trace || '';
    const errorText = trace
      ? `‚ùå **Error**: ${errorMsg}\n\n\`\`\`\n${trace}\n\`\`\``
      : `‚ùå **Error**: ${errorMsg}`;
    enriched.html = marked.parse(errorText, {breaks: true, gfm: true});
    enriched.rawMarkdown = errorText;
    enriched.result = errorText;
  }

  return enriched;
}

// Parse URL parameters
const urlParams = new URLSearchParams(window.location.search);

// State management
let currentAgentId = null;
let isComplete = false;

// Create persistent activity indicator
const activityIndicator = document.createElement('div');
activityIndicator.className = 'activity-indicator';
activityIndicator.id = 'activityIndicator';
activityIndicator.innerHTML = '<span></span><span></span><span></span>';

let chatControlsInitialized = false;

function showActivityIndicator() {
  if (!document.getElementById('activityIndicator')) {
    messagesDiv.appendChild(activityIndicator);
  }
  activityIndicator.classList.add('active');
  requestAnimationFrame(() => {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  });
}

function forceHideActivityIndicator() {
  activityIndicator.classList.remove('active');
}

function ensureActivityIndicatorAtBottom() {
  // Ensure activity indicator is always the last element
  if (!activityIndicator.parentNode) {
    messagesDiv.appendChild(activityIndicator);
  } else if (activityIndicator.parentNode === messagesDiv && messagesDiv.lastElementChild !== activityIndicator) {
    messagesDiv.appendChild(activityIndicator);
  }
}

function addEventCard(text, url, event){
  const div=document.createElement('div');
  div.className='event-card';
  const a=document.createElement('a');
  a.href=url;
  a.textContent=text;
  div.appendChild(a);

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Track tool calls by ID to update them when complete
// Limit to prevent memory leaks
const toolPlacards = {};
const MAX_TOOL_PLACARDS = 100;

// Track agent switches - only show when switching between agents
let previousAgent = null;

// Clean up old tool placards when limit reached
function cleanupOldPlacards() {
  const keys = Object.keys(toolPlacards);
  if (keys.length > MAX_TOOL_PLACARDS) {
    // Remove oldest entries (first half)
    const toRemove = keys.slice(0, Math.floor(keys.length / 2));
    toRemove.forEach(key => delete toolPlacards[key]);
  }
}

function addToolPlacard(toolName, event, callId){
  const div=document.createElement('div');
  div.className='tool-placard';

  const nameSpan=document.createElement('span');
  nameSpan.className='tool-name';
  nameSpan.textContent='üîß ' + toolName;
  div.appendChild(nameSpan);

  const statusSpan=document.createElement('span');
  statusSpan.className='tool-status';
  statusSpan.textContent='(running...)';
  div.appendChild(statusSpan);

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;

  // Store reference to update later
  if(callId){
    toolPlacards[callId] = {div, statusSpan};
    cleanupOldPlacards();  // Clean up if too many
  }
  return div;
}

function completeToolPlacard(callId, result){
  if(toolPlacards[callId]){
    const {div, statusSpan} = toolPlacards[callId];
    div.classList.add('completed');
    statusSpan.textContent = '‚úì';

    // Update title attribute with result
    if(result && div.title){
      const resultText = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
      div.title += '\n\n=== Result ===\n' + resultText;
    }

    delete toolPlacards[callId];
  }
}

function addAgentUpdate(agentName){
  // Only show agent switch if we're actually switching from one agent to another
  if(previousAgent && previousAgent !== agentName){
    const div=document.createElement('div');
    div.className='agent-update';
    div.textContent=`‚Üí Switched from ${previousAgent} to ${agentName} agent`;
    messagesDiv.insertBefore(div, activityIndicator);
    ensureActivityIndicatorAtBottom();
    messagesDiv.scrollTop=messagesDiv.scrollHeight;
  }
  previousAgent = agentName;
}

function addThinkingCard(summary, model){
  const div=document.createElement('div');
  div.className='thinking-card';

  const label=document.createElement('div');
  label.className='thinking-label';
  label.textContent=`üí≠ Thinking (${model})`;
  div.appendChild(label);

  const content=document.createElement('div');
  content.className='thinking-content';
  content.textContent=summary;
  div.appendChild(content);

  div.addEventListener('click', () => {
    div.classList.toggle('expanded');
  });

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Agent loading function
async function loadAgent(agentId) {
  currentAgentId = agentId;
  isComplete = false;
  resetEventTracking();

  // Clear messages but keep activity indicator
  messagesDiv.innerHTML = '';
  messagesDiv.appendChild(activityIndicator);
  Object.keys(toolPlacards).forEach(key => delete toolPlacards[key]);
  previousAgent = null;

  // Fetch existing events from disk
  const url = agentUrl.replace('AGENT_ID', agentId);
  try {
    const response = await fetch(url);
    if (!response.ok) {
      showError(`Failed to load agent: ${response.statusText}`);
      return;
    }

    const data = await response.json();
    const events = data.events || [];
    isComplete = data.is_complete || false;

    // Process historical events
    for (const event of events) {
      const enriched = enrichEvent(event);
      if (!shouldSkipEvent(enriched)) {
        processEvent(enriched);
      }
    }

    // Show activity indicator if not complete
    if (!isComplete) {
      showActivityIndicator();
    } else {
      forceHideActivityIndicator();

      // Check if we can continue the conversation
      const finishEvent = events.find(e => e.event === 'finish');
      if (finishEvent && finishEvent.conversation_id && input) {
        input.disabled = false;
        input.placeholder = 'Continue conversation...';
        input.dataset.continueAgent = agentId;
      }
    }

  } catch (error) {
    showError(`Failed to load agent: ${error.message}`);
  }
}

// Store raw markdown for each bot message
const messageMarkdown = new WeakMap();

function addMessage(text, cls, isHtml=false, rawMarkdown=null){
  const div=document.createElement('div');
  div.className='message '+cls;

  // Use HTML for bot messages if provided, otherwise plain text
  if(isHtml && cls === 'from-bot'){
    div.innerHTML = text;
    if(rawMarkdown) {
      messageMarkdown.set(div, rawMarkdown);
    }
  } else {
    div.textContent = text;
    if(cls === 'from-user') {
      messageMarkdown.set(div, text);
    }
  }

  // Create action buttons container (integrated into message)
  const actions = document.createElement('div');
  actions.className = 'message-actions';

  if(cls === 'from-user'){
    // Recycle button
    const recycleBtn = document.createElement('button');
    recycleBtn.innerHTML = '‚ôªÔ∏è';
    recycleBtn.title = 'Reuse';
    recycleBtn.onclick = (e) => {
      e.stopPropagation();
      reuseMessage(div);
    };
    actions.appendChild(recycleBtn);
  }

  // Copy button for all messages
  const copyBtn = document.createElement('button');
  copyBtn.innerHTML = 'üìã';
  copyBtn.title = 'Copy';
  copyBtn.onclick = (e) => {
    e.stopPropagation();
    copyMessageMarkdown(div, copyBtn);
  };
  actions.appendChild(copyBtn);

  div.appendChild(actions);
  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

function copyMessageMarkdown(messageDiv, copyBtn) {
  const markdown = messageMarkdown.get(messageDiv);
  if(!markdown) {
    // Nothing to copy - brief feedback
    copyBtn.innerHTML = '‚àí';
    setTimeout(() => { copyBtn.innerHTML = 'üìã'; }, 1000);
    return;
  }

  navigator.clipboard.writeText(markdown).then(() => {
    copyBtn.innerHTML = '‚úì';
    copyBtn.classList.add('copied');
    setTimeout(() => {
      copyBtn.innerHTML = 'üìã';
      copyBtn.classList.remove('copied');
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy:', err);
    copyBtn.innerHTML = '‚ùå';
    setTimeout(() => { copyBtn.innerHTML = 'üìã'; }, 2000);
  });
}

function reuseMessage(messageDiv) {
  const text = messageMarkdown.get(messageDiv);
  if(!text) return;

  // Clear the current chat
  messagesDiv.innerHTML='';
  Object.keys(toolPlacards).forEach(key => delete toolPlacards[key]);
  messagesDiv.appendChild(activityIndicator);
  previousAgent = null;
  currentAgentId = null;
  isComplete = false;
  forceHideActivityIndicator();
  resetEventTracking();

  // Clear backend history
  fetch(clearUrl, {method:'POST'}).catch(err => console.error('Failed to clear history:', err));

  // Enable the form and pre-fill
  if(input) {
    input.disabled = false;
    input.placeholder = 'Send a message...';
    input.value = text;
    input.focus();

    // Auto-resize the textarea
    input.style.height = 'auto';
    input.style.height = input.scrollHeight + 'px';
  }
}

function setupFormHandlers() {
  // Enter key to submit
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      form.requestSubmit();
    }
  });

  // Form submission
  form.onsubmit = async e => {
    e.preventDefault();
    const text = input.value.trim();
    if (!text) return;

    input.value = '';
    input.disabled = true;

    // Check if continuing from previous agent
    const continueAgentId = input.dataset.continueAgent;
    delete input.dataset.continueAgent;

    const payload = { message: text, backend: currentBackend };
    if (continueAgentId) {
      payload['continue'] = continueAgentId;
    }

    const r = await fetch(sendUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

    if (r.ok) {
      const d = await r.json();
      // Load the agent (will fetch initial events and subscribe to WebSocket)
      await loadAgent(d.agent_id);
    } else {
      input.disabled = false;
      let err = 'Error';
      try { const d = await r.json(); err = d.error || err; } catch { };
      if (window.showError) showError(err);
    }
  };
}

// Event handler for both live and historical events
function processEvent(event) {
  switch(event.event) {
    case 'start':
      addMessage(event.prompt || '', 'from-user');
      break;

    case 'tool_start':
      handleToolStart(event);
      break;

    case 'tool_end':
      completeToolPlacard(event.call_id, event.result);
      break;

    case 'thinking':
      addThinkingCard(event.summary, event.model || 'unknown');
      break;

    case 'agent_updated':
      addAgentUpdate(event.agent || 'unknown');
      break;

    case 'finish':
      // Add final message
      if(event.html){
        addMessage(event.html, 'from-bot', true, event.rawMarkdown);
      }

      isComplete = true;
      forceHideActivityIndicator();

      // Re-enable input
      if(input){
        input.disabled = false;
        if(event.conversation_id){
          input.placeholder = 'Continue conversation...';
          input.dataset.continueAgent = event.agent_id;
        } else {
          input.placeholder = 'Send a message...';
        }
      }
      break;

    case 'error':
      // Display error message
      if(event.html){
        addMessage(event.html, 'from-bot', true, event.rawMarkdown);
      }

      isComplete = true;
      forceHideActivityIndicator();

      // Re-enable input so user can retry
      if(input){
        input.disabled = false;
        input.placeholder = 'Send a message...';
      }
      break;
  }
}

// Handle tool_start events
function handleToolStart(event) {
  const {tool, args, call_id} = event;

  // Handle search tools with special event cards
  if(args && args.query) {
    // Determine which index is being searched
    let idx = 'insights';
    let indexName = 'Insights';
    if(tool.includes('event')) {
      idx = 'events';
      indexName = 'Events';
    } else if(tool.includes('transcript')) {
      idx = 'transcripts';
      indexName = 'Transcripts';
    }

    // Extract date from query if present (format: YYYYMMDD or YYYY-MM-DD)
    let dateStr = '';
    const dateMatch = args.query.match(/\b(\d{8}|\d{4}-\d{2}-\d{2})\b/);
    if(dateMatch) {
      const dateRaw = dateMatch[1].replace(/-/g, '');
      const month = parseInt(dateRaw.substring(4, 6), 10);
      const day = parseInt(dateRaw.substring(6, 8), 10);
      dateStr = ` on ${month}/${day}`;
    }

    // Build search URL
    const q = args.query + (idx === 'insights' ? '' : ' index:' + idx);
    const url = searchBase + '#q=' + encodeURIComponent(q);

    // Create descriptive text
    const searchText = `Searching ${indexName} for "${args.query}"${dateStr}`;
    addEventCard(searchText, url, event);
    return;
  }

  // Handle get_resource tool
  if(tool === 'get_resource' && args && args.uri) {
    const resourceCard = createResourceCard(args.uri);
    if(resourceCard) {
      addEventCard(resourceCard.text, resourceCard.url, event);
      return;
    }
  }

  // Default: show tool placard
  addToolPlacard(tool, event, call_id);
}

// Create resource card for get_resource tool
function createResourceCard(uri) {
  // Helper to format date from YYYYMMDD to M/D
  function formatDate(dateStr) {
    const month = parseInt(dateStr.substring(4, 6), 10);
    const day = parseInt(dateStr.substring(6, 8), 10);
    return `${month}/${day}`;
  }

  // Helper to format time from HHMMSS to HH:MM
  function formatTime(timeStr) {
    const hours = timeStr.substring(0, 2);
    const minutes = timeStr.substring(2, 4);
    return `${hours}:${minutes}`;
  }

  // Parse journal://summary/20250815/meetings format
  let match = uri.match(/journal:\/\/summary\/(\d{8})\/(.+)/);
  if(match) {
    const date = match[1];
    const topic = match[2];
    const dateStr = formatDate(date);
    const topicDisplay = topic.charAt(0).toUpperCase() + topic.slice(1);

    return {
      text: `Reading ${topicDisplay} Summary from ${dateStr}`,
      url: `/calendar/${date}#${topic}`
    };
  }

  // Parse journal://transcripts/{mode}/20250726/090000/45 format
  match = uri.match(/journal:\/\/transcripts\/(full|audio|screen)\/(\d{8})\/(\d{6})\/(\d+)/);
  if(match) {
    const mode = match[1];
    const date = match[2];
    const time = match[3];
    const length = match[4];
    const dateStr = formatDate(date);
    const timeStr = formatTime(time);

    const modeText = mode === 'full' ? 'full' : mode === 'audio' ? 'audio-only' : 'screen-only';

    return {
      text: `Loading ${length}-minute ${modeText} transcript from ${dateStr} at ${timeStr}`,
      url: `/calendar/${date}`
    };
  }

  // Parse journal://media/20250726/audio_090000.flac or screenshot_090000.png format
  match = uri.match(/journal:\/\/media\/(\d{8})\/(.+)/);
  if(match) {
    const date = match[1];
    const filename = match[2];
    const dateStr = formatDate(date);

    // Determine media type from filename
    let description = filename;
    if(filename.includes('audio') || filename.endsWith('.flac')) {
      const timeMatch = filename.match(/(\d{6})/);
      if(timeMatch) {
        description = `audio recording from ${formatTime(timeMatch[1])}`;
      }
    } else if(filename.includes('screenshot') || filename.endsWith('.png')) {
      const timeMatch = filename.match(/(\d{6})/);
      if(timeMatch) {
        description = `screenshot from ${formatTime(timeMatch[1])}`;
      }
    }

    return {
      text: `Loading ${description} (${dateStr})`,
      url: `/calendar/${date}`
    };
  }

  // Fallback for unknown journal:// formats
  if(uri.startsWith('journal://')) {
    return {
      text: `Fetching journal resource: ${uri}`,
      url: '#'
    };
  }

  return null;
}


// Initialize WebSocket listener and controls
(function initChatControls(){
  if(chatControlsInitialized) return;
  chatControlsInitialized = true;

  // Global WebSocket listener for cortex events
  appEvents.listen('cortex', e => {
    // Only process events for our current agent
    if (!currentAgentId || e.agent_id !== currentAgentId) {
      return;
    }

    // Stop listening once complete
    if (isComplete) {
      return;
    }

    // Deduplicate and enrich
    if (shouldSkipEvent(e)) {
      return;
    }

    const enriched = enrichEvent(e);
    processEvent(enriched);
  });
})();

// Load agent from URL parameter if present
const agentParam = urlParams.get('agent');
if (agentParam && /^\d+$/.test(agentParam)) {
  loadAgent(agentParam);
}
</script>
