<style>
#messages {
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  overflow-x: hidden;
}

/* Base message styles */
.message {
  margin-bottom: 0.75em;
  padding: 0.75em 1em;
  border-radius: 12px;
  max-width: 75%;
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
  animation: fadeInUp 0.3s ease-out;
  position: relative;
}

/* User messages - use facet theme colors */
.from-user {
  background: var(--facet-color, #667eea);
  color: white;
  align-self: flex-end;
  margin-left: 20%;
}

/* Bot messages */
.from-bot {
  background: #fff;
  border: 1px solid #e0e0e0;
  align-self: flex-start;
  margin-right: 20%;
}

/* Action buttons - integrated into message, hover-only, small */
.message-actions {
  position: absolute;
  bottom: 0.4em;
  display: flex;
  gap: 0.25em;
  opacity: 0;
  transition: opacity 0.15s;
}
.from-user .message-actions { left: 0.5em; }
.from-bot .message-actions { right: 0.5em; }
.message:hover .message-actions { opacity: 1; }

.message-actions button {
  background: transparent;
  border: none;
  padding: 0.2em;
  cursor: pointer;
  font-size: 0.7em;
  opacity: 0.5;
  transition: opacity 0.15s;
  line-height: 1;
}
.message-actions button:hover { opacity: 1; }
.from-user .message-actions button { color: rgba(255,255,255,0.9); }
.from-bot .message-actions button { color: #666; }
.message-actions button.copied { opacity: 1; color: #4caf50; }

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Event cards, tool placards, etc */
#messages .event-card {
  background: #fff4e5;
  border: 1px solid #f0ad4e;
  border-radius: 6px;
  padding: 0.5em 0.75em;
  margin-bottom: 0.75em;
  font-size: 0.85em;
  max-width: 80%;
  align-self: flex-start;
  cursor: help;
  transition: all 0.2s;
}
#messages .event-card:hover {
  background: #fff0d4;
  border-color: #e09e3a;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
#messages .event-card a { text-decoration: none; color: #007bff; }
#messages .event-card a:hover { text-decoration: underline; }

/* Shared pill styles for tool params */
#messages .tool-params { margin-left: 0.5em; display: inline; }
#messages .tool-param {
  display: inline-block;
  background: rgba(0,0,0,0.08);
  border-radius: 3px;
  padding: 0.1em 0.4em;
  margin-left: 0.3em;
  font-size: 0.9em;
}
/* Event card pill colors */
#messages .event-card .tool-param { color: #805500; }
#messages .event-card .tool-param .param-label { color: #a06000; }
/* Tool placard pill colors */
#messages .tool-placard .tool-param { color: #555; }
#messages .tool-placard .tool-param .param-label { color: #888; }
#messages .tool-placard.completed .tool-param { background: rgba(0,0,0,0.06); }

#messages .tool-placard {
  background: #e3f2fd;
  border: 1px solid #2196f3;
  border-radius: 6px;
  padding: 0.4em 0.6em;
  margin-bottom: 0.5em;
  font-size: 0.8em;
  max-width: 60%;
  align-self: flex-start;
  cursor: help;
  transition: all 0.2s;
}
#messages .tool-placard:hover {
  background: #d1e8fc;
  border-color: #1976d2;
  transform: translateY(-1px);
}
#messages .tool-placard .tool-name { font-weight: bold; color: #1976d2; }
#messages .tool-placard .tool-status { font-size: 0.9em; color: #666; margin-left: 0.5em; }
#messages .tool-placard.completed { background: #e8f5e9; border-color: #4caf50; }
#messages .tool-placard.completed:hover { background: #d4f0d7; }
#messages .tool-placard.completed .tool-name { color: #2e7d32; }

#messages .agent-update {
  background: #fff3e0;
  border: 1px solid #ff9800;
  border-radius: 6px;
  padding: 0.4em 0.6em;
  margin-bottom: 0.5em;
  font-size: 0.8em;
  max-width: 60%;
  align-self: flex-start;
  color: #e65100;
  font-style: italic;
  transition: all 0.2s;
}
#messages .agent-update:hover { background: #ffe8cc; }

#messages .thinking-card {
  background: #f8f4ff;
  border: 1px solid #9c27b0;
  border-radius: 6px;
  padding: 0.5em 0.75em;
  margin-bottom: 0.75em;
  font-size: 0.85em;
  max-width: 80%;
  align-self: flex-start;
  cursor: pointer;
  transition: all 0.2s;
}
#messages .thinking-card:hover {
  background: #f3e5f5;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
#messages .thinking-card .thinking-label { font-weight: bold; color: #7b1fa2; margin-bottom: 0.25em; }
#messages .thinking-card .thinking-content { color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#messages .thinking-card.expanded .thinking-content { white-space: pre-wrap; overflow: visible; text-overflow: clip; }

/* Message content typography */
.message h1, .message h2, .message h3, .message h4, .message h5, .message h6 { margin: 0.5em 0 0.3em 0; }
.message p { margin: 0.3em 0; }
.message ul, .message ol { margin: 0.3em 0; padding-left: 1.5em; }
.message code { background: rgba(0,0,0,0.1); padding: 0.1em 0.3em; border-radius: 3px; font-size: 0.9em; }
.from-user code { background: rgba(255,255,255,0.2); }
.message pre { background: rgba(0,0,0,0.1); padding: 0.5em; border-radius: 4px; overflow-x: auto; margin: 0.5em 0; }
.from-user pre { background: rgba(255,255,255,0.15); }
.message pre code { background: none; padding: 0; }
.message blockquote { margin: 0.5em 0; padding-left: 1em; border-left: 3px solid rgba(0,0,0,0.2); }
.from-user blockquote { border-left-color: rgba(255,255,255,0.4); }

/* Activity indicator - uses facet color */
@keyframes typingBounce {
  0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
  40% { transform: scale(1); opacity: 1; }
}
.activity-indicator {
  align-self: flex-start;
  padding: 0.5em 0.75em;
  background: var(--facet-bg, #f0f0f0);
  border-radius: 12px;
  margin-bottom: 0.5em;
  display: none;
}
.activity-indicator.active {
  display: flex;
  align-items: center;
  gap: 4px;
  animation: fadeInUp 0.3s ease-out;
}
.activity-indicator span {
  width: 6px;
  height: 6px;
  background: var(--facet-color, #999);
  border-radius: 50%;
  animation: typingBounce 1.4s infinite ease-in-out;
}
.activity-indicator span:nth-child(1) { animation-delay: -0.32s; }
.activity-indicator span:nth-child(2) { animation-delay: -0.16s; }

/* Retry button for failed chats */
.retry-container {
  align-self: flex-start;
  margin-bottom: 0.75em;
  animation: fadeInUp 0.3s ease-out;
}
.retry-button {
  background: #fff3e0;
  border: 1px solid #ff9800;
  border-radius: 6px;
  padding: 0.5em 1em;
  font-size: 0.9em;
  cursor: pointer;
  color: #e65100;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 0.4em;
}
.retry-button:hover {
  background: #ffe0b2;
  border-color: #f57c00;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.retry-button:active {
  transform: translateY(0);
  box-shadow: none;
}
.retry-icon {
  font-size: 1.1em;
}

/* Recent chats panel */
.recent-chats-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2em;
  min-height: 200px;
}

.recent-chats-list {
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  width: 100%;
  max-width: 500px;
}

a.recent-chat-item {
  display: flex;
  flex-direction: column;
  padding: 0.75em 1em;
  background: #f8f9fa;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.15s;
  text-decoration: none;
  color: inherit;
}

.recent-chat-item:hover {
  background: #fff;
  border-color: var(--facet-color, #667eea);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.recent-chat-time {
  font-size: 0.75em;
  color: #888;
  margin-bottom: 0.25em;
}

.recent-chat-preview {
  font-size: 0.85em;
  color: #333;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.recent-chats-empty {
  color: #888;
  font-size: 0.85em;
  font-style: italic;
}

/* Unread styling */
.recent-chat-item.unread {
  background: #bbdefb;
  border-left: 3px solid #1976d2;
  font-weight: 700;
}

.unread-indicator {
  width: 10px;
  height: 10px;
  background: #1976d2;
  border-radius: 50%;
  display: inline-block;
  margin-right: 8px;
}

/* Panel header with unread count */
.recent-chats-header {
  display: flex;
  align-items: baseline;
  gap: 0.5em;
  margin-bottom: 1em;
}

.recent-chats-header h3 {
  margin: 0;
  color: #666;
  font-weight: normal;
  font-size: 0.9em;
}

.unread-count-badge {
  font-size: 0.75em;
  color: #1976d2;
  font-weight: 600;
}

/* See all link */
.see-all-link {
  margin-top: 1em;
  font-size: 0.85em;
  color: #666;
  text-decoration: none;
  transition: color 0.15s;
}

.see-all-link:hover {
  color: var(--facet-color, #1976d2);
  text-decoration: underline;
}

/* Back button */
.back-button {
  align-self: flex-start;
  padding: 0.5em 0.75em;
  margin-bottom: 0.5em;
  background: transparent;
  border: none;
  color: #666;
  font-size: 0.85em;
  cursor: pointer;
  transition: color 0.15s;
  text-decoration: none;
  display: inline-flex;
  align-items: center;
  gap: 0.25em;
}

.back-button:hover {
  color: var(--facet-color, #1976d2);
}

/* All chats view */
.all-chats-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1em 2em 2em;
}

.all-chats-header {
  display: flex;
  align-items: baseline;
  gap: 0.5em;
  margin-bottom: 1em;
  width: 100%;
  max-width: 500px;
}

.all-chats-header h3 {
  margin: 0;
  color: #333;
  font-weight: 600;
  font-size: 1em;
}

.all-chats-list {
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  width: 100%;
  max-width: 500px;
}

.load-more-container {
  margin-top: 1em;
  text-align: center;
}

.load-more-button {
  padding: 0.75em 1.5em;
  background: #f5f5f5;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  color: #666;
  font-size: 0.85em;
  cursor: pointer;
  transition: all 0.15s;
}

.load-more-button:hover {
  background: #fff;
  border-color: var(--facet-color, #1976d2);
  color: var(--facet-color, #1976d2);
}

/* Delete button on chat items */
.chat-item-actions {
  position: absolute;
  right: 0.5em;
  top: 50%;
  transform: translateY(-50%);
  opacity: 0;
  transition: opacity 0.15s;
}

.recent-chat-item {
  position: relative;
}

.recent-chat-item:hover .chat-item-actions {
  opacity: 1;
}

.delete-chat-btn {
  background: transparent;
  border: none;
  padding: 0.25em 0.5em;
  cursor: pointer;
  font-size: 0.9em;
  opacity: 0.5;
  transition: opacity 0.15s;
}

.delete-chat-btn:hover {
  opacity: 1;
}

/* Delete confirmation modal */
.delete-modal {
  display: none;
  position: fixed;
  z-index: 200;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
}

.delete-modal.visible {
  display: flex;
  align-items: center;
  justify-content: center;
}

.delete-modal-content {
  background: white;
  padding: 24px;
  border-radius: 12px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
}

.delete-modal-content h3 {
  margin: 0 0 16px 0;
  font-size: 18px;
  font-weight: 600;
  color: #333;
}

.delete-modal-content p {
  margin: 0 0 8px 0;
  color: #666;
}

.delete-modal-title {
  font-weight: 600;
  color: #333;
  word-break: break-word;
}

.delete-modal-warning {
  font-size: 0.85em;
  color: #999;
  margin-top: 12px;
}

.delete-modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 0.75em;
  margin-top: 20px;
}

.delete-modal-cancel {
  padding: 0.6em 1.2em;
  background: #f5f5f5;
  border: 1px solid #e0e0e0;
  border-radius: 6px;
  color: #666;
  font-size: 0.9em;
  cursor: pointer;
  transition: all 0.15s;
}

.delete-modal-cancel:hover {
  background: #eee;
}

.delete-modal-confirm {
  padding: 0.6em 1.2em;
  background: #ef5350;
  border: none;
  border-radius: 6px;
  color: white;
  font-size: 0.9em;
  cursor: pointer;
  transition: all 0.15s;
}

.delete-modal-confirm:hover {
  background: #e53935;
}
</style>

<div class="workspace-content">
  <div id="messages"></div>
</div>

<!-- Delete confirmation modal -->
<div class="delete-modal" id="deleteModal">
  <div class="delete-modal-content">
    <h3>Delete Chat</h3>
    <p>Are you sure you want to delete</p>
    <p class="delete-modal-title" id="deleteModalTitle"></p>
    <p class="delete-modal-warning">This cannot be undone.</p>
    <div class="delete-modal-actions">
      <button class="delete-modal-cancel" onclick="hideDeleteModal()">Cancel</button>
      <button class="delete-modal-confirm" id="deleteModalConfirm">Delete</button>
    </div>
  </div>
</div>

<script src="{{ vendor_lib('marked') }}"></script>
<script>
const sendUrl = '{{ url_for('app:chat.send_message') }}';
const chatsUrl = '{{ url_for('app:chat.list_chats') }}';
const messagesDiv = document.getElementById('messages');
const searchBase = '{{ url_for('app:search.index') }}';

// Recent chats data
let allChats = [];

// Format day from YYYYMMDD to M/D
function formatDay(dayStr) {
  if (!dayStr || dayStr.length !== 8) return dayStr;
  const month = parseInt(dayStr.substring(4, 6), 10);
  const day = parseInt(dayStr.substring(6, 8), 10);
  return `${month}/${day}`;
}

// Format timestamp as relative time
function formatRelativeTime(ts) {
  const now = Date.now();
  const diff = now - ts;
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  if (days > 0) return `${days}d ago`;
  if (hours > 0) return `${hours}h ago`;
  if (minutes > 0) return `${minutes}m ago`;
  return 'just now';
}

/**
 * Build a chat list item element.
 * @param {Object} chat - Chat data with chat_id, title, ts, facet, unread
 * @param {Object} options - Display options
 * @param {boolean} options.showUnread - Show unread indicator if chat.unread
 * @param {boolean} options.showDelete - Show delete button on hover
 * @returns {HTMLElement} The chat item anchor element
 */
function buildChatItem(chat, options = {}) {
  const { showUnread = false, showDelete = false } = options;
  const facet = window.selectedFacet;

  const item = document.createElement('a');
  item.className = 'recent-chat-item';
  item.href = `#${chat.chat_id}`;

  // Unread indicator
  if (showUnread && chat.unread) {
    item.classList.add('unread');
    const dot = document.createElement('span');
    dot.className = 'unread-indicator';
    item.appendChild(dot);
  }

  // Facet color indicator in all-facets mode
  if (facet === null && chat.facet) {
    const facetData = (window.facetsData || []).find(f => f.name === chat.facet);
    if (facetData?.color) {
      item.style.borderLeftColor = facetData.color;
      item.style.borderLeftWidth = '3px';
      item.style.borderLeftStyle = 'solid';
    }
  }

  // Switch to chat's facet on click (hash change will load the chat)
  if (chat.facet && chat.facet !== facet) {
    item.dataset.facet = chat.facet;
    item.addEventListener('click', () => {
      if (window.selectFacet) {
        window.selectFacet(chat.facet);
      }
    });
  }

  // Time
  const time = document.createElement('div');
  time.className = 'recent-chat-time';
  time.textContent = formatRelativeTime(chat.ts);
  item.appendChild(time);

  // Preview
  const preview = document.createElement('div');
  preview.className = 'recent-chat-preview';
  preview.textContent = chat.title || '(no title)';
  item.appendChild(preview);

  // Delete button (optional)
  if (showDelete) {
    const actions = document.createElement('div');
    actions.className = 'chat-item-actions';

    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-chat-btn';
    deleteBtn.innerHTML = 'üóëÔ∏è';
    deleteBtn.title = 'Delete chat';
    deleteBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      showDeleteModal(chat);
    });

    actions.appendChild(deleteBtn);
    item.appendChild(actions);
  }

  return item;
}

// Filter and sort chats by selected facet
function getFilteredChats(facet) {
  let filtered = allChats;
  if (facet !== null) {
    filtered = allChats.filter(c => c.facet === facet);
  }
  // Sort: unread first, then by timestamp
  return [...filtered].sort((a, b) => {
    if (a.unread !== b.unread) return a.unread ? -1 : 1;
    return b.ts - a.ts;
  });
}

// Count unread chats in filtered list
function countUnread(chats) {
  return chats.filter(c => c.unread).length;
}

// Render recent chats panel
function renderRecentChats() {
  const facet = window.selectedFacet;
  const allFiltered = getFilteredChats(facet);
  const chats = allFiltered.slice(0, 5);
  const unreadCount = countUnread(allFiltered);
  const totalCount = allFiltered.length;

  const panel = document.createElement('div');
  panel.className = 'recent-chats-panel';
  panel.id = 'recentChatsPanel';

  // Header with unread count
  const header = document.createElement('div');
  header.className = 'recent-chats-header';

  const title = document.createElement('h3');
  title.textContent = 'Recent Chats';
  header.appendChild(title);

  if (unreadCount > 0) {
    const badge = document.createElement('span');
    badge.className = 'unread-count-badge';
    badge.textContent = `(${unreadCount} unread)`;
    header.appendChild(badge);
  }

  panel.appendChild(header);

  if (chats.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'recent-chats-empty';
    empty.textContent = 'No recent chats';
    panel.appendChild(empty);
  } else {
    const list = document.createElement('div');
    list.className = 'recent-chats-list';

    for (const chat of chats) {
      list.appendChild(buildChatItem(chat, { showUnread: true, showDelete: true }));
    }

    panel.appendChild(list);

    // "See all chats" link if there are more than 5
    if (totalCount > 5) {
      const seeAllLink = document.createElement('a');
      seeAllLink.className = 'see-all-link';
      seeAllLink.href = '#all';
      seeAllLink.textContent = `See all chats (${totalCount}) ‚Üí`;
      panel.appendChild(seeAllLink);
    }
  }

  return panel;
}

// Pagination state for all-chats view
let allChatsDisplayed = 0;
const CHATS_PER_PAGE = 20;

// Render all chats view with pagination
function renderAllChatsView() {
  const facet = window.selectedFacet;
  const allFiltered = getFilteredChats(facet);
  const unreadCount = countUnread(allFiltered);

  // Reset pagination
  allChatsDisplayed = Math.min(CHATS_PER_PAGE, allFiltered.length);

  const panel = document.createElement('div');
  panel.className = 'all-chats-panel';
  panel.id = 'allChatsPanel';

  // Header with unread count
  const header = document.createElement('div');
  header.className = 'all-chats-header';

  const title = document.createElement('h3');
  title.textContent = 'All Chats';
  header.appendChild(title);

  if (unreadCount > 0) {
    const badge = document.createElement('span');
    badge.className = 'unread-count-badge';
    badge.textContent = `(${unreadCount} unread)`;
    header.appendChild(badge);
  }

  panel.appendChild(header);

  if (allFiltered.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'recent-chats-empty';
    empty.textContent = 'No chats';
    panel.appendChild(empty);
  } else {
    const list = document.createElement('div');
    list.className = 'all-chats-list';
    list.id = 'allChatsList';

    for (let i = 0; i < allChatsDisplayed; i++) {
      list.appendChild(buildChatItem(allFiltered[i], { showUnread: true, showDelete: true }));
    }

    panel.appendChild(list);

    // "Load more" button if there are more chats
    if (allFiltered.length > allChatsDisplayed) {
      const loadMoreContainer = document.createElement('div');
      loadMoreContainer.className = 'load-more-container';
      loadMoreContainer.id = 'loadMoreContainer';

      const remaining = allFiltered.length - allChatsDisplayed;
      const loadMoreBtn = document.createElement('button');
      loadMoreBtn.className = 'load-more-button';
      loadMoreBtn.textContent = `Load more (${remaining} remaining)`;
      loadMoreBtn.addEventListener('click', () => loadMoreChats());

      loadMoreContainer.appendChild(loadMoreBtn);
      panel.appendChild(loadMoreContainer);
    }
  }

  return panel;
}

// Load more chats in all-chats view
function loadMoreChats() {
  const facet = window.selectedFacet;
  const allFiltered = getFilteredChats(facet);
  const list = document.getElementById('allChatsList');
  const loadMoreContainer = document.getElementById('loadMoreContainer');

  if (!list) return;

  const startIndex = allChatsDisplayed;
  const endIndex = Math.min(startIndex + CHATS_PER_PAGE, allFiltered.length);

  for (let i = startIndex; i < endIndex; i++) {
    list.appendChild(buildChatItem(allFiltered[i], { showUnread: true, showDelete: true }));
  }

  allChatsDisplayed = endIndex;

  // Update or remove load more button
  if (loadMoreContainer) {
    if (allChatsDisplayed >= allFiltered.length) {
      loadMoreContainer.remove();
    } else {
      const remaining = allFiltered.length - allChatsDisplayed;
      loadMoreContainer.querySelector('.load-more-button').textContent = `Load more (${remaining} remaining)`;
    }
  }
}

// Hide chat list panels (recent or all)
function hideChatListPanels() {
  const recentPanel = document.getElementById('recentChatsPanel');
  if (recentPanel) recentPanel.remove();
  const allPanel = document.getElementById('allChatsPanel');
  if (allPanel) allPanel.remove();
}

// Delete modal state
let chatToDelete = null;

/**
 * Show delete confirmation modal for a chat.
 * @param {Object} chat - Chat object with chat_id and title
 */
function showDeleteModal(chat) {
  chatToDelete = chat;
  const modal = document.getElementById('deleteModal');
  const titleEl = document.getElementById('deleteModalTitle');
  const confirmBtn = document.getElementById('deleteModalConfirm');

  titleEl.textContent = `"${chat.title || '(untitled)'}"?`;

  // Set up confirm button click handler
  confirmBtn.onclick = () => confirmDelete();

  modal.classList.add('visible');
}

/**
 * Hide delete confirmation modal.
 */
function hideDeleteModal() {
  const modal = document.getElementById('deleteModal');
  modal.classList.remove('visible');
  chatToDelete = null;
}

/**
 * Confirm and execute chat deletion.
 */
async function confirmDelete() {
  if (!chatToDelete) return;

  const chatId = chatToDelete.chat_id;

  try {
    const response = await fetch(`/app/chat/api/chat/${chatId}`, {
      method: 'DELETE'
    });

    if (!response.ok) {
      const error = await response.json();
      console.error('Failed to delete chat:', error);
      return;
    }

    // Remove from local cache
    const index = allChats.findIndex(c => c.chat_id === chatId);
    if (index >= 0) {
      allChats.splice(index, 1);
    }

    // Update background service if it exists
    if (window.AppServices?.services?.chat) {
      window.AppServices.services.chat.removeChat(chatId);
    }

    // If currently viewing the deleted chat, navigate away
    if (currentChatId === chatId) {
      navigateTo(null);
    } else {
      // Re-render current view
      if (location.hash === '#all') {
        showAllChatsView();
      } else {
        showRecentChatsView();
      }
    }

  } catch (error) {
    console.error('Failed to delete chat:', error);
  } finally {
    hideDeleteModal();
  }
}

// Close modal when clicking outside
document.addEventListener('click', (e) => {
  const modal = document.getElementById('deleteModal');
  if (e.target === modal) {
    hideDeleteModal();
  }
});

// Close modal with Escape key
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    const modal = document.getElementById('deleteModal');
    if (modal?.classList.contains('visible')) {
      hideDeleteModal();
    }
  }
});

// Fetch all chats from backend
async function fetchRecentChats() {
  try {
    const response = await fetch(chatsUrl);
    if (response.ok) {
      const data = await response.json();
      allChats = data.chats || [];
    }
  } catch (error) {
    console.error('Failed to fetch recent chats:', error);
  }
}

// Listen for facet changes - handle view updates based on current state
window.addEventListener('facet.switch', (e) => {
  const newFacet = e.detail?.facet;

  if (currentChatId) {
    // Currently viewing a chat
    // Stay on it if: switching to all-facets mode, OR chat belongs to new facet
    const chatMatchesFacet = newFacet === null || currentChatFacet === newFacet;
    if (!chatMatchesFacet) {
      // Chat doesn't belong to new facet - navigate to recent view
      navigateTo(null);
    }
    // Otherwise stay on current chat
  } else {
    // On list view - re-render with new facet filter
    // Check which list view we're on by looking at the hash
    if (location.hash === '#all') {
      showAllChatsView();
    } else {
      showRecentChatsView();
    }
  }
});

// Simple error display - adds error message to chat
function showError(message, enableInput = true) {
  const div = document.createElement('div');
  div.className = 'message from-bot';
  div.innerHTML = `<strong style="color:#c62828">Error:</strong> ${message}`;
  messagesDiv.appendChild(div);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;

  // Re-enable input so user can retry (unless caller wants to handle it)
  if (enableInput && input) {
    input.disabled = false;
    input.placeholder = 'Send a message...';
    input.focus();
  }
}

// Wait for app bar to load
let form, input, providerToggle, currentProvider;

// Provider configuration - module scope for use by setProvider and click handler
const providers = {
  anthropic: { next: 'google', label: 'Claude' },
  google: { next: 'openai', label: 'Gemini' },
  openai: { next: 'anthropic', label: 'GPT' }
};

/**
 * Update provider toggle to a specific provider.
 * @param {string} provider - Provider key (anthropic, google, openai)
 */
function setProvider(provider) {
  if (!provider || !providers[provider] || !providerToggle) return;
  currentProvider = provider;
  providerToggle.dataset.provider = provider;
  providerToggle.textContent = providers[provider].label;
}

function initAppBarControls() {
  form = document.getElementById('chatInputForm');
  input = document.getElementById('chatMessageInput');
  providerToggle = document.getElementById('chatProviderToggle');

  if (!form || !input || !providerToggle) {
    console.error('Chat controls not found');
    return;
  }

  currentProvider = providerToggle.dataset.provider;

  providerToggle.addEventListener('click', () => {
    currentProvider = providers[currentProvider].next;
    providerToggle.dataset.provider = currentProvider;
    providerToggle.textContent = providers[currentProvider].label;
  });

  setupFormHandlers();
  input.focus();
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    initAppBarControls();
  });
} else {
  initAppBarControls();
}

// Deduplication using agent_id:ts as key
const processedEventIds = new Set();
const MAX_EVENT_IDS = 500;

function shouldSkipEvent(event) {
  if (!event || !event.agent_id || !event.ts) {
    return false;
  }
  const eventKey = `${event.agent_id}:${event.ts}`;
  if (processedEventIds.has(eventKey)) {
    return true;
  }
  processedEventIds.add(eventKey);

  // Prevent memory leak - clear old entries if too many
  if (processedEventIds.size > MAX_EVENT_IDS) {
    const entries = Array.from(processedEventIds);
    entries.slice(0, 100).forEach(e => processedEventIds.delete(e));
  }
  return false;
}

function resetEventTracking() {
  processedEventIds.clear();
}

// Single source of truth for event rendering
function enrichEvent(event) {
  const enriched = {...event};

  // Render finish events
  if (event.event === 'finish') {
    const resultText = event.result || '';
    enriched.content = marked.parse(resultText, {
      breaks: true,  // nl2br equivalent
      gfm: true      // GitHub Flavored Markdown
    });
    enriched.rawMarkdown = resultText;
    enriched.html = enriched.content;
  }

  // Render error events
  else if (event.event === 'error') {
    const errorMsg = event.error || 'Unknown error';
    const trace = event.trace || '';
    const prefix = '‚ùå';

    const errorText = trace
      ? `${prefix} **Error**: ${errorMsg}\n\n\`\`\`\n${trace}\n\`\`\``
      : `${prefix} **Error**: ${errorMsg}`;
    enriched.html = marked.parse(errorText, {breaks: true, gfm: true});
    enriched.rawMarkdown = errorText;
    enriched.result = errorText;
  }

  return enriched;
}

// State management
let currentChatId = null;   // The chat being viewed (stable across continuations)
let currentChatFacet = null; // Facet of the current chat (for facet switch handling)
let currentAgentIds = [];   // Agent IDs in the current chat (for WebSocket filtering)
let isComplete = false;
let canContinue = false;    // Whether the chat can be continued (false if ended in error)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ROUTER - Hash-based SPA navigation
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Initialize hash-based router.
 * Call once after allChats are fetched.
 */
function initRouter() {
  window.addEventListener('hashchange', handleRouteChange);
  handleRouteChange(); // Handle initial route
}

/**
 * Parse hash and dispatch to appropriate view.
 * Routes: '' or '#' -> recent, '#all' -> all chats, '#<id>' -> chat view
 */
function handleRouteChange() {
  const hash = location.hash.slice(1);

  if (hash === 'all') {
    // All chats view
    if (currentChatId !== null || !document.getElementById('allChatsPanel')) {
      showAllChatsView();
    }
  } else if (/^\d+$/.test(hash)) {
    // Chat view
    if (currentChatId !== hash) {
      loadChat(hash);
    }
  } else {
    // Recent chats view (empty hash or unknown)
    if (currentChatId !== null || !document.getElementById('recentChatsPanel')) {
      showRecentChatsView();
    }
  }
}

/**
 * Navigate programmatically. Updates hash which triggers handleRouteChange.
 * @param {string|null} chatId - Chat to open, or null for recent view
 */
function navigateTo(chatId) {
  location.hash = chatId || '';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VIEW FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Clear message area and reset UI state.
 */
function clearMessages() {
  messagesDiv.innerHTML = '';
  messagesDiv.appendChild(activityIndicator);
  forceHideActivityIndicator();
  Object.keys(toolPlacards).forEach(key => delete toolPlacards[key]);
  previousAgent = null;
  resetEventTracking();
  hideBackButton();
}

/**
 * Show back button for navigating out of chat view.
 */
function showBackButton() {
  if (document.getElementById('backButton')) return;

  const backBtn = document.createElement('a');
  backBtn.id = 'backButton';
  backBtn.className = 'back-button';
  backBtn.href = '#';
  backBtn.innerHTML = '‚Üê Chats';

  // Insert at the beginning of messages div
  messagesDiv.insertBefore(backBtn, messagesDiv.firstChild);
}

/**
 * Hide back button.
 */
function hideBackButton() {
  const backBtn = document.getElementById('backButton');
  if (backBtn) backBtn.remove();
}

/**
 * Load and display a chat conversation.
 * @param {string} chatId - The chat ID to load
 */
async function loadChat(chatId) {
  // Update state
  currentChatId = chatId;
  currentAgentIds = [];
  isComplete = false;
  canContinue = false;
  resetEventTracking();
  hideRetryButton();

  // Notify background service
  if (window.AppServices?.services?.chat) {
    window.AppServices.services.chat.setActiveAgent(chatId);
  }

  // Prepare UI - always clear and load full conversation
  clearMessages();
  showBackButton();
  showActivityIndicator();

  // Fetch all events from server
  try {
    const response = await fetch(`/app/chat/api/chat/${chatId}/events`);
    if (!response.ok) {
      showError(`Failed to load chat: ${response.statusText}`);
      return;
    }

    const data = await response.json();
    const events = data.events || [];
    currentAgentIds = data.agent_ids || [chatId];
    isComplete = data.is_complete || false;
    canContinue = data.can_continue || false;
    currentChatFacet = data.chat?.facet || null;

    // Lock provider toggle to chat's provider
    const chatProvider = data.chat?.provider;
    if (chatProvider) {
      setProvider(chatProvider);
    }

    // Process and render all events
    for (const event of events) {
      const enriched = enrichEvent(event);
      if (!shouldSkipEvent(enriched)) {
        processEvent(enriched);
      }
    }

    // Update UI based on completion state
    if (isComplete) {
      forceHideActivityIndicator();
      if (canContinue) {
        enableContinuation(chatId);
      } else if (data.end_state === 'error') {
        showRetryButton(chatId);
      }
    }

    // Mark as read and update badges
    await markChatRead(chatId);

    // Scroll to bottom
    messagesDiv.scrollTop = messagesDiv.scrollHeight;

  } catch (error) {
    showError(`Failed to load chat: ${error.message}`);
  }
}

/**
 * Enable continuation input after chat completes.
 * @param {string} chatId - The chat ID to continue
 */
function enableContinuation(chatId) {
  hideRetryButton();
  if (input) {
    input.disabled = false;
    input.placeholder = 'Continue conversation...';
    input.dataset.continueChat = chatId;
  }
}

/**
 * Show retry button after an error. Adds button inline after the last message.
 * @param {string} chatId - The chat ID to retry
 */
function showRetryButton(chatId) {
  // Remove any existing retry button
  hideRetryButton();

  // Create retry button container
  const retryDiv = document.createElement('div');
  retryDiv.id = 'retry-container';
  retryDiv.className = 'retry-container';

  retryDiv.innerHTML = `
    <button class="retry-button" onclick="retryChat('${chatId}')">
      <span class="retry-icon">‚Üª</span> Retry
    </button>
  `;
  messagesDiv.appendChild(retryDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;

  // Keep input disabled
  if (input) {
    input.disabled = true;
    input.placeholder = 'Retry failed message...';
    delete input.dataset.continueChat;
  }
}

/**
 * Hide and remove the retry button.
 */
function hideRetryButton() {
  const existing = document.getElementById('retry-container');
  if (existing) {
    existing.remove();
  }
}

/**
 * Retry the last failed message in the current chat.
 * @param {string} chatId - The chat ID to retry
 */
async function retryChat(chatId) {
  hideRetryButton();
  showActivityIndicator();
  canContinue = false;

  try {
    const response = await fetch(`/app/chat/api/chat/${chatId}/retry`, {
      method: 'POST'
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Retry failed');
    }

    const data = await response.json();
    // Add new agent to list for WebSocket event filtering
    currentAgentIds.push(data.agent_id);
    isComplete = false;
    // Events will arrive via WebSocket

  } catch (error) {
    forceHideActivityIndicator();
    showError(`Retry failed: ${error.message}`, false);
    // Re-show retry button on failure (this will disable input)
    showRetryButton(chatId);
  }
}

/**
 * Save CLI session ID to chat metadata (called once after first agent completes).
 * @param {string} chatId - The chat ID
 * @param {string} sessionId - The CLI session ID from the provider
 */
async function captureSessionId(chatId, sessionId) {
  try {
    await fetch(`/app/chat/api/chat/${chatId}/session`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionId })
    });
  } catch (err) {
    console.error('Failed to capture session ID:', err);
  }
}

/**
 * Mark chat as read and update all badge/submenu state.
 * @param {string} chatId - The chat to mark read
 */
async function markChatRead(chatId) {
  try {
    // Server-side mark read
    await fetch(`/app/chat/api/chat/${chatId}/read`, { method: 'POST' });

    // Update local cache and get facet for badge update
    const chat = allChats.find(c => c.chat_id === chatId);
    if (chat && chat.unread) {
      const facet = chat.facet;
      chat.unread = false;

      // Update badges via background service
      if (window.AppServices?.services?.chat) {
        window.AppServices.services.chat.markRead(chatId, facet);
      }
    }
  } catch (err) {
    console.error('Failed to mark as read:', err);
  }
}

/**
 * Reset to list view state (no active chat).
 */
function resetToListView() {
  currentChatId = null;
  currentChatFacet = null;
  currentAgentIds = [];
  isComplete = false;
  canContinue = false;
  clearMessages();
  hideRetryButton();

  if (input) {
    delete input.dataset.continueChat;
    input.disabled = false;
    input.placeholder = 'Send a message...';
  }

  if (window.AppServices?.services?.chat) {
    window.AppServices.services.chat.setActiveAgent(null);
  }
}

/**
 * Show recent chats view with proper state reset.
 */
function showRecentChatsView() {
  resetToListView();
  hideChatListPanels();
  const panel = renderRecentChats();
  messagesDiv.appendChild(panel);
}

/**
 * Show all chats view with proper state reset.
 */
function showAllChatsView() {
  resetToListView();
  hideChatListPanels();
  const panel = renderAllChatsView();
  messagesDiv.appendChild(panel);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Create persistent activity indicator
const activityIndicator = document.createElement('div');
activityIndicator.className = 'activity-indicator';
activityIndicator.id = 'activityIndicator';
activityIndicator.innerHTML = '<span></span><span></span><span></span>';

let chatControlsInitialized = false;

function showActivityIndicator() {
  if (!document.getElementById('activityIndicator')) {
    messagesDiv.appendChild(activityIndicator);
  }
  activityIndicator.classList.add('active');
  requestAnimationFrame(() => {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  });
}

function forceHideActivityIndicator() {
  activityIndicator.classList.remove('active');
}

function ensureActivityIndicatorAtBottom() {
  // Ensure activity indicator is always the last element
  if (!activityIndicator.parentNode) {
    messagesDiv.appendChild(activityIndicator);
  } else if (activityIndicator.parentNode === messagesDiv && messagesDiv.lastElementChild !== activityIndicator) {
    messagesDiv.appendChild(activityIndicator);
  }
}

function addEventCard(text, url, event, params){
  const div=document.createElement('div');
  div.className='event-card';
  const a=document.createElement('a');
  a.href=url;
  a.textContent=text;
  div.appendChild(a);

  // Add parameter pills if provided
  const pills = createParamPills(params);
  if (pills) div.appendChild(pills);

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Track tool calls by ID to update them when complete
// Limit to prevent memory leaks
const toolPlacards = {};
const MAX_TOOL_PLACARDS = 100;

// Track agent switches - only show when switching between agents
let previousAgent = null;

// Clean up old tool placards when limit reached
function cleanupOldPlacards() {
  const keys = Object.keys(toolPlacards);
  if (keys.length > MAX_TOOL_PLACARDS) {
    // Remove oldest entries (first half)
    const toRemove = keys.slice(0, Math.floor(keys.length / 2));
    toRemove.forEach(key => delete toolPlacards[key]);
  }
}

// Format tool args into display-friendly params (query, facet, day, agent, etc.)
function formatToolParams(args) {
  if (!args) return [];
  const params = [];

  if (args.query) {
    params.push({label: 'query', value: args.query});
  }
  if (args.facet) {
    params.push({label: 'facet', value: args.facet});
  }
  if (args.day) {
    params.push({label: 'day', value: formatDay(args.day)});
  }
  if (args.day_from) {
    params.push({label: 'from', value: formatDay(args.day_from)});
  }
  if (args.day_to) {
    params.push({label: 'to', value: formatDay(args.day_to)});
  }
  if (args.agent) {
    params.push({label: 'agent', value: args.agent});
  }

  return params;
}

// Create a span containing parameter pills from params array
function createParamPills(params) {
  if (!params || params.length === 0) return null;
  const paramsSpan = document.createElement('span');
  paramsSpan.className = 'tool-params';
  params.forEach(p => {
    const pill = document.createElement('span');
    pill.className = 'tool-param';
    const label = document.createElement('span');
    label.className = 'param-label';
    label.textContent = p.label + ': ';
    pill.appendChild(label);
    pill.appendChild(document.createTextNode(p.value));
    paramsSpan.appendChild(pill);
  });
  return paramsSpan;
}

function addToolPlacard(toolName, event, callId){
  const div=document.createElement('div');
  div.className='tool-placard';

  const nameSpan=document.createElement('span');
  nameSpan.className='tool-name';
  nameSpan.textContent='üîß ' + toolName;
  div.appendChild(nameSpan);

  // Add parameter pills if args present
  const args = event && event.args;
  const pills = createParamPills(formatToolParams(args));
  if (pills) div.appendChild(pills);

  const statusSpan=document.createElement('span');
  statusSpan.className='tool-status';
  statusSpan.textContent='(running...)';
  div.appendChild(statusSpan);

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;

  // Store reference to update later
  if(callId){
    toolPlacards[callId] = {div, statusSpan};
    cleanupOldPlacards();  // Clean up if too many
  }
  return div;
}

function completeToolPlacard(callId, result){
  if(toolPlacards[callId]){
    const {div, statusSpan} = toolPlacards[callId];
    div.classList.add('completed');
    statusSpan.textContent = '‚úì';

    // Update title attribute with result
    if(result && div.title){
      const resultText = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
      div.title += '\n\n=== Result ===\n' + resultText;
    }

    delete toolPlacards[callId];
  }
}

function addAgentUpdate(agentName){
  // Only show agent switch if we're actually switching from one agent to another
  if(previousAgent && previousAgent !== agentName){
    const div=document.createElement('div');
    div.className='agent-update';
    div.textContent=`‚Üí Switched from ${previousAgent} to ${agentName} agent`;
    messagesDiv.insertBefore(div, activityIndicator);
    ensureActivityIndicatorAtBottom();
    messagesDiv.scrollTop=messagesDiv.scrollHeight;
  }
  previousAgent = agentName;
}

function addThinkingCard(summary, model){
  const div=document.createElement('div');
  div.className='thinking-card';

  const label=document.createElement('div');
  label.className='thinking-label';
  label.textContent=`üí≠ Thinking (${model})`;
  div.appendChild(label);

  const content=document.createElement('div');
  content.className='thinking-content';
  content.textContent=summary;
  div.appendChild(content);

  div.addEventListener('click', () => {
    div.classList.toggle('expanded');
  });

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Store raw markdown for each bot message
const messageMarkdown = new WeakMap();

function addMessage(text, cls, isHtml=false, rawMarkdown=null){
  const div=document.createElement('div');
  div.className='message '+cls;

  // Use HTML for bot messages if provided, otherwise plain text
  if(isHtml && cls === 'from-bot'){
    div.innerHTML = text;
    if(rawMarkdown) {
      messageMarkdown.set(div, rawMarkdown);
    }
  } else {
    div.textContent = text;
    if(cls === 'from-user') {
      messageMarkdown.set(div, text);
    }
  }

  // Create action buttons container (integrated into message)
  const actions = document.createElement('div');
  actions.className = 'message-actions';

  if(cls === 'from-user'){
    // Recycle button
    const recycleBtn = document.createElement('button');
    recycleBtn.innerHTML = '‚ôªÔ∏è';
    recycleBtn.title = 'Reuse';
    recycleBtn.onclick = (e) => {
      e.stopPropagation();
      reuseMessage(div);
    };
    actions.appendChild(recycleBtn);
  }

  // Copy button for all messages
  const copyBtn = document.createElement('button');
  copyBtn.innerHTML = 'üìã';
  copyBtn.title = 'Copy';
  copyBtn.onclick = (e) => {
    e.stopPropagation();
    copyMessageMarkdown(div, copyBtn);
  };
  actions.appendChild(copyBtn);

  div.appendChild(actions);
  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

function copyMessageMarkdown(messageDiv, copyBtn) {
  const markdown = messageMarkdown.get(messageDiv);
  if(!markdown) {
    // Nothing to copy - brief feedback
    copyBtn.innerHTML = '‚àí';
    setTimeout(() => { copyBtn.innerHTML = 'üìã'; }, 1000);
    return;
  }

  navigator.clipboard.writeText(markdown).then(() => {
    copyBtn.innerHTML = '‚úì';
    copyBtn.classList.add('copied');
    setTimeout(() => {
      copyBtn.innerHTML = 'üìã';
      copyBtn.classList.remove('copied');
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy:', err);
    copyBtn.innerHTML = '‚ùå';
    setTimeout(() => { copyBtn.innerHTML = 'üìã'; }, 2000);
  });
}

function reuseMessage(messageDiv) {
  const text = messageMarkdown.get(messageDiv);
  if(!text) return;

  // Reset to list view state (clears messages, state, enables input)
  resetToListView();

  // Clear URL hash to match state
  location.hash = '';

  // Pre-fill input with the message text
  if(input) {
    input.value = text;
    input.focus();

    // Auto-resize the textarea
    input.style.height = 'auto';
    input.style.height = input.scrollHeight + 'px';
  }
}

function setupFormHandlers() {
  // Enter key to submit
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      form.requestSubmit();
    }
  });

  // Form submission
  form.onsubmit = async e => {
    e.preventDefault();
    const text = input.value.trim();
    if (!text) return;

    // Hide chat list panels when sending a message
    hideChatListPanels();

    input.value = '';
    input.disabled = true;

    // Check if continuing existing chat
    const continueChatId = input.dataset.continueChat;
    delete input.dataset.continueChat;

    const payload = { message: text, provider: currentProvider };
    if (continueChatId) {
      payload['continue_chat'] = continueChatId;
    }

    const r = await fetch(sendUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

    if (r.ok) {
      const d = await r.json();
      if (continueChatId) {
        // Continuation: add new agent to agent list and keep listening
        // Don't reload - that clears UI and causes race conditions with WebSocket events
        currentAgentIds.push(d.agent_id);
        isComplete = false;
        canContinue = false;
        showActivityIndicator();
      } else {
        // New chat: set expected facet before navigation to avoid race conditions
        // (loadChat will confirm this from server, but this protects against facet.switch)
        currentChatFacet = window.selectedFacet;
        navigateTo(d.chat_id);
      }
    } else {
      input.disabled = false;
      let err = 'Error';
      try { const d = await r.json(); err = d.error || err; } catch { };
      if (window.showError) showError(err);
    }
  };
}

// Event handler for both live and historical events
function processEvent(event) {
  switch(event.event) {
    case 'start':
      addMessage(event.prompt || '', 'from-user');
      break;

    case 'tool_start':
      handleToolStart(event);
      break;

    case 'tool_end':
      completeToolPlacard(event.call_id, event.result);
      break;

    case 'thinking':
      addThinkingCard(event.summary, event.model || 'unknown');
      break;

    case 'agent_updated':
      addAgentUpdate(event.agent || 'unknown');
      break;

    case 'finish':
      // Add final message
      if(event.html){
        addMessage(event.html, 'from-bot', true, event.rawMarkdown);
      }

      isComplete = true;
      forceHideActivityIndicator();

      // Capture session_id from the CLI provider and save to chat
      if(currentChatId && event.cli_session_id){
        captureSessionId(currentChatId, event.cli_session_id);
        canContinue = true;
        enableContinuation(currentChatId);
      }
      break;

    case 'error':
      // Display error message
      if(event.html){
        addMessage(event.html, 'from-bot', true, event.rawMarkdown);
      }

      isComplete = true;
      canContinue = false;
      forceHideActivityIndicator();

      // Show retry button instead of enabling input
      if(currentChatId){
        showRetryButton(currentChatId);
      }
      break;
  }
}

// Handle tool_start events
function handleToolStart(event) {
  const {tool, args, call_id} = event;

  // Handle search tools with special event cards
  if(args && args.query) {
    const url = searchBase + '#q=' + encodeURIComponent(args.query);
    const searchText = `Searching for "${args.query}"`;
    // Get filter params (excluding query since it's already in the text)
    const params = formatToolParams(args).filter(p => p.label !== 'query');
    addEventCard(searchText, url, event, params);
    return;
  }

  // Default: show tool placard
  addToolPlacard(tool, event, call_id);
}


// Initialize WebSocket listener and controls
(function initChatControls(){
  if(chatControlsInitialized) return;
  chatControlsInitialized = true;

  // Global WebSocket listener for cortex events
  appEvents.listen('cortex', e => {
    // Only process events for agents in our current chat
    if (!currentChatId || !currentAgentIds.includes(e.agent_id)) {
      return;
    }

    // Stop listening once complete
    if (isComplete) {
      return;
    }

    // Deduplicate and enrich
    if (shouldSkipEvent(e)) {
      return;
    }

    const enriched = enrichEvent(e);
    processEvent(enriched);
  });
})();

// Initialize: fetch chats then start router
fetchRecentChats().then(() => {
  initRouter();
});
</script>
