<style>
#messages {
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  overflow-x: hidden;
}

/* Base message styles */
.message {
  margin-bottom: 0.75em;
  padding: 0.75em 1em;
  border-radius: 12px;
  max-width: 75%;
  box-shadow: 0 1px 3px rgba(0,0,0,0.08);
  animation: fadeInUp 0.3s ease-out;
  position: relative;
}

/* User messages - use facet theme colors */
.from-user {
  background: var(--facet-color, #667eea);
  color: white;
  align-self: flex-end;
  margin-left: 20%;
}

/* Bot messages */
.from-bot {
  background: #fff;
  border: 1px solid #e0e0e0;
  align-self: flex-start;
  margin-right: 20%;
}

/* Action buttons - integrated into message, hover-only, small */
.message-actions {
  position: absolute;
  bottom: 0.4em;
  display: flex;
  gap: 0.25em;
  opacity: 0;
  transition: opacity 0.15s;
}
.from-user .message-actions { left: 0.5em; }
.from-bot .message-actions { right: 0.5em; }
.message:hover .message-actions { opacity: 1; }

.message-actions button {
  background: transparent;
  border: none;
  padding: 0.2em;
  cursor: pointer;
  font-size: 0.7em;
  opacity: 0.5;
  transition: opacity 0.15s;
  line-height: 1;
}
.message-actions button:hover { opacity: 1; }
.from-user .message-actions button { color: rgba(255,255,255,0.9); }
.from-bot .message-actions button { color: #666; }
.message-actions button.copied { opacity: 1; color: #4caf50; }

@keyframes fadeInUp {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Event cards, tool placards, etc */
#messages .event-card {
  background: #fff4e5;
  border: 1px solid #f0ad4e;
  border-radius: 6px;
  padding: 0.5em 0.75em;
  margin-bottom: 0.75em;
  font-size: 0.85em;
  max-width: 80%;
  align-self: flex-start;
  cursor: help;
  transition: all 0.2s;
}
#messages .event-card:hover {
  background: #fff0d4;
  border-color: #e09e3a;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
#messages .event-card a { text-decoration: none; color: #007bff; }
#messages .event-card a:hover { text-decoration: underline; }

/* Shared pill styles for tool params */
#messages .tool-params { margin-left: 0.5em; display: inline; }
#messages .tool-param {
  display: inline-block;
  background: rgba(0,0,0,0.08);
  border-radius: 3px;
  padding: 0.1em 0.4em;
  margin-left: 0.3em;
  font-size: 0.9em;
}
/* Event card pill colors */
#messages .event-card .tool-param { color: #805500; }
#messages .event-card .tool-param .param-label { color: #a06000; }
/* Tool placard pill colors */
#messages .tool-placard .tool-param { color: #555; }
#messages .tool-placard .tool-param .param-label { color: #888; }
#messages .tool-placard.completed .tool-param { background: rgba(0,0,0,0.06); }

#messages .tool-placard {
  background: #e3f2fd;
  border: 1px solid #2196f3;
  border-radius: 6px;
  padding: 0.4em 0.6em;
  margin-bottom: 0.5em;
  font-size: 0.8em;
  max-width: 60%;
  align-self: flex-start;
  cursor: help;
  transition: all 0.2s;
}
#messages .tool-placard:hover {
  background: #d1e8fc;
  border-color: #1976d2;
  transform: translateY(-1px);
}
#messages .tool-placard .tool-name { font-weight: bold; color: #1976d2; }
#messages .tool-placard .tool-status { font-size: 0.9em; color: #666; margin-left: 0.5em; }
#messages .tool-placard.completed { background: #e8f5e9; border-color: #4caf50; }
#messages .tool-placard.completed:hover { background: #d4f0d7; }
#messages .tool-placard.completed .tool-name { color: #2e7d32; }

#messages .agent-update {
  background: #fff3e0;
  border: 1px solid #ff9800;
  border-radius: 6px;
  padding: 0.4em 0.6em;
  margin-bottom: 0.5em;
  font-size: 0.8em;
  max-width: 60%;
  align-self: flex-start;
  color: #e65100;
  font-style: italic;
  transition: all 0.2s;
}
#messages .agent-update:hover { background: #ffe8cc; }

#messages .thinking-card {
  background: #f8f4ff;
  border: 1px solid #9c27b0;
  border-radius: 6px;
  padding: 0.5em 0.75em;
  margin-bottom: 0.75em;
  font-size: 0.85em;
  max-width: 80%;
  align-self: flex-start;
  cursor: pointer;
  transition: all 0.2s;
}
#messages .thinking-card:hover {
  background: #f3e5f5;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}
#messages .thinking-card .thinking-label { font-weight: bold; color: #7b1fa2; margin-bottom: 0.25em; }
#messages .thinking-card .thinking-content { color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#messages .thinking-card.expanded .thinking-content { white-space: pre-wrap; overflow: visible; text-overflow: clip; }

/* Message content typography */
.message h1, .message h2, .message h3, .message h4, .message h5, .message h6 { margin: 0.5em 0 0.3em 0; }
.message p { margin: 0.3em 0; }
.message ul, .message ol { margin: 0.3em 0; padding-left: 1.5em; }
.message code { background: rgba(0,0,0,0.1); padding: 0.1em 0.3em; border-radius: 3px; font-size: 0.9em; }
.from-user code { background: rgba(255,255,255,0.2); }
.message pre { background: rgba(0,0,0,0.1); padding: 0.5em; border-radius: 4px; overflow-x: auto; margin: 0.5em 0; }
.from-user pre { background: rgba(255,255,255,0.15); }
.message pre code { background: none; padding: 0; }
.message blockquote { margin: 0.5em 0; padding-left: 1em; border-left: 3px solid rgba(0,0,0,0.2); }
.from-user blockquote { border-left-color: rgba(255,255,255,0.4); }

/* Activity indicator - uses facet color */
@keyframes typingBounce {
  0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
  40% { transform: scale(1); opacity: 1; }
}
.activity-indicator {
  align-self: flex-start;
  padding: 0.5em 0.75em;
  background: var(--facet-bg, #f0f0f0);
  border-radius: 12px;
  margin-bottom: 0.5em;
  display: none;
}
.activity-indicator.active {
  display: flex;
  align-items: center;
  gap: 4px;
  animation: fadeInUp 0.3s ease-out;
}
.activity-indicator span {
  width: 6px;
  height: 6px;
  background: var(--facet-color, #999);
  border-radius: 50%;
  animation: typingBounce 1.4s infinite ease-in-out;
}
.activity-indicator span:nth-child(1) { animation-delay: -0.32s; }
.activity-indicator span:nth-child(2) { animation-delay: -0.16s; }

/* Retry button for failed chats */
.retry-container {
  align-self: flex-start;
  margin-bottom: 0.75em;
  animation: fadeInUp 0.3s ease-out;
}
.retry-button {
  background: #fff3e0;
  border: 1px solid #ff9800;
  border-radius: 6px;
  padding: 0.5em 1em;
  font-size: 0.9em;
  cursor: pointer;
  color: #e65100;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 0.4em;
}
.retry-button:hover {
  background: #ffe0b2;
  border-color: #f57c00;
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
.retry-button:active {
  transform: translateY(0);
  box-shadow: none;
}
.retry-icon {
  font-size: 1.1em;
}

/* Recent chats panel */
.recent-chats-panel {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 2em;
  min-height: 200px;
}

.recent-chats-panel h3 {
  margin: 0 0 1em 0;
  color: #666;
  font-weight: normal;
  font-size: 0.9em;
}

.recent-chats-list {
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  width: 100%;
  max-width: 500px;
}

a.recent-chat-item {
  display: flex;
  flex-direction: column;
  padding: 0.75em 1em;
  background: #f8f9fa;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.15s;
  text-decoration: none;
  color: inherit;
}

.recent-chat-item:hover {
  background: #fff;
  border-color: var(--facet-color, #667eea);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.recent-chat-time {
  font-size: 0.75em;
  color: #888;
  margin-bottom: 0.25em;
}

.recent-chat-preview {
  font-size: 0.85em;
  color: #333;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.recent-chats-empty {
  color: #888;
  font-size: 0.85em;
  font-style: italic;
}

/* Unread styling */
.recent-chat-item.unread {
  background: #e3f2fd;
  border-left: 3px solid #2196f3;
  font-weight: 600;
}

.unread-indicator {
  width: 8px;
  height: 8px;
  background: #2196f3;
  border-radius: 50%;
  display: inline-block;
  margin-right: 8px;
}
</style>

<div class="workspace-content">
  <div id="messages"></div>
</div>

<script src="{{ vendor_lib('marked') }}"></script>
<script>
const sendUrl = '{{ url_for('app:chat.send_message') }}';
const chatsUrl = '{{ url_for('app:chat.list_chats') }}';
const messagesDiv = document.getElementById('messages');
const searchBase = '{{ url_for('app:search.index') }}';

// Recent chats data
let allChats = [];

// Format day from YYYYMMDD to M/D
function formatDay(dayStr) {
  if (!dayStr || dayStr.length !== 8) return dayStr;
  const month = parseInt(dayStr.substring(4, 6), 10);
  const day = parseInt(dayStr.substring(6, 8), 10);
  return `${month}/${day}`;
}

// Format timestamp as relative time
function formatRelativeTime(ts) {
  const now = Date.now();
  const diff = now - ts;
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  if (days > 0) return `${days}d ago`;
  if (hours > 0) return `${hours}h ago`;
  if (minutes > 0) return `${minutes}m ago`;
  return 'just now';
}

/**
 * Build a chat list item element.
 * @param {Object} chat - Chat data with chat_id, title, ts, facet, unread
 * @param {Object} options - Display options
 * @param {boolean} options.showUnread - Show unread indicator if chat.unread
 * @param {boolean} options.showStar - Show star indicator in preview
 * @returns {HTMLElement} The chat item anchor element
 */
function buildChatItem(chat, options = {}) {
  const { showUnread = false, showStar = false } = options;
  const facet = window.selectedFacet;

  const item = document.createElement('a');
  item.className = 'recent-chat-item';
  item.href = `#${chat.chat_id}`;

  // Unread indicator
  if (showUnread && chat.unread) {
    item.classList.add('unread');
    const dot = document.createElement('span');
    dot.className = 'unread-indicator';
    item.appendChild(dot);
  }

  // Facet color indicator in all-facets mode
  if (facet === null && chat.facet) {
    const facetData = (window.facetsData || []).find(f => f.name === chat.facet);
    if (facetData?.color) {
      item.style.borderLeftColor = facetData.color;
      item.style.borderLeftWidth = '3px';
      item.style.borderLeftStyle = 'solid';
    }
  }

  // Switch to chat's facet on click (hash change will load the chat)
  if (chat.facet && chat.facet !== facet) {
    item.dataset.facet = chat.facet;
    item.addEventListener('click', () => {
      if (window.selectFacet) {
        window.selectFacet(chat.facet);
      }
    });
  }

  // Time
  const time = document.createElement('div');
  time.className = 'recent-chat-time';
  time.textContent = formatRelativeTime(chat.ts);
  item.appendChild(time);

  // Preview with optional star
  const preview = document.createElement('div');
  preview.className = 'recent-chat-preview';
  if (showStar) {
    const star = document.createElement('span');
    star.textContent = '‚òÖ ';
    star.style.color = '#ffc107';
    preview.appendChild(star);
    preview.appendChild(document.createTextNode(chat.title || '(no title)'));
  } else {
    preview.textContent = chat.title || '(no title)';
  }
  item.appendChild(preview);

  return item;
}

// Filter chats by selected facet
function getFilteredChats(facet) {
  let filtered = allChats;
  if (facet !== null) {
    filtered = allChats.filter(c => c.facet === facet);
  }
  // Sort: unread first, then by timestamp
  return filtered
    .sort((a, b) => {
      if (a.unread !== b.unread) return a.unread ? -1 : 1;
      return b.ts - a.ts;
    })
    .slice(0, 5);
}

// Render recent chats panel
function renderRecentChats() {
  const facet = window.selectedFacet;
  const chats = getFilteredChats(facet);

  const panel = document.createElement('div');
  panel.className = 'recent-chats-panel';
  panel.id = 'recentChatsPanel';

  const title = document.createElement('h3');
  title.textContent = 'Recent Chats';
  panel.appendChild(title);

  if (chats.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'recent-chats-empty';
    empty.textContent = 'No recent chats';
    panel.appendChild(empty);
  } else {
    const list = document.createElement('div');
    list.className = 'recent-chats-list';

    for (const chat of chats) {
      list.appendChild(buildChatItem(chat, { showUnread: true }));
    }

    panel.appendChild(list);
  }

  return panel;
}

// Hide recent chats panel
function hideRecentChats() {
  const panel = document.getElementById('recentChatsPanel');
  if (panel) panel.remove();
}

// Fetch all chats from backend
async function fetchRecentChats() {
  try {
    const response = await fetch(chatsUrl);
    if (response.ok) {
      const data = await response.json();
      allChats = data.chats || [];
    }
  } catch (error) {
    console.error('Failed to fetch recent chats:', error);
  }
}

// Listen for facet changes - handle view updates based on current state
window.addEventListener('facet.switch', (e) => {
  const newFacet = e.detail?.facet;

  if (currentChatId) {
    // Currently viewing a chat
    // Stay on it if: switching to all-facets mode, OR chat belongs to new facet
    const chatMatchesFacet = newFacet === null || currentChatFacet === newFacet;
    if (!chatMatchesFacet) {
      // Chat doesn't belong to new facet - navigate to recent view
      navigateTo(null);
    }
    // Otherwise stay on current chat
  } else {
    // On recent view - re-render with new facet filter
    showRecentChatsView();
  }
});

// Simple error display - adds error message to chat
function showError(message, enableInput = true) {
  const div = document.createElement('div');
  div.className = 'message from-bot';
  div.innerHTML = `<strong style="color:#c62828">Error:</strong> ${message}`;
  messagesDiv.appendChild(div);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;

  // Re-enable input so user can retry (unless caller wants to handle it)
  if (enableInput && input) {
    input.disabled = false;
    input.placeholder = 'Send a message...';
    input.focus();
  }
}

// Wait for app bar to load
let form, input, providerToggle, currentProvider;

// Provider configuration - module scope for use by setProvider and click handler
const providers = {
  anthropic: { next: 'google', label: 'Claude' },
  google: { next: 'openai', label: 'Gemini' },
  openai: { next: 'anthropic', label: 'GPT' }
};

/**
 * Update provider toggle to a specific provider.
 * @param {string} provider - Provider key (anthropic, google, openai)
 */
function setProvider(provider) {
  if (!provider || !providers[provider] || !providerToggle) return;
  currentProvider = provider;
  providerToggle.dataset.provider = provider;
  providerToggle.textContent = providers[provider].label;
}

function initAppBarControls() {
  form = document.getElementById('chatInputForm');
  input = document.getElementById('chatMessageInput');
  providerToggle = document.getElementById('chatProviderToggle');

  if (!form || !input || !providerToggle) {
    console.error('Chat controls not found');
    return;
  }

  currentProvider = providerToggle.dataset.provider;

  providerToggle.addEventListener('click', () => {
    currentProvider = providers[currentProvider].next;
    providerToggle.dataset.provider = currentProvider;
    providerToggle.textContent = providers[currentProvider].label;
  });

  // Bookmark toggle
  const bookmarkToggle = document.getElementById('chatBookmarkToggle');
  if (bookmarkToggle) {
    bookmarkToggle.addEventListener('click', async () => {
      if (!currentChatId) return;

      try {
        const resp = await fetch(`/app/chat/api/chat/${currentChatId}/bookmark`, { method: 'POST' });
        if (resp.ok) {
          const data = await resp.json();
          updateStarButton(data.bookmarked);
          // Update allChats cache if present
          const chat = allChats.find(c => c.chat_id === currentChatId);
          if (chat) {
            chat.bookmarked = data.bookmarked;
          }
        }
      } catch (err) {
        console.error('Failed to toggle bookmark:', err);
      }
    });
  }

  setupFormHandlers();
  input.focus();
}

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    initAppBarControls();
  });
} else {
  initAppBarControls();
}

// Deduplication using agent_id:ts as key
const processedEventIds = new Set();
const MAX_EVENT_IDS = 500;

function shouldSkipEvent(event) {
  if (!event || !event.agent_id || !event.ts) {
    return false;
  }
  const eventKey = `${event.agent_id}:${event.ts}`;
  if (processedEventIds.has(eventKey)) {
    return true;
  }
  processedEventIds.add(eventKey);

  // Prevent memory leak - clear old entries if too many
  if (processedEventIds.size > MAX_EVENT_IDS) {
    const entries = Array.from(processedEventIds);
    entries.slice(0, 100).forEach(e => processedEventIds.delete(e));
  }
  return false;
}

function resetEventTracking() {
  processedEventIds.clear();
}

// Single source of truth for event rendering
function enrichEvent(event) {
  const enriched = {...event};

  // Render finish events
  if (event.event === 'finish') {
    const resultText = event.result || '';
    enriched.html = marked.parse(resultText, {
      breaks: true,  // nl2br equivalent
      gfm: true      // GitHub Flavored Markdown
    });
    enriched.rawMarkdown = resultText;
  }

  // Render error events
  else if (event.event === 'error') {
    const errorMsg = event.error || 'Unknown error';
    const trace = event.trace || '';
    const errorText = trace
      ? `‚ùå **Error**: ${errorMsg}\n\n\`\`\`\n${trace}\n\`\`\``
      : `‚ùå **Error**: ${errorMsg}`;
    enriched.html = marked.parse(errorText, {breaks: true, gfm: true});
    enriched.rawMarkdown = errorText;
    enriched.result = errorText;
  }

  return enriched;
}

// State management
let currentChatId = null;   // The chat being viewed (stable across continuations)
let currentChatFacet = null; // Facet of the current chat (for facet switch handling)
let currentThread = [];     // Agent IDs in the current thread (for WebSocket filtering)
let isComplete = false;
let canContinue = false;    // Whether the chat can be continued (false if ended in error)

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ROUTER - Hash-based SPA navigation
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Initialize hash-based router.
 * Call once after allChats are fetched.
 */
function initRouter() {
  window.addEventListener('hashchange', handleRouteChange);
  handleRouteChange(); // Handle initial route
}

/**
 * Parse hash and dispatch to appropriate view.
 */
function handleRouteChange() {
  const hash = location.hash.slice(1);

  if (hash === 'saved') {
    // Saved chats view
    showSavedChatsView();
  } else {
    const chatId = /^\d+$/.test(hash) ? hash : null;

    if (chatId) {
      // Avoid reloading same chat
      if (currentChatId !== chatId) {
        loadChat(chatId);
      }
    } else {
      // Recent chats view - show if not already on it or if first load
      if (currentChatId !== null || !document.getElementById('recentChatsPanel')) {
        showRecentChatsView();
      }
    }
  }
}

/**
 * Navigate programmatically. Updates hash which triggers handleRouteChange.
 * @param {string|null} chatId - Chat to open, or null for recent view
 */
function navigateTo(chatId) {
  location.hash = chatId || '';
}

/**
 * Update star button state based on bookmark status.
 * @param {number|null} bookmarked - Bookmark timestamp or null
 */
function updateStarButton(bookmarked) {
  const btn = document.getElementById('chatBookmarkToggle');
  if (!btn) return;

  if (currentChatId) {
    btn.style.display = 'inline';
    btn.textContent = bookmarked ? '‚òÖ' : '‚òÜ';
    btn.classList.toggle('bookmarked', !!bookmarked);
    btn.classList.toggle('unbookmarked', !bookmarked);
    btn.title = bookmarked ? 'Remove bookmark' : 'Bookmark this chat';
  } else {
    btn.style.display = 'none';
  }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VIEW FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Clear message area and reset UI state.
 */
function clearMessages() {
  messagesDiv.innerHTML = '';
  messagesDiv.appendChild(activityIndicator);
  forceHideActivityIndicator();
  Object.keys(toolPlacards).forEach(key => delete toolPlacards[key]);
  previousAgent = null;
  resetEventTracking();
}

/**
 * Load and display a chat conversation (full thread).
 * @param {string} chatId - The chat ID to load
 */
async function loadChat(chatId) {
  // Update state
  currentChatId = chatId;
  currentThread = [];
  isComplete = false;
  canContinue = false;
  resetEventTracking();
  hideRetryButton();

  // Notify background service
  if (window.AppServices?.services?.chat) {
    window.AppServices.services.chat.setActiveAgent(chatId);
  }

  // Prepare UI - always clear and load full thread
  clearMessages();
  showActivityIndicator();

  // Fetch full thread events from server
  try {
    const response = await fetch(`/app/chat/api/chat/${chatId}/events`);
    if (!response.ok) {
      showError(`Failed to load chat: ${response.statusText}`);
      return;
    }

    const data = await response.json();
    const events = data.events || [];
    currentThread = data.thread || [chatId];
    isComplete = data.is_complete || false;
    canContinue = data.can_continue || false;
    currentChatFacet = data.chat?.facet || null;

    // Update provider toggle to match last used provider in this chat
    if (data.last_provider) {
      setProvider(data.last_provider);
    }

    // Update star button based on chat's bookmark status
    updateStarButton(data.chat?.bookmarked || null);

    // Process and render all events from the thread
    for (const event of events) {
      const enriched = enrichEvent(event);
      if (!shouldSkipEvent(enriched)) {
        processEvent(enriched);
      }
    }

    // Update UI based on completion state
    if (isComplete) {
      forceHideActivityIndicator();
      if (canContinue) {
        enableContinuation(chatId);
      } else if (data.end_state === 'error') {
        showRetryButton(chatId);
      }
    }

    // Mark as read and update badges
    await markChatRead(chatId);

    // Scroll to bottom
    messagesDiv.scrollTop = messagesDiv.scrollHeight;

  } catch (error) {
    showError(`Failed to load chat: ${error.message}`);
  }
}

/**
 * Enable continuation input after chat completes.
 * @param {string} chatId - The chat ID to continue
 */
function enableContinuation(chatId) {
  hideRetryButton();
  if (input) {
    input.disabled = false;
    input.placeholder = 'Continue conversation...';
    input.dataset.continueChat = chatId;
  }
}

/**
 * Show retry button after an error. Adds button inline after the last message.
 * @param {string} chatId - The chat ID to retry
 */
function showRetryButton(chatId) {
  // Remove any existing retry button
  hideRetryButton();

  // Create retry button container
  const retryDiv = document.createElement('div');
  retryDiv.id = 'retry-container';
  retryDiv.className = 'retry-container';
  retryDiv.innerHTML = `
    <button class="retry-button" onclick="retryChat('${chatId}')">
      <span class="retry-icon">‚Üª</span> Retry
    </button>
  `;
  messagesDiv.appendChild(retryDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;

  // Keep input disabled
  if (input) {
    input.disabled = true;
    input.placeholder = 'Retry failed message...';
    delete input.dataset.continueChat;
  }
}

/**
 * Hide and remove the retry button.
 */
function hideRetryButton() {
  const existing = document.getElementById('retry-container');
  if (existing) {
    existing.remove();
  }
}

/**
 * Retry the last failed message in the current chat.
 * @param {string} chatId - The chat ID to retry
 */
async function retryChat(chatId) {
  hideRetryButton();
  showActivityIndicator();
  canContinue = false;

  try {
    const response = await fetch(`/app/chat/api/chat/${chatId}/retry`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ provider: currentProvider })
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Retry failed');
    }

    const data = await response.json();
    // Add new agent to thread for WebSocket event filtering
    currentThread.push(data.agent_id);
    isComplete = false;
    // Events will arrive via WebSocket

  } catch (error) {
    forceHideActivityIndicator();
    showError(`Retry failed: ${error.message}`, false);
    // Re-show retry button on failure (this will disable input)
    showRetryButton(chatId);
  }
}

/**
 * Mark chat as read and update all badge/submenu state.
 * @param {string} chatId - The chat to mark read
 */
async function markChatRead(chatId) {
  try {
    // Server-side mark read
    await fetch(`/app/chat/api/chat/${chatId}/read`, { method: 'POST' });

    // Update local cache and get facet for badge update
    const chat = allChats.find(c => c.chat_id === chatId);
    if (chat && chat.unread) {
      const facet = chat.facet;
      chat.unread = false;

      // Update badges via background service
      if (window.AppServices?.services?.chat) {
        window.AppServices.services.chat.markRead(chatId, facet);
      }
    }
  } catch (err) {
    console.error('Failed to mark as read:', err);
  }
}

/**
 * Reset to list view state (no active chat).
 */
function resetToListView() {
  currentChatId = null;
  currentChatFacet = null;
  currentThread = [];
  isComplete = false;
  canContinue = false;
  clearMessages();
  hideRetryButton();
  updateStarButton(null);

  if (input) {
    delete input.dataset.continueChat;
    input.disabled = false;
    input.placeholder = 'Send a message...';
  }

  if (window.AppServices?.services?.chat) {
    window.AppServices.services.chat.setActiveAgent(null);
  }
}

/**
 * Show recent chats view with proper state reset.
 */
function showRecentChatsView() {
  resetToListView();
  const panel = renderRecentChats();
  messagesDiv.appendChild(panel);
}

/**
 * Show saved/bookmarked chats view.
 */
async function showSavedChatsView() {
  resetToListView();

  // Fetch bookmarks from API
  let bookmarks = [];
  try {
    const facet = window.selectedFacet;
    const url = facet !== null
      ? `/app/chat/api/bookmarks?facet=${encodeURIComponent(facet)}`
      : '/app/chat/api/bookmarks';
    const response = await fetch(url);
    if (response.ok) {
      const data = await response.json();
      bookmarks = data.bookmarks || [];
    }
  } catch (error) {
    console.error('Failed to fetch bookmarks:', error);
  }

  // Render saved chats panel
  const panel = document.createElement('div');
  panel.className = 'recent-chats-panel';
  panel.id = 'savedChatsPanel';

  const title = document.createElement('h3');
  title.textContent = 'Saved Chats';
  panel.appendChild(title);

  if (bookmarks.length === 0) {
    const empty = document.createElement('div');
    empty.className = 'recent-chats-empty';
    empty.textContent = 'No saved chats';
    panel.appendChild(empty);
  } else {
    const list = document.createElement('div');
    list.className = 'recent-chats-list';

    for (const chat of bookmarks) {
      list.appendChild(buildChatItem(chat, { showStar: true }));
    }

    panel.appendChild(list);
  }

  messagesDiv.appendChild(panel);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Create persistent activity indicator
const activityIndicator = document.createElement('div');
activityIndicator.className = 'activity-indicator';
activityIndicator.id = 'activityIndicator';
activityIndicator.innerHTML = '<span></span><span></span><span></span>';

let chatControlsInitialized = false;

function showActivityIndicator() {
  if (!document.getElementById('activityIndicator')) {
    messagesDiv.appendChild(activityIndicator);
  }
  activityIndicator.classList.add('active');
  requestAnimationFrame(() => {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  });
}

function forceHideActivityIndicator() {
  activityIndicator.classList.remove('active');
}

function ensureActivityIndicatorAtBottom() {
  // Ensure activity indicator is always the last element
  if (!activityIndicator.parentNode) {
    messagesDiv.appendChild(activityIndicator);
  } else if (activityIndicator.parentNode === messagesDiv && messagesDiv.lastElementChild !== activityIndicator) {
    messagesDiv.appendChild(activityIndicator);
  }
}

function addEventCard(text, url, event, params){
  const div=document.createElement('div');
  div.className='event-card';
  const a=document.createElement('a');
  a.href=url;
  a.textContent=text;
  div.appendChild(a);

  // Add parameter pills if provided
  const pills = createParamPills(params);
  if (pills) div.appendChild(pills);

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Track tool calls by ID to update them when complete
// Limit to prevent memory leaks
const toolPlacards = {};
const MAX_TOOL_PLACARDS = 100;

// Track agent switches - only show when switching between agents
let previousAgent = null;

// Clean up old tool placards when limit reached
function cleanupOldPlacards() {
  const keys = Object.keys(toolPlacards);
  if (keys.length > MAX_TOOL_PLACARDS) {
    // Remove oldest entries (first half)
    const toRemove = keys.slice(0, Math.floor(keys.length / 2));
    toRemove.forEach(key => delete toolPlacards[key]);
  }
}

// Format tool args into display-friendly params (query, facet, day, topic, etc.)
function formatToolParams(args) {
  if (!args) return [];
  const params = [];

  if (args.query) {
    params.push({label: 'query', value: args.query});
  }
  if (args.facet) {
    params.push({label: 'facet', value: args.facet});
  }
  if (args.day) {
    params.push({label: 'day', value: formatDay(args.day)});
  }
  if (args.day_from) {
    params.push({label: 'from', value: formatDay(args.day_from)});
  }
  if (args.day_to) {
    params.push({label: 'to', value: formatDay(args.day_to)});
  }
  if (args.topic) {
    params.push({label: 'topic', value: args.topic});
  }

  return params;
}

// Create a span containing parameter pills from params array
function createParamPills(params) {
  if (!params || params.length === 0) return null;
  const paramsSpan = document.createElement('span');
  paramsSpan.className = 'tool-params';
  params.forEach(p => {
    const pill = document.createElement('span');
    pill.className = 'tool-param';
    const label = document.createElement('span');
    label.className = 'param-label';
    label.textContent = p.label + ': ';
    pill.appendChild(label);
    pill.appendChild(document.createTextNode(p.value));
    paramsSpan.appendChild(pill);
  });
  return paramsSpan;
}

function addToolPlacard(toolName, event, callId){
  const div=document.createElement('div');
  div.className='tool-placard';

  const nameSpan=document.createElement('span');
  nameSpan.className='tool-name';
  nameSpan.textContent='üîß ' + toolName;
  div.appendChild(nameSpan);

  // Add parameter pills if args present
  const args = event && event.args;
  const pills = createParamPills(formatToolParams(args));
  if (pills) div.appendChild(pills);

  const statusSpan=document.createElement('span');
  statusSpan.className='tool-status';
  statusSpan.textContent='(running...)';
  div.appendChild(statusSpan);

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;

  // Store reference to update later
  if(callId){
    toolPlacards[callId] = {div, statusSpan};
    cleanupOldPlacards();  // Clean up if too many
  }
  return div;
}

function completeToolPlacard(callId, result){
  if(toolPlacards[callId]){
    const {div, statusSpan} = toolPlacards[callId];
    div.classList.add('completed');
    statusSpan.textContent = '‚úì';

    // Update title attribute with result
    if(result && div.title){
      const resultText = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
      div.title += '\n\n=== Result ===\n' + resultText;
    }

    delete toolPlacards[callId];
  }
}

function addAgentUpdate(agentName){
  // Only show agent switch if we're actually switching from one agent to another
  if(previousAgent && previousAgent !== agentName){
    const div=document.createElement('div');
    div.className='agent-update';
    div.textContent=`‚Üí Switched from ${previousAgent} to ${agentName} agent`;
    messagesDiv.insertBefore(div, activityIndicator);
    ensureActivityIndicatorAtBottom();
    messagesDiv.scrollTop=messagesDiv.scrollHeight;
  }
  previousAgent = agentName;
}

function addThinkingCard(summary, model){
  const div=document.createElement('div');
  div.className='thinking-card';

  const label=document.createElement('div');
  label.className='thinking-label';
  label.textContent=`üí≠ Thinking (${model})`;
  div.appendChild(label);

  const content=document.createElement('div');
  content.className='thinking-content';
  content.textContent=summary;
  div.appendChild(content);

  div.addEventListener('click', () => {
    div.classList.toggle('expanded');
  });

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Store raw markdown for each bot message
const messageMarkdown = new WeakMap();

function addMessage(text, cls, isHtml=false, rawMarkdown=null){
  const div=document.createElement('div');
  div.className='message '+cls;

  // Use HTML for bot messages if provided, otherwise plain text
  if(isHtml && cls === 'from-bot'){
    div.innerHTML = text;
    if(rawMarkdown) {
      messageMarkdown.set(div, rawMarkdown);
    }
  } else {
    div.textContent = text;
    if(cls === 'from-user') {
      messageMarkdown.set(div, text);
    }
  }

  // Create action buttons container (integrated into message)
  const actions = document.createElement('div');
  actions.className = 'message-actions';

  if(cls === 'from-user'){
    // Recycle button
    const recycleBtn = document.createElement('button');
    recycleBtn.innerHTML = '‚ôªÔ∏è';
    recycleBtn.title = 'Reuse';
    recycleBtn.onclick = (e) => {
      e.stopPropagation();
      reuseMessage(div);
    };
    actions.appendChild(recycleBtn);
  }

  // Copy button for all messages
  const copyBtn = document.createElement('button');
  copyBtn.innerHTML = 'üìã';
  copyBtn.title = 'Copy';
  copyBtn.onclick = (e) => {
    e.stopPropagation();
    copyMessageMarkdown(div, copyBtn);
  };
  actions.appendChild(copyBtn);

  div.appendChild(actions);
  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

function copyMessageMarkdown(messageDiv, copyBtn) {
  const markdown = messageMarkdown.get(messageDiv);
  if(!markdown) {
    // Nothing to copy - brief feedback
    copyBtn.innerHTML = '‚àí';
    setTimeout(() => { copyBtn.innerHTML = 'üìã'; }, 1000);
    return;
  }

  navigator.clipboard.writeText(markdown).then(() => {
    copyBtn.innerHTML = '‚úì';
    copyBtn.classList.add('copied');
    setTimeout(() => {
      copyBtn.innerHTML = 'üìã';
      copyBtn.classList.remove('copied');
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy:', err);
    copyBtn.innerHTML = '‚ùå';
    setTimeout(() => { copyBtn.innerHTML = 'üìã'; }, 2000);
  });
}

function reuseMessage(messageDiv) {
  const text = messageMarkdown.get(messageDiv);
  if(!text) return;

  // Reset to list view state (clears messages, state, enables input)
  resetToListView();

  // Clear URL hash to match state
  location.hash = '';

  // Pre-fill input with the message text
  if(input) {
    input.value = text;
    input.focus();

    // Auto-resize the textarea
    input.style.height = 'auto';
    input.style.height = input.scrollHeight + 'px';
  }
}

function setupFormHandlers() {
  // Enter key to submit
  input.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      form.requestSubmit();
    }
  });

  // Form submission
  form.onsubmit = async e => {
    e.preventDefault();
    const text = input.value.trim();
    if (!text) return;

    // Hide recent chats panel when sending a message
    hideRecentChats();

    input.value = '';
    input.disabled = true;

    // Check if continuing existing chat
    const continueChatId = input.dataset.continueChat;
    delete input.dataset.continueChat;

    const payload = { message: text, provider: currentProvider };
    if (continueChatId) {
      payload['continue_chat'] = continueChatId;
    }

    const r = await fetch(sendUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });

    if (r.ok) {
      const d = await r.json();
      if (continueChatId) {
        // Continuation: add new agent to thread and keep listening
        // Don't reload - that clears UI and causes race conditions with WebSocket events
        currentThread.push(d.agent_id);
        isComplete = false;
        canContinue = false;
        showActivityIndicator();
      } else {
        // New chat: set expected facet before navigation to avoid race conditions
        // (loadChat will confirm this from server, but this protects against facet.switch)
        currentChatFacet = window.selectedFacet;
        navigateTo(d.chat_id);
      }
    } else {
      input.disabled = false;
      let err = 'Error';
      try { const d = await r.json(); err = d.error || err; } catch { };
      if (window.showError) showError(err);
    }
  };
}

// Event handler for both live and historical events
function processEvent(event) {
  switch(event.event) {
    case 'start':
      addMessage(event.prompt || '', 'from-user');
      break;

    case 'tool_start':
      handleToolStart(event);
      break;

    case 'tool_end':
      completeToolPlacard(event.call_id, event.result);
      break;

    case 'thinking':
      addThinkingCard(event.summary, event.model || 'unknown');
      break;

    case 'agent_updated':
      addAgentUpdate(event.agent || 'unknown');
      break;

    case 'finish':
      // Add final message
      if(event.html){
        addMessage(event.html, 'from-bot', true, event.rawMarkdown);
      }

      isComplete = true;
      canContinue = true;
      forceHideActivityIndicator();

      // Re-enable input and enable continuation using current chat ID
      if(currentChatId){
        enableContinuation(currentChatId);
      }
      break;

    case 'error':
      // Display error message
      if(event.html){
        addMessage(event.html, 'from-bot', true, event.rawMarkdown);
      }

      isComplete = true;
      canContinue = false;
      forceHideActivityIndicator();

      // Show retry button instead of enabling input
      if(currentChatId){
        showRetryButton(currentChatId);
      }
      break;
  }
}

// Handle tool_start events
function handleToolStart(event) {
  const {tool, args, call_id} = event;

  // Handle search tools with special event cards
  if(args && args.query) {
    const url = searchBase + '#q=' + encodeURIComponent(args.query);
    const searchText = `Searching for "${args.query}"`;
    // Get filter params (excluding query since it's already in the text)
    const params = formatToolParams(args).filter(p => p.label !== 'query');
    addEventCard(searchText, url, event, params);
    return;
  }

  // Handle get_resource tool
  if(tool === 'get_resource' && args && args.uri) {
    const resourceCard = createResourceCard(args.uri);
    if(resourceCard) {
      addEventCard(resourceCard.text, resourceCard.url, event);
      return;
    }
  }

  // Default: show tool placard
  addToolPlacard(tool, event, call_id);
}

// Create resource card for get_resource tool
function createResourceCard(uri) {
  // Helper to format time from HHMMSS to HH:MM
  function formatTime(timeStr) {
    const hours = timeStr.substring(0, 2);
    const minutes = timeStr.substring(2, 4);
    return `${hours}:${minutes}`;
  }

  // Parse journal://insight/20250815/meetings format
  let match = uri.match(/journal:\/\/insight\/(\d{8})\/(.+)/);
  if(match) {
    const date = match[1];
    const topic = match[2];
    const dateStr = formatDay(date);
    const topicDisplay = topic.charAt(0).toUpperCase() + topic.slice(1);

    return {
      text: `Reading ${topicDisplay} Insight from ${dateStr}`,
      url: `/calendar/${date}#${topic}`
    };
  }

  // Parse journal://transcripts/{mode}/20250726/090000/45 format
  match = uri.match(/journal:\/\/transcripts\/(full|audio|screen)\/(\d{8})\/(\d{6})\/(\d+)/);
  if(match) {
    const mode = match[1];
    const date = match[2];
    const time = match[3];
    const length = match[4];
    const dateStr = formatDay(date);
    const timeStr = formatTime(time);

    const modeText = mode === 'full' ? 'full' : mode === 'audio' ? 'audio-only' : 'screen-only';

    return {
      text: `Loading ${length}-minute ${modeText} transcript from ${dateStr} at ${timeStr}`,
      url: `/calendar/${date}`
    };
  }

  // Parse journal://media/20250726/audio_090000.flac or screenshot_090000.png format
  match = uri.match(/journal:\/\/media\/(\d{8})\/(.+)/);
  if(match) {
    const date = match[1];
    const filename = match[2];
    const dateStr = formatDay(date);

    // Determine media type from filename
    let description = filename;
    if(filename.includes('audio') || filename.endsWith('.flac')) {
      const timeMatch = filename.match(/(\d{6})/);
      if(timeMatch) {
        description = `audio recording from ${formatTime(timeMatch[1])}`;
      }
    } else if(filename.includes('screenshot') || filename.endsWith('.png')) {
      const timeMatch = filename.match(/(\d{6})/);
      if(timeMatch) {
        description = `screenshot from ${formatTime(timeMatch[1])}`;
      }
    }

    return {
      text: `Loading ${description} (${dateStr})`,
      url: `/calendar/${date}`
    };
  }

  // Fallback for unknown journal:// formats
  if(uri.startsWith('journal://')) {
    return {
      text: `Fetching journal resource: ${uri}`,
      url: '#'
    };
  }

  return null;
}


// Initialize WebSocket listener and controls
(function initChatControls(){
  if(chatControlsInitialized) return;
  chatControlsInitialized = true;

  // Global WebSocket listener for cortex events
  appEvents.listen('cortex', e => {
    // Only process events for agents in our current thread
    if (!currentChatId || !currentThread.includes(e.agent_id)) {
      return;
    }

    // Stop listening once complete
    if (isComplete) {
      return;
    }

    // Deduplicate and enrich
    if (shouldSkipEvent(e)) {
      return;
    }

    const enriched = enrichEvent(e);
    processEvent(enriched);
  });
})();

// Initialize: fetch chats then start router
fetchRecentChats().then(() => {
  initRouter();
});
</script>
