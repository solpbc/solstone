{% extends 'base.html' %}
{% set title = 'Chat' %}
{% set active = 'chat' %}
{% block head %}
<style>
body {height:100vh; overflow:hidden;}
.container {height:100vh; display:flex; flex-direction:column; position:relative; padding:0 1em; box-sizing:border-box;}
#messages {flex:1; overflow-y:auto; padding:1em; padding-bottom:1em; display:flex; flex-direction:column; min-height:0;}
.message {margin-bottom:0.75em; padding:0.75em 1em; border-radius:12px; max-width:75%; box-shadow:0 1px 3px rgba(0,0,0,0.1); animation:fadeInUp 0.3s ease-out; position:relative;}
.from-user {background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; align-self:flex-end; margin-left:20%;}
.from-bot {background:#fff; border:1px solid #e0e0e0; align-self:flex-start; margin-right:20%;}
.copy-markdown-btn {position:absolute; top:0.5em; right:0.5em; background:rgba(0,0,0,0.05); border:1px solid rgba(0,0,0,0.1); border-radius:4px; padding:0.25em 0.5em; cursor:pointer; opacity:0; transition:opacity 0.2s; font-size:0.9em; color:#666;}
.copy-markdown-btn:hover {background:rgba(0,0,0,0.1); color:#333;}
.from-bot:hover .copy-markdown-btn {opacity:1;}
.copy-markdown-btn.copied {background:#4caf50; color:white; border-color:#4caf50;}
@keyframes fadeInUp {from{opacity:0;transform:translateY(10px);}to{opacity:1;transform:translateY(0);}}
#messages .event-card{background:#fff4e5;border:1px solid #f0ad4e;border-radius:6px;padding:0.5em 0.75em;margin-bottom:0.75em;font-size:0.85em;max-width:80%;align-self:flex-start;cursor:help;}
#messages .event-card a{text-decoration:none;color:#007bff;}
#messages .event-card a:hover{text-decoration:underline;}
#messages .tool-placard{background:#e3f2fd;border:1px solid #2196f3;border-radius:6px;padding:0.4em 0.6em;margin-bottom:0.5em;font-size:0.8em;max-width:60%;align-self:flex-start;cursor:help;}
#messages .tool-placard .tool-name{font-weight:bold;color:#1976d2;}
#messages .tool-placard .tool-status{font-size:0.9em;color:#666;margin-left:0.5em;}
#messages .tool-placard.completed{background:#e8f5e9;border-color:#4caf50;}
#messages .tool-placard.completed .tool-name{color:#2e7d32;}
#messages .agent-update{background:#fff3e0;border:1px solid #ff9800;border-radius:6px;padding:0.4em 0.6em;margin-bottom:0.5em;font-size:0.8em;max-width:60%;align-self:flex-start;color:#e65100;font-style:italic;}
#messages .thinking-card{background:#f8f4ff;border:1px solid #9c27b0;border-radius:6px;padding:0.5em 0.75em;margin-bottom:0.75em;font-size:0.85em;max-width:80%;align-self:flex-start;cursor:pointer;}
#messages .thinking-card:hover{background:#f3e5f5;}
#messages .thinking-card .thinking-label{font-weight:bold;color:#7b1fa2;margin-bottom:0.25em;}
#messages .thinking-card .thinking-content{color:#333;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
#messages .thinking-card.expanded .thinking-content{white-space:pre-wrap;overflow:visible;text-overflow:clip;}
#drawer {display:none; border-top:1px solid #ddd; padding:0.5em; background:#fafafa;}
.input-tray {background:#f8f9fa; border-top:1px solid #e0e0e0; padding:1em;}
.input-area {display:flex; gap:0.5em; align-items:center;}
#messageInput {flex:1; resize:none; border:1px solid #ddd; border-radius:20px; padding:0.75em 1em; font-family:inherit; font-size:14px; line-height:1.5; max-height:120px; min-height:42px;}
#messageInput:focus {outline:none; border-color:#667eea;}
#backendSelect {padding:0.75em 1em; border:1px solid #ddd; border-radius:20px; background:white; cursor:pointer; font-weight:500; height:42px; font-size:14px;}
#backendSelect option[value="google"] {background:#4285f4; color:white;}
#backendSelect option[value="openai"] {background:#10a37f; color:white;}
#backendSelect option[value="anthropic"] {background:#764ba2; color:white;}
.input-area button {padding:0.75em 1.2em; border:none; border-radius:20px; cursor:pointer; font-weight:500; transition:all 0.2s; height:42px; font-size:14px;}
.input-area button[type="submit"] {background:#667eea; color:white;}
.input-area button[type="submit"]:hover {background:#5a67d8; transform:translateY(-1px);}
.input-area button[type="button"] {background:#e0e0e0; color:#333;}
.input-area button[type="button"]:hover {background:#d0d0d0;}
.message h1,.message h2,.message h3,.message h4,.message h5,.message h6 {margin:0.5em 0 0.3em 0;}
.message p {margin:0.3em 0;}
.message ul,.message ol {margin:0.3em 0; padding-left:1.5em;}
.message code {background:rgba(0,0,0,0.1); padding:0.1em 0.3em; border-radius:3px; font-size:0.9em;}
.from-user code {background:rgba(255,255,255,0.2);}
.message pre {background:rgba(0,0,0,0.1); padding:0.5em; border-radius:4px; overflow-x:auto; margin:0.5em 0;}
.from-user pre {background:rgba(255,255,255,0.15);}
.message pre code {background:none; padding:0;}
.message blockquote {margin:0.5em 0; padding-left:1em; border-left:3px solid rgba(0,0,0,0.2);}
.from-user blockquote {border-left-color:rgba(255,255,255,0.4);}
.typing-indicator {display:none; align-self:flex-start; padding:0.75em 1em; background:#f0f0f0; border-radius:12px; margin-bottom:0.75em; max-width:80px;}
.typing-indicator.show {display:flex; align-items:center; gap:4px; animation:fadeInUp 0.3s ease-out;}
.typing-indicator span {width:8px; height:8px; background:#999; border-radius:50%; animation:typingBounce 1.4s infinite ease-in-out;}
.typing-indicator span:nth-child(1) {animation-delay:-0.32s;}
.typing-indicator span:nth-child(2) {animation-delay:-0.16s;}
@keyframes typingBounce {0%,80%,100%{transform:scale(0.8);opacity:0.5;}40%{transform:scale(1);opacity:1;}}
.activity-indicator {align-self:flex-start; padding:0.75em 1em; background:#f0f0f0; border-radius:12px; margin-bottom:0.75em; margin-top:0.5em; max-width:80px; display:none;}
.activity-indicator.active {display:flex; align-items:center; gap:4px; animation:fadeInUp 0.3s ease-out;}
.activity-indicator span {width:8px; height:8px; background:#999; border-radius:50%; animation:typingBounce 1.4s infinite ease-in-out;}
.activity-indicator span:nth-child(1) {animation-delay:-0.32s;}
.activity-indicator span:nth-child(2) {animation-delay:-0.16s;}
</style>
{% endblock %}
{% block body %}
<div class="container">
  <div id="messages">
    <div class="typing-indicator" id="typingIndicator">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  <div id="drawer">Attachments drawer</div>
  <div class="input-tray">
    <form id="inputArea" class="input-area">
      <select id="backendSelect">
        <option value="google">ðŸ”µ Google</option>
        <option value="openai" selected>ðŸŸ¢ OpenAI</option>
        <option value="anthropic">ðŸŸ£ Claude</option>
      </select>
      <textarea id="messageInput" rows="1" placeholder="Send a message..."></textarea>
      <button type="submit">Send</button>
      <button type="button" id="clearBtn">Clear</button>
    </form>
  </div>
</div>
<script>
const sendUrl = '{{ url_for('chat.send_message') }}';
const historyUrl = '{{ url_for('chat.chat_history') }}';
const clearUrl = '{{ url_for('chat.clear_history') }}';
const agentUrl = '{{ url_for('chat.agent_events', agent_id='AGENT_ID') }}';
const form = document.getElementById('inputArea');
const input = document.getElementById('messageInput');
const messagesDiv = document.getElementById('messages');
const backendSelect = document.getElementById('backendSelect');
const searchBase = '{{ url_for('search.search_page') }}';

// Pass persona titles from backend
const personaTitles = {{ persona_titles | tojson }};

const processedEventIds = new Set();

function shouldSkipEvent(event) {
  const eventId = event && event.event_id;
  if (!eventId) {
    return false;
  }
  if (processedEventIds.has(eventId)) {
    return true;
  }
  processedEventIds.add(eventId);
  return false;
}

function resetEventTracking() {
  processedEventIds.clear();
}

// Parse URL parameters for persona and agent ID
const urlParams = new URLSearchParams(window.location.search);
let currentPersona = urlParams.get('persona') || 'default';
let isHistorical = false;
let historicalAgentId = null;

const agentParam = urlParams.get('agent');
if (agentParam && /^\d+$/.test(agentParam)) {
  isHistorical = true;
  historicalAgentId = agentParam;
}

// Create persistent activity indicator
const activityIndicator = document.createElement('div');
activityIndicator.className = 'activity-indicator';
activityIndicator.id = 'activityIndicator';
activityIndicator.innerHTML = '<span></span><span></span><span></span>';

// Track if we're currently processing events
let eventProcessingActive = false;
let eventTimeout = null;
let responseInProgress = false;
let nextContinueAgentId = null;
let chatControlsInitialized = false;
let activeRunAgentId = null;

function showActivityIndicator() {
  if (!document.getElementById('activityIndicator')) {
    messagesDiv.appendChild(activityIndicator);
  }
  activityIndicator.classList.add('active');
  eventProcessingActive = true;
  
  // Auto-scroll to keep activity indicator in view
  requestAnimationFrame(() => {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  });
  
  // Clear any existing timeout
  if (eventTimeout) {
    clearTimeout(eventTimeout);
    eventTimeout = null;
  }
}

function hideActivityIndicator() {
  // Only hide if we're not expecting more events
  if (!responseInProgress) {
    // Set a small delay before hiding to handle rapid event sequences
    if (eventTimeout) {
      clearTimeout(eventTimeout);
    }
    eventTimeout = setTimeout(() => {
      activityIndicator.classList.remove('active');
      eventProcessingActive = false;
    }, 500);
  }
}

function forceHideActivityIndicator() {
  // Force hide without delay
  if (eventTimeout) {
    clearTimeout(eventTimeout);
    eventTimeout = null;
  }
  activityIndicator.classList.remove('active');
  eventProcessingActive = false;
  responseInProgress = false;
}

function ensureActivityIndicatorAtBottom() {
  // Ensure activity indicator is always the last element
  if (!activityIndicator.parentNode) {
    messagesDiv.appendChild(activityIndicator);
  } else if (activityIndicator.parentNode === messagesDiv && messagesDiv.lastElementChild !== activityIndicator) {
    messagesDiv.appendChild(activityIndicator);
  }
}

function addEventCard(text, url, event){
  const div=document.createElement('div');
  div.className='event-card';
  const a=document.createElement('a');
  a.href=url;
  a.textContent=text;
  div.appendChild(a);  // This line was missing!

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Track tool calls by ID to update them when complete
// Limit to prevent memory leaks
const toolPlacards = {};
const MAX_TOOL_PLACARDS = 100;

// Track agent switches - only show when switching between agents
let previousAgent = null;

// Clean up old tool placards when limit reached
function cleanupOldPlacards() {
  const keys = Object.keys(toolPlacards);
  if (keys.length > MAX_TOOL_PLACARDS) {
    // Remove oldest entries (first half)
    const toRemove = keys.slice(0, Math.floor(keys.length / 2));
    toRemove.forEach(key => delete toolPlacards[key]);
  }
}

function addToolPlacard(toolName, event, callId){
  const div=document.createElement('div');
  div.className='tool-placard';

  const nameSpan=document.createElement('span');
  nameSpan.className='tool-name';
  nameSpan.textContent='ðŸ”§ ' + toolName;
  div.appendChild(nameSpan);

  const statusSpan=document.createElement('span');
  statusSpan.className='tool-status';
  statusSpan.textContent='(running...)';
  div.appendChild(statusSpan);

  // Add browser's built-in title attribute with formatted JSON
  if(event){
    div.title = JSON.stringify(event, null, 2);
  }

  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;

  // Store reference to update later
  if(callId){
    toolPlacards[callId] = {div, statusSpan};
    cleanupOldPlacards();  // Clean up if too many
  }
  return div;
}

function completeToolPlacard(callId, result){
  if(toolPlacards[callId]){
    const {div, statusSpan} = toolPlacards[callId];
    div.classList.add('completed');
    statusSpan.textContent = 'âœ“';

    // Update title attribute with result
    if(result && div.title){
      const resultText = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
      div.title += '\n\n=== Result ===\n' + resultText;
    }

    delete toolPlacards[callId];
  }
}

function addAgentUpdate(agentName){
  // Only show agent switch if we're actually switching from one agent to another
  if(previousAgent && previousAgent !== agentName){
    const div=document.createElement('div');
    div.className='agent-update';
    div.textContent=`â†’ Switched from ${previousAgent} to ${agentName} agent`;
    messagesDiv.insertBefore(div, activityIndicator);
    ensureActivityIndicatorAtBottom();
    messagesDiv.scrollTop=messagesDiv.scrollHeight;
  }
  previousAgent = agentName;
}

function addThinkingCard(summary, model){
  const div=document.createElement('div');
  div.className='thinking-card';
  
  const label=document.createElement('div');
  label.className='thinking-label';
  label.textContent=`ðŸ’­ Thinking (${model})`;
  div.appendChild(label);
  
  const content=document.createElement('div');
  content.className='thinking-content';
  content.textContent=summary;
  div.appendChild(content);
  
  div.addEventListener('click', () => {
    div.classList.toggle('expanded');
  });
  
  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

input.focus();

input.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    form.requestSubmit();
  }
});
// Store raw markdown for each bot message
const messageMarkdown = new WeakMap();

function addMessage(text, cls, isHtml=false, rawMarkdown=null){
  const div=document.createElement('div');
  div.className='message '+cls;
  
  // Use HTML for bot messages if provided, otherwise plain text
  if(isHtml && cls === 'from-bot'){
    div.innerHTML = text;
    
    // Store raw markdown if provided
    if(rawMarkdown) {
      messageMarkdown.set(div, rawMarkdown);
    }
    
    // Add copy button for bot messages
    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-markdown-btn';
    copyBtn.innerHTML = 'ðŸ“‹';
    copyBtn.onclick = (e) => {
      e.stopPropagation();
      copyMessageMarkdown(div, copyBtn);
    };
    div.appendChild(copyBtn);
  } else {
    div.textContent = text;
  }
  
  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

function copyMessageMarkdown(messageDiv, copyBtn) {
  const markdown = messageMarkdown.get(messageDiv);
  if(!markdown) return;
  
  navigator.clipboard.writeText(markdown).then(() => {
    // Show success feedback
    copyBtn.innerHTML = 'âœ“';
    copyBtn.classList.add('copied');
    
    // Reset after 2 seconds
    setTimeout(() => {
      copyBtn.innerHTML = 'ðŸ“‹';
      copyBtn.classList.remove('copied');
    }, 2000);
  }).catch(err => {
    console.error('Failed to copy:', err);
    copyBtn.innerHTML = 'âŒ';
    setTimeout(() => {
      copyBtn.innerHTML = 'ðŸ“‹';
    }, 2000);
  });
}
document.getElementById('inputArea').onsubmit=async e=>{
  e.preventDefault();
  const text=input.value.trim();
  if(!text)return;
  
  const continueAgent = nextContinueAgentId;
  const isContinuing = Boolean(continueAgent);

  // Clear previous messages unless we're continuing from an active conversation
  if(!isContinuing){
    messagesDiv.innerHTML='';
    resetEventTracking();
  }
  // Clear tool placard references to prevent memory leaks
  Object.keys(toolPlacards).forEach(key => delete toolPlacards[key]);
  
  // Reset agent tracking when starting new conversation
  previousAgent = null;
  
  // Add the activity indicator to the messages div
  messagesDiv.appendChild(activityIndicator);
  
  addMessage(text,'from-user');
  input.value='';
  
  // Show activity indicator and mark response as in progress
  responseInProgress = true;
  showActivityIndicator();
  
  const payload={message:text,backend:backendSelect.value,persona:currentPersona};
  if(continueAgent){
    payload['continue']=continueAgent;
  }
  nextContinueAgentId=null;
  activeRunAgentId=null;

  const r=await fetch(sendUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
  
  if(r.ok){
    const d=await r.json();
    // Pass both HTML and raw markdown text
    addMessage(d.html||d.text,'from-bot',!!d.html, d.text);
    // Response complete - force hide after a short delay
    responseInProgress = false;
    setTimeout(forceHideActivityIndicator, 1000);
  }else{
    responseInProgress = false;
    forceHideActivityIndicator();
    let err='Error';
    try{const d=await r.json();err=d.error||err;}catch{};
    if(window.showError)showError(err);
  }
};

async function loadHistory(){
  const r=await fetch(historyUrl);
  if(!r.ok)return;
  const d=await r.json();
  for(const m of d.history){
    addMessage(m.text,m.role==='user'?'from-user':'from-bot');
  }
}

async function loadHistoricalAgent(agentId){
  const url = agentUrl.replace('AGENT_ID', agentId);
  const r = await fetch(url);
  if(!r.ok){
    showError('Failed to load historical agent: ' + agentId);
    return;
  }
  const d = await r.json();
  const events = Array.isArray(d.events) ? d.events : [];
  const requestEvent = events.find(e => e.event === 'request');
  const finishEvent = [...events].reverse().find(e => e.event === 'finish');
  const isLive = d.source === 'cortex' && d.is_running;
  activeRunAgentId = null;
  resetEventTracking();

  if(requestEvent){
    if(requestEvent.persona){
      currentPersona = requestEvent.persona;
    }
    if(requestEvent.backend){
      backendSelect.value = requestEvent.backend;
    }
  }

  // Check if this is a live agent from Cortex vs historical from file
  if(isLive) {
    // This is a live agent - hide the historical notice
    const notice = document.getElementById('historicalNotice');
    if(notice) {
      notice.style.display = 'none';
    }
    // Show the form for live agents (but keep it disabled since we're observing)
    form.style.display = '';
    input.disabled = true;
    input.placeholder = 'Viewing live agent run (read-only)...';
    
    // Subscribe to live updates via SSE for this agent
    if(d.agent_id) {
      // Track that we're watching a specific agent
      window.watchingAgentId = d.agent_id;
      responseInProgress = true;  // Keep activity indicator visible
      showActivityIndicator();

      // The global listener will handle events for this agent
      // No need for a separate listener here
    }
  } else {
    // Update the header with human-friendly info for historical agents
    updateHistoricalHeader(agentId, events);
  }
  
  // Process events in chronological order
  // This maintains the proper sequence of messages and tool calls
  for(const event of events){
    if(event.event === 'start'){
      // User message
      addMessage(event.prompt || '', 'from-user');
    } else if(event.event === 'finish'){
      // Assistant final response - use HTML if available for markdown formatting
      const text = event.result || '';
      const html = event.html || text;
      // Pass raw markdown for copy functionality
      addMessage(html, 'from-bot', !!event.html, text);
    } else if(event.event === 'error'){
      // Error event - display as final response
      const text = event.result || event.error || 'Unknown error occurred';
      const html = event.html || text;
      // Pass raw markdown for copy functionality
      addMessage(html, 'from-bot', !!event.html, text);
    } else {
      // All other events (tool calls, thinking, etc.)
      handleHistoricalEvent(event);
    }
  }

  if(!isLive && finishEvent){
    activeRunAgentId = agentId;
    processEvent(finishEvent);
  }

  if(!isLive){
    if(finishEvent && finishEvent.conversation_id){
      nextContinueAgentId = agentId;
      isHistorical = false;
      form.style.display = '';
      input.disabled = false;
      input.placeholder = 'Continue conversation...';
      initChatControls();
      updatePersonaNotice();
      input.focus();
    } else {
      form.style.display = 'none';
    }
  }
}

// Unified event handler for both live and historical events
function processEvent(event) {
  if (shouldSkipEvent(event)) {
    return;
  }

  if(event.agent_id && responseInProgress){
    if(!activeRunAgentId || activeRunAgentId === event.agent_id){
      activeRunAgentId = event.agent_id;
    }
  }

  switch(event.event) {
    case 'tool_start':
      handleToolStart(event);
      break;
    case 'tool_end':
      completeToolPlacard(event.call_id, event.result);
      break;
    case 'thinking':
      addThinkingCard(event.summary, event.model || 'unknown');
      break;
    case 'agent_updated':
      addAgentUpdate(event.agent || 'unknown');
      break;
    case 'finish':
      if(event.agent_id){
        const matchesActive = activeRunAgentId ? event.agent_id === activeRunAgentId : responseInProgress;
        if(event.source === 'cortex'){
          const text = event.result || '';
          const html = event.html || text;
          if(html || text){
            addMessage(html || text, 'from-bot', Boolean(event.html), text || html);
          }
        }
        if(matchesActive){
          if(event.conversation_id){
            nextContinueAgentId = event.agent_id;
          } else if(nextContinueAgentId === event.agent_id){
            nextContinueAgentId = null;
          }
          activeRunAgentId = null;
        }
      }
      break;
    case 'error':
      // Handle error events during live streaming
      // Since the backend already sends formatted HTML for errors,
      // we just need to display the message
      responseInProgress = false;
      forceHideActivityIndicator();
      activeRunAgentId = null;
      nextContinueAgentId = null;
      // Note: The actual error message will be sent from backend
      // via the finish/error handling in _handle_cortex_event
      break;
  }
}

// Handle tool_start events
function handleToolStart(event) {
  const {tool, args, call_id} = event;
  
  // Handle search tools with special event cards
  if(args && args.query) {
    // Determine which index is being searched
    let idx = 'summaries';
    let indexName = 'Summaries';
    if(tool.includes('event')) {
      idx = 'events';
      indexName = 'Events';
    } else if(tool.includes('transcript')) {
      idx = 'transcripts';
      indexName = 'Transcripts';
    }
    
    // Extract date from query if present (format: YYYYMMDD or YYYY-MM-DD)
    let dateStr = '';
    const dateMatch = args.query.match(/\b(\d{8}|\d{4}-\d{2}-\d{2})\b/);
    if(dateMatch) {
      const dateRaw = dateMatch[1].replace(/-/g, '');
      const month = parseInt(dateRaw.substring(4, 6), 10);
      const day = parseInt(dateRaw.substring(6, 8), 10);
      dateStr = ` on ${month}/${day}`;
    }
    
    // Build search URL
    const q = args.query + (idx === 'summaries' ? '' : ' index:' + idx);
    const url = searchBase + '#q=' + encodeURIComponent(q);
    
    // Create descriptive text
    const searchText = `Searching ${indexName} for "${args.query}"${dateStr}`;
    addEventCard(searchText, url, event);
    return;
  }
  
  // Handle get_resource tool
  if(tool === 'get_resource' && args && args.uri) {
    const resourceCard = createResourceCard(args.uri);
    if(resourceCard) {
      addEventCard(resourceCard.text, resourceCard.url, event);
      return;
    }
  }
  
  // Default: show tool placard
  addToolPlacard(tool, event, call_id);
}

// Create resource card for get_resource tool
function createResourceCard(uri) {
  // Helper to format date from YYYYMMDD to M/D
  function formatDate(dateStr) {
    const month = parseInt(dateStr.substring(4, 6), 10);
    const day = parseInt(dateStr.substring(6, 8), 10);
    return `${month}/${day}`;
  }
  
  // Helper to format time from HHMMSS to HH:MM
  function formatTime(timeStr) {
    const hours = timeStr.substring(0, 2);
    const minutes = timeStr.substring(2, 4);
    return `${hours}:${minutes}`;
  }
  
  // Parse journal://summary/20250815/meetings format
  let match = uri.match(/journal:\/\/summary\/(\d{8})\/(.+)/);
  if(match) {
    const date = match[1];
    const topic = match[2];
    const dateStr = formatDate(date);
    const topicDisplay = topic.charAt(0).toUpperCase() + topic.slice(1);
    
    return {
      text: `Reading ${topicDisplay} Summary from ${dateStr}`,
      url: `/calendar/${date}#${topic}`
    };
  }
  
  // Parse journal://transcripts/{mode}/20250726/090000/45 format
  match = uri.match(/journal:\/\/transcripts\/(full|audio|screen)\/(\d{8})\/(\d{6})\/(\d+)/);
  if(match) {
    const mode = match[1];
    const date = match[2];
    const time = match[3];
    const length = match[4];
    const dateStr = formatDate(date);
    const timeStr = formatTime(time);

    const modeText = mode === 'full' ? 'full' : mode === 'audio' ? 'audio-only' : 'screen-only';

    return {
      text: `Loading ${length}-minute ${modeText} transcript from ${dateStr} at ${timeStr}`,
      url: `/calendar/${date}`
    };
  }
  
  // Parse journal://media/20250726/audio_090000.flac or screenshot_090000.png format
  match = uri.match(/journal:\/\/media\/(\d{8})\/(.+)/);
  if(match) {
    const date = match[1];
    const filename = match[2];
    const dateStr = formatDate(date);
    
    // Determine media type from filename
    let description = filename;
    if(filename.includes('audio') || filename.endsWith('.flac')) {
      const timeMatch = filename.match(/(\d{6})/);
      if(timeMatch) {
        description = `audio recording from ${formatTime(timeMatch[1])}`;
      }
    } else if(filename.includes('screenshot') || filename.endsWith('.png')) {
      const timeMatch = filename.match(/(\d{6})/);
      if(timeMatch) {
        description = `screenshot from ${formatTime(timeMatch[1])}`;
      }
    }
    
    return {
      text: `Loading ${description} (${dateStr})`,
      url: `/calendar/${date}`
    };
  }
  
  // Fallback for unknown journal:// formats
  if(uri.startsWith('journal://')) {
    return {
      text: `Fetching journal resource: ${uri}`,
      url: '#'
    };
  }
  
  return null;
}

// Simplified wrapper for historical events
function handleHistoricalEvent(event) {
  processEvent(event);
}

// Function to update historical header with run details
function updateHistoricalHeader(agentId, events) {
  const notice = document.getElementById('historicalNotice');
  if (!notice) return;
  
  const requestEvent = events.find(e => e.event === 'request');
  // Find start and finish events to calculate duration
  const startEvent = events.find(e => e.event === 'start');
  const finishEvent = events.find(e => e.event === 'finish' || e.event === 'error');
  const continueId = requestEvent && requestEvent['continue'] ? String(requestEvent['continue']) : null;
  
  if (startEvent && startEvent.ts) {
    // Format the timestamp as a human-readable date
    const startDate = new Date(startEvent.ts);
    const dateStr = startDate.toLocaleDateString('en-US', {
      weekday: 'short',
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
    
    // Calculate duration if we have both start and finish
    let durationStr = '';
    if (finishEvent && finishEvent.ts) {
      const durationMs = finishEvent.ts - startEvent.ts;
      const seconds = Math.floor(durationMs / 1000);
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      
      if (minutes > 0) {
        durationStr = ` â€¢ Duration: ${minutes}m ${remainingSeconds}s`;
      } else {
        durationStr = ` â€¢ Duration: ${seconds}s`;
      }
    }
    
    // Check if it ended in error
    const errorStatus = finishEvent && finishEvent.event === 'error' ? ' â€¢ Status: Failed' : '';
    
    let headerText = `Viewing historical agent run from ${dateStr}${durationStr}${errorStatus} (read-only)`;
    if (continueId) {
      headerText += ` â€¢ <a id="historicalContinueLink" href="/chat?agent=${continueId}" style="color:#1565c0;text-decoration:underline;">Previous run ${continueId}</a>`;
    }
    notice.innerHTML = headerText;
  } else if (continueId) {
    notice.innerHTML = `Viewing historical agent run (read-only) â€¢ <a id="historicalContinueLink" href="/chat?agent=${continueId}" style="color:#1565c0;text-decoration:underline;">Previous run ${continueId}</a>`;
  }
}

function updatePersonaNotice(){
  const container = document.querySelector('.container');
  if(!container) return;

  let notice = document.getElementById('personaNotice');
  if(currentPersona === 'default' || isHistorical){
    if(notice){
      notice.remove();
    }
    return;
  }

  const personaTitle = personaTitles[currentPersona] || currentPersona;
  if(!notice){
    notice = document.createElement('div');
    notice.id = 'personaNotice';
    notice.style.cssText = 'background:#e3f2fd;border:1px solid #2196f3;padding:0.75rem;margin:1rem;border-radius:4px;text-align:center;color:#1565c0;';
    container.insertBefore(notice, messagesDiv);
  }
  notice.innerHTML = `Using <strong>${personaTitle}</strong> persona`;
}

function initChatControls(){
  if(chatControlsInitialized) return;
  chatControlsInitialized = true;

  const clearButton = document.getElementById('clearBtn');
  if(clearButton){
    clearButton.onclick = async ()=>{
      await fetch(clearUrl,{method:'POST'});
      messagesDiv.innerHTML='';
      Object.keys(toolPlacards).forEach(key => delete toolPlacards[key]);
      messagesDiv.appendChild(activityIndicator);
      previousAgent = null;
      responseInProgress = false;
      nextContinueAgentId = null;
      activeRunAgentId = null;
      forceHideActivityIndicator();
      resetEventTracking();
      input.focus();
    };
  }

  backendSelect.addEventListener('change', async ()=>{
    await fetch(clearUrl,{method:'POST'});
    messagesDiv.innerHTML='';
    Object.keys(toolPlacards).forEach(key => delete toolPlacards[key]);
    messagesDiv.appendChild(activityIndicator);
    previousAgent = null;
    responseInProgress = false;
    nextContinueAgentId = null;
    activeRunAgentId = null;
    forceHideActivityIndicator();
    resetEventTracking();
    input.focus();
  });

  // Global event listener for all chat events
  // Handles both regular chat responses and watched agent events
  appEvents.listen('chat', e => {
    // Check if this event is relevant to us:
    // 1. We're processing a direct response from the active chat agent
    // 2. We're watching a specific agent and this event is from that agent
    const eventAgentId = e.agent_id;
    const eventSource = e.source || 'direct';
    const isDirectChatEvent = responseInProgress && eventSource === 'direct';
    const isSameAgent = responseInProgress && eventAgentId && activeRunAgentId === eventAgentId;
    const isWatchedAgent = Boolean(window.watchingAgentId && eventAgentId === window.watchingAgentId);

    if (!isDirectChatEvent && !isSameAgent && !isWatchedAgent) {
      return; // Skip irrelevant events
    }

    // Show activity for relevant events
    showActivityIndicator();
    processEvent(e);

    // Handle completion for watched agents
    if (window.watchingAgentId && e.agent_id === window.watchingAgentId) {
      if (e.event === 'finish' || e.event === 'error') {
        responseInProgress = false;
        window.watchingAgentId = null;
        // Update UI to show it's completed
        const input = document.getElementById('messageInput');
        if (input) {
          input.placeholder = 'Agent run completed (read-only)';
        }
        forceHideActivityIndicator();
      }
    }
  });

  loadHistory();

  updatePersonaNotice();
}

// Disable input and controls if viewing historical agent
if(isHistorical){
  initChatControls();
  form.style.display = 'none';
  const notice = document.createElement('div');
  notice.id = 'historicalNotice';
  notice.style.cssText = 'background:#fff3cd;border:1px solid #ffeaa7;padding:0.75rem;margin:1rem;border-radius:4px;text-align:center;color:#856404;';
  notice.textContent = `Loading historical agent run...`;
  document.querySelector('.container').insertBefore(notice, messagesDiv);

  messagesDiv.appendChild(activityIndicator);

  if(historicalAgentId){
    loadHistoricalAgent(historicalAgentId);
  }
} else {
  initChatControls();
}
</script>
{% endblock %}
