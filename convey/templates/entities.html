{% extends 'base.html' %}
{% set title = 'Entity Review' %}
{% set active = 'entities' %}
{% block head %}
<style>
h1 { margin-bottom: 1em; }

/* Entity type color scheme - light shades */
:root {
  --color-person: #e8f5e9;      /* Light green */
  --color-company: #e3f2fd;     /* Light blue */
  --color-project: #fff3e0;     /* Light orange */
  --color-tool: #f3e5f5;        /* Light purple */
  
  --border-person: #a5d6a7;     /* Green border */
  --border-company: #90caf9;    /* Blue border */
  --border-project: #ffcc80;    /* Orange border */
  --border-tool: #ce93d8;       /* Purple border */
  
  --text-person: #2e7d32;       /* Dark green text */
  --text-company: #1565c0;      /* Dark blue text */
  --text-project: #e65100;      /* Dark orange text */
  --text-tool: #6a1b9a;         /* Dark purple text */
}

/* Table styling */
table { 
  width: 100%; 
  border-collapse: collapse; 
  background: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
th, td { 
  padding: 12px; 
  text-align: left; 
  border-bottom: 1px solid #e0e0e0; 
}
th { 
  background: #f8f9fa; 
  font-weight: 600;
  color: #333;
}
tr:hover { background: #f8f9fa; }

/* Entity type specific table backgrounds */
table[data-entity-type="Person"] {
  background: linear-gradient(to bottom, var(--color-person) 0%, white 100px);
}

table[data-entity-type="Person"] th {
  background: var(--color-person);
  color: var(--text-person);
  border-bottom: 2px solid var(--border-person);
}

table[data-entity-type="Company"] {
  background: linear-gradient(to bottom, var(--color-company) 0%, white 100px);
}

table[data-entity-type="Company"] th {
  background: var(--color-company);
  color: var(--text-company);
  border-bottom: 2px solid var(--border-company);
}

table[data-entity-type="Project"] {
  background: linear-gradient(to bottom, var(--color-project) 0%, white 100px);
}

table[data-entity-type="Project"] th {
  background: var(--color-project);
  color: var(--text-project);
  border-bottom: 2px solid var(--border-project);
}

table[data-entity-type="Tool"] {
  background: linear-gradient(to bottom, var(--color-tool) 0%, white 100px);
}

table[data-entity-type="Tool"] th {
  background: var(--color-tool);
  color: var(--text-tool);
  border-bottom: 2px solid var(--border-tool);
}
.count {
  text-align: left;
  font-weight: bold;
  color: #007bff;
  width: 110px;
}
.entity-row {
  cursor: pointer;
}
.entity-count {
  display: inline-flex;
  align-items: center;
  gap: 8px;
}
.entity-star {
  font-size: 1.1em;
  line-height: 1;
  cursor: pointer;
  transition: transform 0.15s ease, color 0.15s ease;
  flex-shrink: 0;
}
.entity-star:hover {
  transform: scale(1.1);
}
.entity-star.is-top {
  color: gold;
  cursor: default;
  transform: none;
}
.entity-star.is-loading {
  color: #888;
  cursor: wait;
  transform: none;
}
.entity-count-value {
  display: inline-block;
  min-width: 3ch;
  text-align: right;
  font-variant-numeric: tabular-nums;
}
.name { font-weight: 500; width: 200px; }
.desc { color: #666; }

/* Tab styling with new entity button */
.tabs-container {
  margin-bottom: 1em;
}

.tabs {
  display: flex;
  gap: 0;
  margin-bottom: 1em;
}

/* Entity type specific tab colors */
.tab {
  padding: 10px 20px;
  cursor: pointer;
  border: 1px solid #ddd;
  border-bottom: none;
  background: #f8f9fa;
  transition: all 0.3s ease;
}

.tab:hover {
  background: #e9ecef;
}

.tab.active {
  background: white;
  font-weight: 600;
}

.tab[data-type="Person"] {
  background: var(--color-person);
  border-color: var(--border-person);
  color: var(--text-person);
}

.tab[data-type="Person"]:hover {
  background: #c8e6c9;
}

.tab[data-type="Person"].active {
  background: white;
  border-bottom: 3px solid var(--border-person);
}

.tab[data-type="Company"] {
  background: var(--color-company);
  border-color: var(--border-company);
  color: var(--text-company);
}

.tab[data-type="Company"]:hover {
  background: #bbdefb;
}

.tab[data-type="Company"].active {
  background: white;
  border-bottom: 3px solid var(--border-company);
}

.tab[data-type="Project"] {
  background: var(--color-project);
  border-color: var(--border-project);
  color: var(--text-project);
}

.tab[data-type="Project"]:hover {
  background: #ffe0b2;
}

.tab[data-type="Project"].active {
  background: white;
  border-bottom: 3px solid var(--border-project);
}

.tab[data-type="Tool"] {
  background: var(--color-tool);
  border-color: var(--border-tool);
  color: var(--text-tool);
}

.tab[data-type="Tool"]:hover {
  background: #e1bee7;
}

.tab[data-type="Tool"].active {
  background: white;
  border-bottom: 3px solid var(--border-tool);
}

/* Merge tab styles */
.merge-container {
  display: none;
}

.entity-actions {
  display: none;
  align-items: center;
  gap: 1em;
  margin-bottom: 1em;
  flex-wrap: wrap;
}

.entity-search {
  flex: 1 1 220px;
  max-width: 360px;
  padding: 8px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 0.9em;
  transition: border-color 0.2s, box-shadow 0.2s;
}

.entity-search:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.1);
}

.merge-quick-create {
  display: none;
  gap: 0.5em;
  margin-top: 0.75em;
  flex-wrap: wrap;
}

.merge-quick-create.active {
  display: flex;
}

.quick-create-btn {
  border: 1px solid transparent;
  border-radius: 6px;
  padding: 6px 14px;
  font-size: 0.85em;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s, transform 0.2s;
}

.quick-create-btn:hover {
  transform: translateY(-1px);
}

.quick-create-btn[data-entity-type="Person"] {
  background: var(--color-person);
  border-color: var(--border-person);
  color: var(--text-person);
}

.quick-create-btn[data-entity-type="Person"]:hover {
  background: #c8e6c9;
}

.quick-create-btn[data-entity-type="Company"] {
  background: var(--color-company);
  border-color: var(--border-company);
  color: var(--text-company);
}

.quick-create-btn[data-entity-type="Company"]:hover {
  background: #bbdefb;
}

.quick-create-btn[data-entity-type="Project"] {
  background: var(--color-project);
  border-color: var(--border-project);
  color: var(--text-project);
}

.quick-create-btn[data-entity-type="Project"]:hover {
  background: #ffe0b2;
}

.quick-create-btn[data-entity-type="Tool"] {
  background: var(--color-tool);
  border-color: var(--border-tool);
  color: var(--text-tool);
}

.quick-create-btn[data-entity-type="Tool"]:hover {
  background: #e1bee7;
}

.merge-search {
  margin-bottom: 1.5em;
}

.merge-search input {
  width: 100%;
  padding: 0.75em;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 1em;
}

.merge-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 1em;
  margin-top: 1em;
}

.entity-card {
  background: white;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  padding: 1em;
  cursor: move;
  transition: all 0.3s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  position: relative;
}

.entity-card-top {
  border-width: 4px;
  border-style: solid;
  box-shadow: 0 4px 12px rgba(0,0,0,0.25);
  font-weight: 700;
  outline: 2px solid rgba(0,123,255,0.3);
  outline-offset: 2px;
}

.entity-card:hover {
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  transform: translateY(-2px);
}

/* Entity type specific card colors */
.entity-card[data-entity-type="Person"] {
  background: var(--color-person);
  border-color: var(--border-person);
}

.entity-card[data-entity-type="Person"] .entity-card-type {
  color: var(--text-person);
}

.entity-card[data-entity-type="Company"] {
  background: var(--color-company);
  border-color: var(--border-company);
}

.entity-card[data-entity-type="Company"] .entity-card-type {
  color: var(--text-company);
}

.entity-card[data-entity-type="Project"] {
  background: var(--color-project);
  border-color: var(--border-project);
}

.entity-card[data-entity-type="Project"] .entity-card-type {
  color: var(--text-project);
}

.entity-card[data-entity-type="Tool"] {
  background: var(--color-tool);
  border-color: var(--border-tool);
}

.entity-card[data-entity-type="Tool"] .entity-card-type {
  color: var(--text-tool);
}

.entity-card.dragging {
  opacity: 0.5;
  transform: rotate(2deg);
}

.entity-card.drag-over {
  border-color: #007bff;
  background: #e3f2fd;
  transform: scale(1.05);
}

.entity-card-type {
  font-size: 0.8em;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 0.5em;
}

.entity-card-name {
  font-weight: 600;
  color: #333;
  word-break: break-word;
}

.merge-status {
  display: none;
  padding: 1em;
  margin: 1em 0;
  border-radius: 6px;
  background: #d4edda;
  color: #155724;
  border: 1px solid #c3e6cb;
}

.merge-status.error {
  background: #f8d7da;
  color: #721c24;
  border-color: #f5c6cb;
}

.new-entity-btn {
  background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
  color: white;
  border: none;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9em;
  font-weight: 500;
  transition: opacity 0.2s;
  white-space: nowrap;
  display: inline-block;
}

.new-entity-btn:hover {
  opacity: 0.9;
}

/* Generate button styling */
.generate-btn {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  padding: 8px 14px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9em;
  display: flex;
  align-items: center;
  gap: 6px;
  transition: all 0.2s;
}

.generate-btn:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.generate-btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none;
}

.generate-btn.generating {
  background: #999;
}

.generate-btn.generating .generate-icon {
  animation: sparkle 1.5s infinite;
}

@keyframes sparkle {
  0%, 100% { transform: scale(1) rotate(0deg); }
  50% { transform: scale(1.2) rotate(180deg); }
}


/* Modal styling */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
}
.modal-content {
  background-color: white;
  margin: 10% auto;
  border-radius: 8px;
  width: 90%;
  max-width: 1000px;
  max-height: 70vh;
  position: relative;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  overflow: hidden;
}
.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  line-height: 1;
  position: absolute;
  top: 15px;
  right: 20px;
  background: white;
  z-index: 3;
}
.close:hover { color: #000; }
.modal-header {
  padding: 20px 40px 15px 20px;
  border-bottom: 1px solid #e0e0e0;
  background: white;
  border-radius: 8px 8px 0 0;
  display: flex;
  align-items: center;
}
.modal-header h3 { 
  margin: 0; 
  color: #333; 
  cursor: pointer;
  border-radius: 4px;
  padding: 4px;
  transition: background-color 0.2s;
  display: inline-block;
  vertical-align: middle;
}
.modal-header h3:hover {
  background: #f0f0f0;
}
.modal-delete {
  margin-left: auto;
  background: none;
  border: none;
  color: #555;
  cursor: pointer;
  font-size: 1.1em;
  padding: 4px;
  line-height: 1;
}
.modal-delete:hover {
  color: #c0392b;
}
.modal-delete:focus {
  outline: 2px solid #c0392b;
  outline-offset: 2px;
}
.modal-body {
  max-height: calc(70vh - 80px);
  overflow-y: auto;
  padding: 20px;
}
.date-entry {
  margin-bottom: 12px;
  padding: 8px;
  border-left: 3px solid #007bff;
  background: #f8f9fa;
}
.date-entry:first-child {
  margin-top: 0;
}
.date-label {
  font-weight: bold;
  color: #007bff;
  margin-bottom: 4px;
}
.date-desc {
  color: #666;
  font-style: italic;
}

/* New entity modal styles */
.new-entity-modal .modal-content {
  max-width: 500px;
  margin: 15% auto;
}

.form-group {
  margin-bottom: 1.2em;
}

.form-group label {
  display: block;
  margin-bottom: 0.5em;
  font-weight: 500;
  color: #333;
}

.form-group input, .form-group textarea {
  width: 100%;
  padding: 0.6em 0.75em;
  border: 1px solid #ddd;
  border-radius: 6px;
  font-size: 0.95em;
  font-family: inherit;
  transition: border-color 0.2s;
  box-sizing: border-box;
}

.form-group input:focus, .form-group textarea:focus {
  outline: none;
  border-color: #007bff;
}

.form-group textarea {
  resize: vertical;
  min-height: 80px;
}

.form-actions {
  display: flex;
  gap: 0.8em;
  justify-content: flex-end;
  margin-top: 1.5em;
}

.btn {
  padding: 0.6em 1.2em;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.95em;
  font-weight: 500;
  transition: background-color 0.2s;
}

.btn-primary {
  background: #007bff;
  color: white;
}

.btn-primary:hover {
  background: #0056b3;
}

.btn-secondary {
  background: #f5f5f5;
  color: #666;
}

.btn-secondary:hover {
  background: #eee;
}

.error-message {
  background: #fee;
  color: #c33;
  padding: 0.75em;
  border-radius: 6px;
  margin-bottom: 1em;
  border: 1px solid #fcc;
}
</style>
{% endblock %}
{% block body %}
<div class="container">
  <div class="tabs-container">
    <div class="tabs" id="tabs"></div>
  </div>
  <div class="entity-actions" id="entityActions">
    <button class="new-entity-btn" id="newEntityBtn" style="display: none;">+ New Entity</button>
    <input type="text" id="entitySearchInput" class="entity-search" placeholder="Search entities..." autocomplete="off" spellcheck="false">
  </div>
  <table id="entityTable">
    <thead>
      <tr>
        <th class="count">Count</th>
        <th class="name">Name</th>
        <th class="desc">Description</th>
      </tr>
    </thead>
    <tbody id="entities"></tbody>
  </table>
  
  <div id="mergeContainer" class="merge-container">
    <div class="merge-search">
      <input type="text" id="mergeSearchInput" placeholder="Search entities to merge..." />
    </div>
    <div id="mergeQuickCreate" class="merge-quick-create"></div>
    <div id="mergeStatus" class="merge-status"></div>
    <div id="mergeGrid" class="merge-grid"></div>
  </div>
</div>

<!-- Entity Details Modal -->
<div id="entityModal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <div id="modalContent"></div>
  </div>
</div>

<!-- Merge Confirmation Modal -->
<div id="mergeConfirmModal" class="modal">
  <div class="modal-content" style="max-width: 900px; max-height: 85vh; display: flex; flex-direction: column;">
    <span class="close" id="mergeConfirmClose" style="position: absolute; top: 10px; right: 15px; z-index: 1;">&times;</span>
    <div id="mergeDetails" style="flex-shrink: 0;"></div>
    <div class="form-actions" style="flex-shrink: 0; padding: 0 1.5em; margin-top: 1em;">
      <button type="button" class="btn btn-secondary" id="mergeCancelBtn">Cancel</button>
      <button type="button" class="btn btn-primary" id="mergeConfirmBtn">Confirm Merge</button>
    </div>
    <div id="mergeOccurrences" style="flex: 1; overflow-y: auto; padding: 0 1.5em 1.5em 1.5em;"></div>
  </div>
</div>

<!-- New Entity Modal -->
<div id="newEntityModal" class="modal new-entity-modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 id="newEntityModalTitle">Add New Entity</h2>
      <span class="close" id="newEntityClose">&times;</span>
    </div>
    <div id="newEntityErrorContainer"></div>
    <form id="newEntityForm">
      <div class="form-group">
        <label for="entityName">Name</label>
        <input type="text" id="entityName" name="name" required placeholder="Entity name">
      </div>
      <div class="form-group">
        <label for="entityDescription">Description</label>
        <textarea id="entityDescription" name="description" placeholder="Brief description (optional)"></textarea>
      </div>
      <div class="form-actions">
        <button type="button" id="generateEntityDescBtn" class="generate-btn" title="Generate description with AI">
          <span class="generate-icon">✨</span>
          <span class="generate-text">Generate</span>
        </button>
        <button type="submit" class="btn btn-primary" id="newEntitySaveBtn">Create Entity</button>
      </div>
    </form>
  </div>
</div>

<script>
let data = {};
let activeType = null;
let currentItem = null;
let generatingTops = new Set();
let mergeMode = false;
let allEntities = [];
let draggedEntity = null;
let newEntityType = null;
let currentMergeQuery = '';
let entitySearchFilters = {};
const entitySearchInput = document.getElementById('entitySearchInput');
const entityActions = document.getElementById('entityActions');
const newEntityBtn = document.getElementById('newEntityBtn');

if (entitySearchInput) {
  entitySearchInput.addEventListener('input', (event) => {
    if (!activeType) {
      return;
    }
    entitySearchFilters[activeType] = event.target.value;
    renderTable();
  });

  entitySearchInput.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
      event.preventDefault();
      event.stopPropagation();
      event.target.value = '';
      if (activeType) {
        entitySearchFilters[activeType] = '';
        renderTable();
      }
    } else if (event.key === 'Enter') {
      event.preventDefault();
    }
  });
}

if (newEntityBtn) {
  newEntityBtn.addEventListener('click', () => {
    const prefill = entitySearchInput ? entitySearchInput.value : '';
    openNewEntityModal(null, prefill);
  });
}

function reloadTabs() {
  const currentType = activeType;
  const wasMergeMode = mergeMode;
  fetch('{{ url_for('entities.entities_types') }}').then(r => r.json()).then(counts => {
    const tabsDiv = document.getElementById('tabs');
    tabsDiv.innerHTML = '';
    Object.keys(counts).forEach(type => {
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.setAttribute('data-type', type);
      tab.textContent = type;
      tab.onclick = () => showType(type);
      tabsDiv.appendChild(tab);
    });
    
    // Add Merge tab
    const mergeTab = document.createElement('div');
    mergeTab.className = 'tab';
    mergeTab.textContent = 'Merge';
    mergeTab.onclick = () => showMergeTab();
    tabsDiv.appendChild(mergeTab);
    
    const first = Object.keys(counts)[0];
    
    // Check for URL fragment to determine initial tab
    const fragment = parseFragment();
    if (fragment) {
      if (fragment.type === 'merge') {
        showMergeTab(fragment.query, false);
      } else if (counts[fragment.type]) {
        showType(fragment.type, false);
      } else if (wasMergeMode) {
        showMergeTab();
      } else if (currentType && counts[currentType] !== undefined) {
        showType(currentType);
      } else if (first) {
        showType(first);
      }
    } else if (wasMergeMode) {
      showMergeTab();
    } else if (currentType && counts[currentType] !== undefined) {
      showType(currentType);
    } else if (first) {
      showType(first);
    }
    
    // Show new entity button if we have any entity types
    if (newEntityBtn) {
      if (Object.keys(counts).length > 0) {
        newEntityBtn.style.display = 'inline-block';
        if (entityActions) {
          entityActions.style.display = mergeMode ? 'none' : 'flex';
        }
      } else {
        newEntityBtn.style.display = 'none';
        if (entityActions) {
          entityActions.style.display = 'none';
        }
      }
    }
  });
}

// Function to parse URL fragment
function parseFragment() {
  const hash = window.location.hash.substring(1); // Remove #
  if (!hash) return null;
  
  if (hash === 'merge') {
    return { type: 'merge', query: '' };
  }
  
  if (hash.startsWith('merge?q=')) {
    const query = decodeURIComponent(hash.substring(8));
    return { type: 'merge', query };
  }
  
  // Check if it's a valid entity type
  const validTypes = ['person', 'company', 'project', 'tool'];
  if (validTypes.includes(hash.toLowerCase())) {
    // Convert to proper case
    return { type: hash.charAt(0).toUpperCase() + hash.slice(1).toLowerCase() };
  }
  
  return null;
}

// Handle browser back/forward navigation
window.addEventListener('hashchange', () => {
  const fragment = parseFragment();
  if (fragment) {
    if (fragment.type === 'merge') {
      showMergeTab(fragment.query, false);
    } else {
      showType(fragment.type, false);
    }
  }
});

reloadTabs();

function loadType(type) {
  return fetch(`{{ url_for('entities.entities_list') }}?type=${encodeURIComponent(type)}`)
    .then(r => r.json())
    .then(items => { data[type] = items; });
}

function showType(type, updateFragment = true) {
  mergeMode = false;
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.toggle('active', tab.textContent.startsWith(type));
  });
  activeType = type;
  
  // Update URL fragment
  if (updateFragment) {
    window.location.hash = type.toLowerCase();
  }
  
  // Show table, hide merge container
  const table = document.getElementById('entityTable');
  table.style.display = 'table';
  table.setAttribute('data-entity-type', type);
  document.getElementById('mergeContainer').style.display = 'none';
  if (entityActions) {
    entityActions.style.display = 'flex';
  }
  
  // Update new entity button text to show current type
  if (newEntityBtn) {
    newEntityBtn.textContent = `+ New ${type}`;
    newEntityBtn.style.display = 'inline-block';
  }

  if (entitySearchInput) {
    if (!(type in entitySearchFilters)) {
      entitySearchFilters[type] = '';
    }
    entitySearchInput.placeholder = `Search ${type}`;
    entitySearchInput.value = entitySearchFilters[type];
    requestAnimationFrame(() => {
      entitySearchInput.focus();
      entitySearchInput.setSelectionRange(0, entitySearchInput.value.length);
    });
  }
  
  if (!data[type]) {
    loadType(type).then(renderTable);
  } else {
    renderTable();
  }
}

function renderTable() {
  const tbody = document.getElementById('entities');
  tbody.innerHTML = '';
  const items = data[activeType] || [];
  const rawFilter = activeType ? entitySearchFilters[activeType] || '' : '';
  const words = rawFilter.trim().toLowerCase().split(/\s+/).filter(Boolean);
  const filteredItems = words.length === 0
    ? items
    : items.filter(item => {
        const name = (item.name || '').toLowerCase();
        const desc = (item.desc || '').toLowerCase();
        const combined = `${name} ${desc}`;
        return words.every(word => combined.includes(word));
      });
  filteredItems.forEach(item => {
    const tr = document.createElement('tr');
    tr.classList.add('entity-row');

    const countCell = document.createElement('td');
    countCell.classList.add('count');

    const star = document.createElement('span');
    star.classList.add('entity-star');
    if (item.top) {
      star.classList.add('is-top');
      star.textContent = '★';
      star.title = 'Already highlighted';
    } else {
      star.textContent = '☆';
      star.title = 'Add to highlights';
    }

    const countValue = document.createElement('span');
    countValue.classList.add('entity-count-value');
    countValue.textContent = item.count;

    const countWrapper = document.createElement('span');
    countWrapper.classList.add('entity-count');

    star.addEventListener('click', (event) => {
      event.stopPropagation();
      if (item.top) {
        return;
      }
      generateTopEntry(item, star);
    });

    countWrapper.appendChild(star);
    countWrapper.appendChild(countValue);
    countCell.appendChild(countWrapper);

    const nameCell = document.createElement('td');
    nameCell.classList.add('name');
    nameCell.textContent = item.name;

    const descCell = document.createElement('td');
    descCell.classList.add('desc');
    descCell.textContent = item.desc;

    tr.addEventListener('click', (event) => {
      if (event.target.closest('.entity-star')) {
        return;
      }

      if (event.ctrlKey || event.metaKey || event.altKey) {
        event.preventDefault();
        generateTopEntry(item, star);
        return;
      }

      showEntityDetails(item.name);
    });

    tr.appendChild(countCell);
    tr.appendChild(nameCell);
    tr.appendChild(descCell);
    tbody.appendChild(tr);
  });
}

function editName(nameElement, item) {
  const original = item.name;
  nameElement.innerHTML = '';
  nameElement.onclick = null;
  
  const input = document.createElement('input');
  input.type = 'text';
  input.value = original;
  input.style.width = '200px';
  input.style.border = '1px solid #ddd';
  input.style.padding = '4px';
  nameElement.appendChild(input);

  const reset = () => {
    nameElement.innerHTML = original;
    nameElement.onclick = () => editName(nameElement, item);
  };

  const save = () => {
    const newName = input.value.trim();
    if (!newName || newName === original) { reset(); return; }
    
    nameElement.style.opacity = '0.5';
    
    fetch('{{ url_for('entities.entities') }}/api/rename', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type: activeType, name: original, new_name: newName, days: item.raw_dates })
    }).then(() => {
      document.getElementById('entityModal').style.display = 'none';
      reloadTabs();
    });
  };

  // Handle keyboard events
  input.onkeydown = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      save();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      reset();
    }
  };

  // Focus and select the input text
  input.focus();
  input.select();
}

function showEntityDetails(name) {
  fetch(`{{ url_for('entities.entities_details') }}?type=${activeType}&name=${encodeURIComponent(name)}`)
    .then(r => r.json())
    .then(item => {
      if (!item) return;
      currentItem = item;
      const modal = document.getElementById('entityModal');
      const content = document.getElementById('modalContent');
      let html = `
        <div class="modal-header">
          <h3 id="modalEntityName">${name}</h3>
          <button type="button" class="modal-delete" id="modalDelete" title="Delete entity" aria-label="Delete entity">&#128465;</button>
        </div>
        <div class="modal-body">`;
      item.dates.forEach(date => {
        const desc = item.descriptions && item.descriptions[date] ? item.descriptions[date] : 'No description';
        html += `
          <div class="date-entry">
            <div class="date-label">${date}</div>
            <div class="date-desc">${desc}</div>
          </div>
        `;
      });
      html += '</div>';
      content.innerHTML = html;
      document.getElementById('modalEntityName').onclick = () => {
        editName(document.getElementById('modalEntityName'), item);
      };
      document.getElementById('modalDelete').onclick = () => {
        if (!confirm(`Delete ${name}?`)) return;
        modal.style.display = 'none';
        fetch('{{ url_for('entities.entities') }}/api/remove', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type: activeType, name: name, days: item.raw_dates })
        }).then(() => {
          reloadTabs();
        });
      };
      modal.style.display = 'block';
    });
}


// Modal close functionality
document.querySelector('.close').onclick = function() {
  document.getElementById('entityModal').style.display = 'none';
};

window.onclick = function(event) {
  const modal = document.getElementById('entityModal');
  if (event.target == modal) {
    modal.style.display = 'none';
  }
};

// Generate a top summary inline (used by star clicks and modifier row clicks)
async function generateTopEntry(item, starEl) {
  if (!item || item.top) {
    return;
  }

  const name = item.name;
  if (generatingTops.has(name)) {
    return;
  }

  generatingTops.add(name);

  const originalStarText = starEl.textContent;
  const originalTitle = starEl.getAttribute('title');

  starEl.classList.add('is-loading');
  starEl.textContent = '⏳';
  starEl.setAttribute('title', 'Generating summary...');

  try {
    const generateResponse = await fetch('{{ url_for('entities.entities') }}/api/top_generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type: activeType, name })
    });

    const res = await generateResponse.json();

    if (res.error) {
      throw new Error(res.error);
    }

    await fetch('{{ url_for('entities.entities') }}/api/top_update', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ type: activeType, name, desc: res.desc })
    });

    starEl.classList.remove('is-loading');
    starEl.classList.add('is-top');
    starEl.textContent = '★';
    starEl.setAttribute('title', 'Already highlighted');
    item.top = true;
    reloadTabs();
  } catch (err) {
    console.error('Error generating top entry for', name, ':', err);
    starEl.classList.remove('is-loading');
    starEl.classList.remove('is-top');
    starEl.textContent = originalStarText;
    if (originalTitle) {
      starEl.setAttribute('title', originalTitle);
    } else {
      starEl.removeAttribute('title');
    }
  } finally {
    generatingTops.delete(name);
  }
}

// New Entity Modal functionality
function openNewEntityModal(typeOverride = null, namePrefill = '') {
  const modal = document.getElementById('newEntityModal');
  const title = document.getElementById('newEntityModalTitle');
  const saveBtn = document.getElementById('newEntitySaveBtn');
  const form = document.getElementById('newEntityForm');
  const type = typeOverride || activeType;

  newEntityType = type;

  title.textContent = type ? `Add New ${type}` : 'Add New Entity';
  if (saveBtn) {
    saveBtn.textContent = type ? `Create ${type}` : 'Create Entity';
  }

  // Reset form
  form.reset();
  clearNewEntityErrors();

  const nameInput = document.getElementById('entityName');
  const descriptionInput = document.getElementById('entityDescription');
  if (namePrefill) {
    nameInput.value = namePrefill;
  }
  if (descriptionInput) {
    descriptionInput.value = '';
  }

  modal.style.display = 'block';
  nameInput.focus();
  nameInput.select();
}

function closeNewEntityModal() {
  const modal = document.getElementById('newEntityModal');
  modal.style.display = 'none';
  document.getElementById('newEntityForm').reset();
  clearNewEntityErrors();
  newEntityType = null;
}

function clearNewEntityErrors() {
  const errorContainer = document.getElementById('newEntityErrorContainer');
  errorContainer.innerHTML = '';
}

function showNewEntityError(message) {
  const errorContainer = document.getElementById('newEntityErrorContainer');
  errorContainer.innerHTML = `<div class="error-message">${message}</div>`;
}

// New Entity Modal event handlers
document.getElementById('newEntityClose').onclick = closeNewEntityModal;

// Generate entity description button handler
document.getElementById('generateEntityDescBtn').onclick = async function() {
  const entityName = document.getElementById('entityName').value.trim();
  const resolvedType = newEntityType || activeType;

  if (!entityName) {
    showNewEntityError('Please enter an entity name first');
    return;
  }

  if (!resolvedType) {
    showNewEntityError('Entity type is required');
    return;
  }

  const btn = this;
  const generateText = btn.querySelector('.generate-text');
  const descriptionTextarea = document.getElementById('entityDescription');

  // Disable button and show generating state
  btn.disabled = true;
  btn.classList.add('generating');
  generateText.textContent = 'Generating...';

  try {
    const response = await fetch('{{ url_for('entities.entities') }}/api/generate-description', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        type: resolvedType,
        name: entityName
      })
    });

    const data = await response.json();

    if (response.ok && data.success) {
      // Update the description field
      descriptionTextarea.value = data.description;
    } else {
      showNewEntityError(data.error || 'Failed to generate description');
    }
  } catch (error) {
    console.error('Error generating description:', error);
    showNewEntityError('Failed to generate description: ' + error.message);
  } finally {
    // Re-enable button and reset state
    btn.disabled = false;
    btn.classList.remove('generating');
    generateText.textContent = 'Generate';
  }
};

// Merge Confirmation Modal event handlers
document.getElementById('mergeConfirmClose').onclick = function() {
  document.getElementById('mergeConfirmModal').style.display = 'none';
  window.pendingMerge = null;
};

document.getElementById('mergeCancelBtn').onclick = function() {
  document.getElementById('mergeConfirmModal').style.display = 'none';
  window.pendingMerge = null;
};

document.getElementById('mergeConfirmBtn').onclick = function() {
  if (window.pendingMerge) {
    performMerge(window.pendingMerge.source, window.pendingMerge.target);
  }
};

window.addEventListener('click', function(event) {
  const newEntityModal = document.getElementById('newEntityModal');
  const mergeModal = document.getElementById('mergeConfirmModal');
  if (event.target === newEntityModal) {
    closeNewEntityModal();
  } else if (event.target === mergeModal) {
    mergeModal.style.display = 'none';
    window.pendingMerge = null;
  }
});

function updateMergeQuickCreate(query) {
  const container = document.getElementById('mergeQuickCreate');
  if (!container) {
    return;
  }

  const trimmed = query.trim();
  if (!trimmed) {
    container.innerHTML = '';
    container.classList.remove('active');
    return;
  }

  const types = ['Person', 'Company', 'Project', 'Tool'];
  container.innerHTML = types
    .map(
      (type) =>
        `<button type="button" class="quick-create-btn" data-entity-type="${type}">+ New ${type}</button>`
    )
    .join('');
  container.classList.add('active');
}

const mergeQuickCreateContainer = document.getElementById('mergeQuickCreate');
if (mergeQuickCreateContainer) {
  mergeQuickCreateContainer.addEventListener('click', (event) => {
    const target = event.target;
    if (target && target.classList.contains('quick-create-btn')) {
      const type = target.getAttribute('data-entity-type');
      openNewEntityModal(type, currentMergeQuery);
    }
  });
}

// Merge tab functionality
function showMergeTab(query = '', updateFragment = true) {
  mergeMode = true;
  document.querySelectorAll('.tab').forEach(tab => {
    tab.classList.toggle('active', tab.textContent === 'Merge');
  });
  
  // Update URL fragment
  if (updateFragment) {
    if (query) {
      window.location.hash = `merge?q=${encodeURIComponent(query)}`;
    } else {
      window.location.hash = 'merge';
    }
  }
  
  // Hide table, show merge container
  document.getElementById('entityTable').style.display = 'none';
  document.getElementById('mergeContainer').style.display = 'block';
  if (newEntityBtn) {
    newEntityBtn.style.display = 'none';
  }
  if (entityActions) {
    entityActions.style.display = 'none';
  }
  if (entitySearchInput) {
    entitySearchInput.blur();
  }
  
  // Set the search input and run search if query provided
  const searchInput = document.getElementById('mergeSearchInput');
  if (query) {
    searchInput.value = query;
    // Trigger search
    searchInput.dispatchEvent(new Event('input'));
  } else {
    // Clear the search input and grid when switching to merge tab
    searchInput.value = '';
    document.getElementById('mergeGrid').innerHTML = '';
    allEntities = [];
    currentMergeQuery = '';
    updateMergeQuickCreate('');
  }
  
  // Auto-focus the search input
  searchInput.focus();
}


function renderMergeGrid(entities) {
  const grid = document.getElementById('mergeGrid');
  grid.innerHTML = '';
  
  // Sort entities: top entities first, then non-top entities
  const sortedEntities = entities.sort((a, b) => {
    // Top entities come first
    if (a.top && !b.top) return -1;
    if (!a.top && b.top) return 1;
    // Within same top status, sort alphabetically by name
    return a.name.localeCompare(b.name);
  });
  
  sortedEntities.forEach(entity => {
    const card = document.createElement('div');
    card.className = entity.top ? 'entity-card entity-card-top' : 'entity-card';
    card.draggable = true;
    card.dataset.entityType = entity.type;
    card.dataset.entityName = entity.name;
    
    // Get description for native tooltip
    const description = entity.text && entity.text !== entity.name ? entity.text : 'No description available';
    card.title = description;
    
    // Create card content
    card.innerHTML = `
      <div class="entity-card-type">${entity.type}</div>
      <div class="entity-card-name">${entity.name}</div>
    `;
    
    // Drag event handlers
    card.addEventListener('dragstart', handleDragStart);
    card.addEventListener('dragend', handleDragEnd);
    card.addEventListener('dragover', handleDragOver);
    card.addEventListener('drop', handleDrop);
    card.addEventListener('dragenter', handleDragEnter);
    card.addEventListener('dragleave', handleDragLeave);
    
    grid.appendChild(card);
  });
}

function handleDragStart(e) {
  draggedEntity = {
    type: e.target.dataset.entityType,
    name: e.target.dataset.entityName
  };
  e.target.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
}

function handleDragEnd(e) {
  e.target.classList.remove('dragging');
  // Clean up any lingering drag-over states
  document.querySelectorAll('.entity-card.drag-over').forEach(card => {
    card.classList.remove('drag-over');
  });
  draggedEntity = null;
}

function handleDragOver(e) {
  if (e.preventDefault) {
    e.preventDefault();
  }
  e.dataTransfer.dropEffect = 'move';
  
  // Ensure the drag-over class is maintained while dragging over the element
  if (draggedEntity && e.currentTarget.dataset.entityName !== draggedEntity.name) {
    if (!e.currentTarget.classList.contains('drag-over')) {
      e.currentTarget.classList.add('drag-over');
    }
  }
  
  return false;
}

function handleDragEnter(e) {
  // Prevent event from bubbling to avoid issues with child elements
  e.preventDefault();
  e.stopPropagation();
  
  if (draggedEntity && e.currentTarget.dataset.entityName !== draggedEntity.name) {
    e.currentTarget.classList.add('drag-over');
  }
}

function handleDragLeave(e) {
  // Prevent event from bubbling
  e.stopPropagation();
  
  // Only remove drag-over if we're actually leaving the element
  // Check if the related target is not a child of the current element
  const rect = e.currentTarget.getBoundingClientRect();
  const x = e.clientX;
  const y = e.clientY;
  
  // Check if cursor is still within the bounds of the current element
  if (x < rect.left || x >= rect.right || y < rect.top || y >= rect.bottom) {
    e.currentTarget.classList.remove('drag-over');
  }
}

async function handleDrop(e) {
  if (e.stopPropagation) {
    e.stopPropagation();
  }
  
  e.currentTarget.classList.remove('drag-over');
  
  const targetEntity = {
    type: e.currentTarget.dataset.entityType,
    name: e.currentTarget.dataset.entityName
  };
  
  if (draggedEntity && targetEntity.name !== draggedEntity.name) {
    // Show confirmation modal instead of directly merging
    showMergeConfirmation(draggedEntity, targetEntity);
  }
  
  return false;
}

async function showMergeConfirmation(source, target) {
  // First, fetch entity details to get all occurrences with descriptions
  let occurrences = [];
  try {
    const response = await fetch(`{{ url_for('search.search_entities_api') }}?type=${encodeURIComponent(source.type)}&name=${encodeURIComponent(source.name)}&limit=1000&order=day`);
    const data = await response.json();
    // Get day-specific occurrences (not the aggregated entry)
    // The API returns appearance=true for day-specific occurrences and includes day directly in the result
    occurrences = data.results.filter(r => r.appearance === true && r.day);
  } catch (error) {
    console.error('Error fetching entity details:', error);
  }
  
  // Build confirmation message
  const detailsDiv = document.getElementById('mergeDetails');
  detailsDiv.innerHTML = `
    <div style="padding: 1em; background: #f8f9fa; border-radius: 8px;">
      <p style="margin-bottom: 1em;"><strong>This will merge:</strong></p>
      <div style="display: flex; align-items: center; gap: 2em; margin-bottom: 1em;">
        <div style="flex: 1; padding: 1em; background: white; border: 2px solid #dc3545; border-radius: 6px;">
          <div style="font-size: 0.9em; color: #666; margin-bottom: 0.5em;">${source.type}</div>
          <div style="font-weight: 600; color: #333;">${source.name}</div>
        </div>
        <div style="font-size: 1.5em;">→</div>
        <div style="flex: 1; padding: 1em; background: white; border: 2px solid #28a745; border-radius: 6px;">
          <div style="font-size: 0.9em; color: #666; margin-bottom: 0.5em;">${target.type}</div>
          <div style="font-weight: 600; color: #333;">${target.name}</div>
        </div>
      </div>
      <p style="margin: 0; color: #666; font-size: 0.9em;">All checked references below will be replaced with "${target.type}: ${target.name}"</p>
    </div>
  `;
  
  // Build occurrences list with checkboxes
  const occurrencesDiv = document.getElementById('mergeOccurrences');
  if (occurrences.length > 0) {
    // Format dates for display
    const formatDate = (dateStr) => {
      try {
        const year = dateStr.substring(0, 4);
        const month = dateStr.substring(4, 6);
        const day = dateStr.substring(6, 8);
        const date = new Date(year, month - 1, day);
        const options = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
      } catch (e) {
        return dateStr;
      }
    };
    
    let occurrencesHtml = `
      <div style="display: flex; justify-content: space-between; align-items: center; margin: 1em 0; padding-top: 1em; border-top: 1px solid #eee;">
        <h3 style="margin: 0; font-size: 1.1em;">Select occurrences to merge (${occurrences.length} total)</h3>
        <label style="cursor: pointer; color: #007bff;">
          <input type="checkbox" id="selectAllOccurrences" checked style="margin-right: 0.5em;">
          Select All
        </label>
      </div>
      <div style="border: 1px solid #ddd; border-radius: 8px;">
    `;
    
    occurrences.forEach((occ, index) => {
      const day = occ.day;  // Day is directly on the result object, not in metadata
      const description = occ.text && occ.text !== source.name ? occ.text : '(no description)';
      const isLast = index === occurrences.length - 1;
      occurrencesHtml += `
        <div style="padding: 0.75em 1em; ${!isLast ? 'border-bottom: 1px solid #f0f0f0;' : ''} display: flex; align-items: start;">
          <input type="checkbox" class="occurrence-checkbox" data-day="${day}" checked style="margin-right: 1em; margin-top: 0.25em;">
          <div style="flex: 1;">
            <div style="font-weight: 500; color: #333; margin-bottom: 0.25em;">${formatDate(day)}</div>
            <div style="color: #666; font-style: italic; font-size: 0.9em;">${description}</div>
          </div>
        </div>
      `;
    });
    
    occurrencesHtml += `
      </div>
    `;
    occurrencesDiv.innerHTML = occurrencesHtml;
    
    // Add select all functionality
    document.getElementById('selectAllOccurrences').addEventListener('change', (e) => {
      const checkboxes = document.querySelectorAll('.occurrence-checkbox');
      checkboxes.forEach(cb => cb.checked = e.target.checked);
    });
    
    // Update select all when individual checkboxes change
    occurrencesDiv.addEventListener('change', (e) => {
      if (e.target.classList.contains('occurrence-checkbox')) {
        const checkboxes = document.querySelectorAll('.occurrence-checkbox');
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        const someChecked = Array.from(checkboxes).some(cb => cb.checked);
        const selectAll = document.getElementById('selectAllOccurrences');
        selectAll.checked = allChecked;
        selectAll.indeterminate = !allChecked && someChecked;
      }
    });
  } else {
    occurrencesDiv.innerHTML = `
      <div style="padding: 1em; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; color: #856404;">
        No occurrences found for "${source.type}: ${source.name}" in daily entries.
      </div>
    `;
  }
  
  // Store entities and occurrences for later use
  window.pendingMerge = { source, target, occurrences };
  
  // Show modal
  const modal = document.getElementById('mergeConfirmModal');
  modal.style.display = 'block';
  
  // Enable confirm button
  const confirmBtn = document.getElementById('mergeConfirmBtn');
  confirmBtn.disabled = false;
  confirmBtn.textContent = 'Confirm Merge';
}

async function performMerge(source, target) {
  const confirmBtn = document.getElementById('mergeConfirmBtn');
  const modal = document.getElementById('mergeConfirmModal');
  
  // Get selected days from checkboxes
  const selectedDays = [];
  const checkboxes = document.querySelectorAll('.occurrence-checkbox:checked');
  checkboxes.forEach(cb => {
    selectedDays.push(cb.dataset.day);
  });
  
  // Disable button and show processing state
  confirmBtn.disabled = true;
  confirmBtn.textContent = 'Merging...';
  
  try {
    // Call the backend merge endpoint with selected days
    const response = await fetch('{{ url_for('entities.entities') }}/api/merge', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        source_type: source.type,
        source_name: source.name,
        target_type: target.type,
        target_name: target.name,
        days: selectedDays
      })
    });
    
    const result = await response.json();
    
    // Close modal
    modal.style.display = 'none';
    
    const statusDiv = document.getElementById('mergeStatus');
    statusDiv.style.display = 'block';
    
    if (response.ok) {
      statusDiv.className = 'merge-status';
      statusDiv.textContent = `Successfully merged "${source.type}: ${source.name}" into "${target.type}: ${target.name}"`;
      
      // Re-run the current search after merge
      setTimeout(() => {
        statusDiv.style.display = 'none';
        const searchInput = document.getElementById('mergeSearchInput');
        if (searchInput.value.trim().length >= 2) {
          // Trigger the search again to refresh results
          searchInput.dispatchEvent(new Event('input'));
        } else {
          // Clear the grid if no valid search
          document.getElementById('mergeGrid').innerHTML = '';
          allEntities = [];
        }
      }, 3000);
    } else {
      statusDiv.className = 'merge-status error';
      statusDiv.textContent = result.error || 'Error performing merge';
      setTimeout(() => {
        statusDiv.style.display = 'none';
      }, 5000);
    }
  } catch (error) {
    // Close modal
    modal.style.display = 'none';
    
    const statusDiv = document.getElementById('mergeStatus');
    statusDiv.className = 'merge-status error';
    statusDiv.style.display = 'block';
    statusDiv.textContent = 'Network error occurred during merge';
    console.error('Merge error:', error);
    setTimeout(() => {
      statusDiv.style.display = 'none';
    }, 5000);
  } finally {
    // Reset button state
    confirmBtn.disabled = false;
    confirmBtn.textContent = 'Confirm Merge';
  }
}

// Search functionality for merge tab
document.getElementById('mergeSearchInput').addEventListener('input', async (e) => {
  const query = e.target.value.trim();
  currentMergeQuery = query;
  updateMergeQuickCreate(query);
  
  // Update URL fragment with search query
  if (mergeMode) {
    if (query) {
      window.location.hash = `merge?q=${encodeURIComponent(query)}`;
    } else {
      window.location.hash = 'merge';
    }
  }
  
  if (query.length === 0) {
    // Clear the grid when search is empty
    document.getElementById('mergeGrid').innerHTML = '';
    allEntities = [];
    return;
  }
  
  if (query.length < 2) {
    return; // Wait for at least 2 characters
  }
  
  try {
    const response = await fetch(`{{ url_for('search.search_entities_api') }}?name=${encodeURIComponent(query)}&limit=100`);
    const data = await response.json();
    const filtered = data.results.filter(e => !e.appearance);
    allEntities = filtered; // Store the search results
    renderMergeGrid(filtered);
  } catch (error) {
    console.error('Search error:', error);
  }
});

// New Entity Form submission
document.getElementById('newEntityForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  clearNewEntityErrors();
  
  const formData = new FormData(e.target);
  const formType = newEntityType || activeType;
  const data = {
    type: formType,
    name: formData.get('name').trim(),
    description: formData.get('description').trim()
  };

  if (!data.type) {
    showNewEntityError('Entity type is required');
    return;
  }
  
  if (!data.name) {
    showNewEntityError('Entity name is required');
    return;
  }
  
  try {
    const response = await fetch('{{ url_for('entities.entities') }}/api/create', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data)
    });
    
    const result = await response.json();
    
    if (response.ok && result.success) {
      closeNewEntityModal();
      reloadTabs(); // Reload to update counts and entity list
    } else {
      showNewEntityError(result.error || 'An error occurred creating the entity');
    }
  } catch (error) {
    console.error('Error creating entity:', error);
    showNewEntityError('Network error occurred');
  }
});
</script>
{% endblock %}
