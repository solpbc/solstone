{% extends 'base.html' %}
{% set title = 'Agents' %}
{% set active = 'agents' %}
{% block head %}
<style>
.container { padding: 0 1em; }

/* Tab Navigation */
.tab-nav {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 2rem;
  border-bottom: 2px solid #e0e0e0;
  padding-bottom: 0;
}

.tab-button {
  padding: 0.75rem 1.5rem;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  color: #666;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: -2px;
}

.tab-button:hover {
  color: #007bff;
  background: #f8f9ff;
}

.tab-button.active {
  color: #007bff;
  border-bottom-color: #007bff;
  font-weight: 500;
}

/* Tab Content */
.tab-container {
  min-height: 400px;
}

.main-tab-content {
  display: none;
  animation: fadeIn 0.3s ease;
}

.main-tab-content.active {
  display: block;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Agent Cards */
.agent-cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1rem;
  margin-bottom: 2rem;
}

.agent-card {
  background: white;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  padding: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
}

.agent-card:hover {
  border-color: #007bff;
  box-shadow: 0 2px 8px rgba(0, 123, 255, 0.1);
}

.agent-card .chat-link {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  font-size: 1.5rem;
  text-decoration: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  background: white;
  border-radius: 4px;
  padding: 0.2rem 0.4rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.agent-card:hover .chat-link {
  opacity: 1;
}

.agent-card .chat-link:hover {
  transform: scale(1.1);
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.agent-card.selected {
  border-color: #007bff;
  background: #f8f9ff;
  box-shadow: 0 0 0 1px #007bff;
}

.agent-card.disabled {
  opacity: 0.6;
  background: #f8f8f8;
}

.agent-card h3 {
  margin: 0 0 0.5rem 0;
  font-size: 1.1rem;
  color: #333;
}

.agent-card p {
  margin: 0;
  color: #666;
  font-size: 0.9rem;
  line-height: 1.4;
}

/* Agent metadata badges */
.agent-metadata {
  display: flex;
  flex-wrap: wrap;
  gap: 0.3rem;
  margin-top: 0.5rem;
}

.metadata-badge {
  display: inline-flex;
  align-items: center;
  gap: 0.2rem;
  padding: 0.2rem 0.5rem;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 500;
  background: #f0f0f0;
  color: #555;
}

.metadata-badge.schedule {
  background: #e3f2fd;
  color: #1976d2;
}

.metadata-badge.priority {
  background: #fff3e0;
  color: #f57c00;
}

.metadata-badge.multi-domain {
  background: #f3e5f5;
  color: #7b1fa2;
}

.metadata-badge.tools {
  background: #e8f5e9;
  color: #388e3c;
}

.metadata-badge.backend {
  background: #fce4ec;
  color: #c2185b;
}

.metadata-badge .badge-icon {
  font-size: 0.9rem;
}

/* Create Agent Card */
.create-agent-card {
  background: #f8f9ff;
  border: 2px dashed #007bff;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 80px;
}

.create-agent-card:hover {
  background: #e8ecff;
  border-style: solid;
}

.create-agent-card h3 {
  color: #007bff;
  margin: 0;
  font-size: 1.2rem;
}

/* Topic card with colored indicator */
.topic-indicator {
  display: inline-block;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  margin-right: 0.5rem;
  vertical-align: middle;
}

/* Input Form */
.input-area {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 2rem;
}

.input-area textarea {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-family: inherit;
  resize: vertical;
}

.input-area button {
  padding: 0.75rem 1.5rem;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1.2rem;
  align-self: flex-start;
}

.input-area button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.input-area button:hover:not(:disabled) {
  background: #0056b3;
}

.input-area.busy {
  position: relative;
}

.input-area.busy::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.8);
  cursor: wait;
  z-index: 10;
}

.input-area.busy textarea,
.input-area.busy button {
  pointer-events: none;
}

.planning-status {
  margin-top: 0.5rem;
  padding: 0.5rem;
  background: #e3f2fd;
  border: 1px solid #90caf9;
  border-radius: 4px;
  font-size: 0.9rem;
  display: none;
}

.planning-status.show {
  display: block;
}

.selection-status {
  font-size: 0.9rem;
  color: #666;
  margin-bottom: 1rem;
}

.selection-status.required {
  color: #dc3545;
  font-weight: 500;
}

/* Session History Table */
table { 
  border-collapse: collapse; 
  width: 100%; 
  margin-top: 2rem;
}
th, td { 
  padding: 4px 8px; 
  border-bottom: 1px solid #ddd; 
  white-space: nowrap; 
  text-align: left;
}
th {
  font-weight: 600;
  background-color: #f8f9fa;
}
/* Adjust column widths */
td:nth-child(1), th:nth-child(1) { /* Status */
  width: 100px;
}
td:nth-child(2), th:nth-child(2) { /* Started */
  width: 120px;
}
td:nth-child(3), th:nth-child(3) { /* Runtime */
  width: 80px;
  text-align: right;
}
td:nth-child(4), th:nth-child(4) { /* Model */
  width: 150px;
}
td:nth-child(5), th:nth-child(5) { /* Agent */
  width: 180px;
}
td:last-child { /* Prompt */
  overflow: hidden; 
  text-overflow: ellipsis;
  max-width: 0;
}
tr:hover {
  background-color: #f8f9fa;
}
tr a {
  color: #007bff;
  text-decoration: none;
}
tr a:hover {
  text-decoration: underline;
}

/* Status indicators */
.status-badge {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: uppercase;
  margin-right: 0.5rem;
}

.status-running {
  background-color: #d4edda;
  color: #155724;
}

.status-finished {
  background-color: #d1ecf1;
  color: #0c5460;
}

.status-error {
  background-color: #f8d7da;
  color: #721c24;
}

.status-interrupted {
  background-color: #fff3cd;
  color: #856404;
}

.status-unknown {
  background-color: #e2e3e5;
  color: #383d41;
}

/* Section headers for agent log */
.section-header {
  margin: 2rem 0 1rem 0;
  padding: 0.5rem 0;
  border-bottom: 2px solid #007bff;
  font-size: 1.1rem;
  font-weight: 500;
  color: #333;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.section-header .count {
  font-size: 0.9rem;
  font-weight: normal;
  color: #666;
  background: #f8f9fa;
  padding: 2px 8px;
  border-radius: 12px;
}

.empty-state {
  text-align: center;
  padding: 2rem;
  color: #666;
  font-style: italic;
}

/* Pagination */
.pagination {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;
  margin-top: 1rem;
  padding: 1rem;
}

.pagination button {
  padding: 0.5rem 1rem;
  border: 1px solid #ddd;
  background: white;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.pagination button:hover:not(:disabled) {
  background: #007bff;
  color: white;
  border-color: #007bff;
}

.pagination button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.pagination .page-info {
  margin: 0 1rem;
  font-size: 0.9rem;
  color: #666;
}

/* Modal Styling (reused from entities.html) */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
}

.modal-content {
  background-color: white;
  margin: 5% auto;
  border-radius: 8px;
  width: 90%;
  max-width: 800px;
  max-height: 80vh;
  position: relative;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  overflow: hidden;
}

.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  line-height: 1;
  position: absolute;
  top: 15px;
  right: 20px;
  background: white;
  z-index: 3;
}

.close:hover { 
  color: #000; 
}

.modal-header {
  padding: 20px 40px 15px 20px;
  border-bottom: 1px solid #e0e0e0;
  background: white;
  border-radius: 8px 8px 0 0;
}

.modal-header h3 { 
  margin: 0; 
  color: #333; 
}

.modal-body {
  max-height: calc(80vh - 80px);
  overflow-y: auto;
  padding: 20px;
}

.modal-body .markdown-content h1,
.modal-body .markdown-content h2,
.modal-body .markdown-content h3,
.modal-body .markdown-content h4,
.modal-body .markdown-content h5,
.modal-body .markdown-content h6 {
  margin-top: 1.5rem;
  margin-bottom: 0.75rem;
  color: #333;
}

.modal-body .markdown-content p {
  margin-bottom: 1rem;
  line-height: 1.6;
}

.modal-body .markdown-content ul,
.modal-body .markdown-content ol {
  margin-bottom: 1rem;
  padding-left: 2rem;
}

.modal-body .markdown-content code {
  background: #f8f9fa;
  padding: 0.2rem 0.4rem;
  border-radius: 3px;
  font-family: 'Courier New', monospace;
}

.modal-body .markdown-content pre {
  background: #f8f9fa;
  padding: 1rem;
  border-radius: 4px;
  overflow-x: auto;
  margin-bottom: 1rem;
}

/* Planning Modal Tabs */
.modal-tabs {
  display: flex;
  border-bottom: 1px solid #e0e0e0;
  margin: -20px -20px 20px -20px;
  background: #f8f9fa;
}

.modal-tab {
  padding: 12px 20px;
  cursor: pointer;
  border: none;
  background: none;
  font-size: 0.9rem;
  color: #666;
  transition: all 0.2s ease;
  flex: 1;
  text-align: center;
}

.modal-tab:hover {
  background: #e9ecef;
  color: #333;
}

.modal-tab.active {
  color: #007bff;
  background: white;
  border-bottom: 2px solid #007bff;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

.prompt-editor {
  width: 100%;
  min-height: 400px;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 1rem;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 0.9rem;
  line-height: 1.4;
  resize: vertical;
}

.config-section {
  margin-bottom: 1.5rem;
}

.config-section label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: #333;
}

.config-section select,
.config-section input {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 0.9rem;
}

.start-agent-btn {
  background: #28a745;
  color: white;
  border: none;
  padding: 0.75rem 2rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
  margin-top: 1rem;
}

.start-agent-btn:hover {
  background: #218838;
}

.start-agent-btn:disabled {
  background: #6c757d;
  cursor: not-allowed;
}

/* Item Modal Styles - 80% viewport */
#itemModal .modal-content {
  width: 80vw;
  height: 80vh;
  max-width: 1400px;
  margin: 2.5% auto;
  display: flex;
  flex-direction: column;
}

#itemModal .modal-body {
  flex: 1;
  overflow-y: auto;
  padding: 1.5rem;
}

/* Create Agent Modal Styles */
#createPersonaModal .modal-content {
  max-width: 700px;
}

#personaTitle {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;
  margin-bottom: 1rem;
}

.prompt-content {
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  padding: 1rem;
  margin: 1rem 0;
  max-height: 400px;
  overflow-y: auto;
  white-space: pre-wrap;
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 0.9rem;
}

.modal-actions {
  display: flex;
  gap: 1rem;
  margin-top: 1rem;
}

.modal-actions button {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
}

.modal-actions button:first-child {
  background: #28a745;
  color: white;
}

.modal-actions button:first-child:hover {
  background: #218838;
}

.modal-actions button:last-child {
  background: #6c757d;
  color: white;
}

.modal-actions button:last-child:hover {
  background: #545b62;
}

/* Edit Mode Styles */
.edit-btn, .toggle-btn {
  position: absolute;
  top: 20px;
  background: #007bff;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  z-index: 3;
}

.edit-btn {
  right: 60px;
}

.toggle-btn {
  right: 120px;
  background: #6c757d;
}

.toggle-btn:hover {
  background: #545b62;
}

.toggle-btn.enable {
  background: #28a745;
}

.toggle-btn.enable:hover {
  background: #218838;
}

.edit-btn:hover {
  background: #0056b3;
}

.edit-btn.save-mode {
  background: #28a745;
  position: static;
  margin-left: 1rem;
  flex-shrink: 0;
}

.edit-btn.save-mode:hover {
  background: #218838;
}

.modal-header.edit-mode {
  display: flex;
  align-items: center;
  padding-right: 60px;
}

.edit-mode-input {
  flex: 1;
  padding: 0.5rem;
  font-size: 1.1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-weight: 500;
  margin: 0;
}

.edit-mode-textarea {
  width: 100%;
  min-height: 400px;
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 0.9rem;
  line-height: 1.5;
  resize: vertical;
}

/* Tools Tab Styles */
.tools-container {
  padding: 1rem 0;
}

.tools-header {
  margin-bottom: 2rem;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.tools-search {
  width: 100%;
  max-width: 400px;
  padding: 0.75rem 1rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: 1rem;
  transition: border-color 0.2s;
}

.tools-search:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0,123,255,0.1);
}

.pack-filters {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.pack-filter-btn {
  padding: 0.5rem 1rem;
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 20px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.9rem;
}

.pack-filter-btn:hover {
  background: #e9ecef;
  border-color: #adb5bd;
}

.pack-filter-btn.active {
  background: #007bff;
  color: white;
  border-color: #007bff;
}

.pack-filter-btn .count {
  margin-left: 0.3rem;
  font-size: 0.85rem;
  opacity: 0.8;
}

.tools-grid {
  display: grid;
  gap: 1.5rem;
  animation: fadeIn 0.3s ease;
}

.tool-card {
  background: white;
  border: 1px solid #e0e0e0;
  border-radius: 12px;
  padding: 1.5rem;
  transition: all 0.2s ease;
  position: relative;
}

.tool-card:hover {
  border-color: #007bff;
  box-shadow: 0 4px 12px rgba(0,123,255,0.1);
  transform: translateY(-2px);
}

.tool-card.hidden {
  display: none;
}

.tool-header {
  display: flex;
  align-items: start;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.tool-name {
  font-size: 1.2rem;
  font-weight: 600;
  color: #333;
  margin: 0;
}

.tool-packs {
  display: flex;
  gap: 0.3rem;
  flex-wrap: wrap;
}

.tool-pack-badge {
  display: inline-block;
  padding: 0.2rem 0.6rem;
  background: #e3f2fd;
  color: #1976d2;
  border-radius: 12px;
  font-size: 0.75rem;
  font-weight: 500;
}

.tool-description {
  color: #666;
  line-height: 1.6;
  margin-bottom: 1rem;
}

.tool-params {
  border-top: 1px solid #e0e0e0;
  padding-top: 1rem;
  margin-top: auto;
}

.tool-params-title {
  font-size: 0.9rem;
  font-weight: 600;
  color: #555;
  margin-bottom: 0.5rem;
}

.param-list {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.param-item {
  display: flex;
  align-items: start;
  gap: 0.5rem;
  font-size: 0.9rem;
}

.param-name {
  font-family: 'Monaco', 'Menlo', monospace;
  background: #f8f9fa;
  padding: 0.2rem 0.5rem;
  border-radius: 4px;
  color: #d63384;
  white-space: nowrap;
}

.param-required {
  color: #dc3545;
  font-weight: 600;
}

.param-optional {
  color: #6c757d;
  font-style: italic;
}

.param-type {
  color: #0969da;
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 0.85rem;
}

.param-description {
  color: #666;
  flex: 1;
}

.loading-spinner {
  text-align: center;
  padding: 3rem;
  color: #666;
  font-style: italic;
}

.tools-empty-state {
  text-align: center;
  padding: 3rem;
  color: #666;
}

.tools-empty-state h3 {
  color: #333;
  margin-bottom: 0.5rem;
}

/* Collapsible parameters */
.tool-params.collapsed .param-list {
  display: none;
}

.tool-params-toggle {
  cursor: pointer;
  user-select: none;
  display: flex;
  align-items: center;
  gap: 0.3rem;
}

.tool-params-toggle::before {
  content: '‚ñº';
  font-size: 0.7rem;
  transition: transform 0.2s;
  display: inline-block;
}

.tool-params.collapsed .tool-params-toggle::before {
  transform: rotate(-90deg);
}
</style>
{% endblock %}
{% block body %}
<div class="container">
  
  <!-- Tab Navigation -->
  <div class="tab-nav">
    <button class="tab-button active" onclick="switchMainTab('log')">Log</button>
    <button class="tab-button" onclick="switchMainTab('agents')">Agents</button>
    <button class="tab-button" onclick="switchMainTab('topics')">Topics</button>
    <button class="tab-button" onclick="switchMainTab('tools')">Tools</button>
  </div>
  
  <!-- Tab Content -->
  <div class="tab-container">
    
    <!-- Log Tab -->
    <div id="logTab" class="main-tab-content active">
      <!-- Live Agents Section -->
      <div id="liveAgentsSection">
        <div class="section-header">
          <span>Live</span>
          <span class="count" id="liveCount">0</span>
        </div>
        <table id="liveAgentTable"></table>
        <div id="liveEmpty" class="empty-state" style="display: none;">
          No agents currently running
        </div>
      </div>
      
      <!-- Historical Agents Section -->
      <div id="historicalAgentsSection">
        <div class="section-header">
          <span>Completed</span>
          <span class="count" id="historicalCount">0</span>
        </div>
        <table id="historicalAgentTable"></table>
        <div id="historicalEmpty" class="empty-state" style="display: none;">
          No completed agent runs found
        </div>
      </div>
      
      <!-- Pagination -->
      <div id="pagination" class="pagination" style="display: none;">
        <button id="prevBtn" onclick="changePage(-1)">Previous</button>
        <div class="page-info">
          <span id="pageInfo">Page 1 of 1</span>
        </div>
        <button id="nextBtn" onclick="changePage(1)">Next</button>
      </div>
    </div>
    
    <!-- Agents Tab -->
    <div id="agentsTab" class="main-tab-content">
      <div id="agentCards" class="agent-cards"></div>
    </div>
    
    <!-- Topics Tab -->
    <div id="topicsTab" class="main-tab-content">
      <div id="topicCards" class="agent-cards"></div>
    </div>

    <!-- Tools Tab -->
    <div id="toolsTab" class="main-tab-content">
      <div class="tools-container">
        <!-- Tools Filter/Search -->
        <div class="tools-header">
          <input type="text" id="toolsSearch" placeholder="Search tools..." class="tools-search" />
          <div class="pack-filters" id="packFilters"></div>
        </div>

        <!-- Tools Grid -->
        <div id="toolsGrid" class="tools-grid">
          <div class="loading-spinner">Loading tools...</div>
        </div>
      </div>
    </div>

  </div>
</div>

<!-- Create Agent Modal -->
<div id="createPersonaModal" class="modal">
  <div class="modal-content">
    <span class="close" onclick="closeCreatePersonaModal()">&times;</span>
    <h2>Create New Agent</h2>
    <form id="createPersonaForm" class="input-area">
      <input type="text" id="personaTitle" placeholder="Agent Title" required />
      <textarea id="personaInput" rows="8" placeholder="Describe what this agent should accomplish..." required></textarea>
      <div style="margin: 1rem 0; border-top: 1px solid #ddd; padding-top: 1rem;">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
          <div>
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
              <input type="checkbox" id="personaDailySchedule" style="width: auto;">
              <span>Run daily (scheduled agent)</span>
            </label>
          </div>
          <div>
            <label style="display: block;">
              Priority (0-99):
              <input type="number" id="personaPriority" min="0" max="99" placeholder="Default: 50"
                     style="width: 100px; margin-left: 0.5rem; padding: 0.25rem;">
            </label>
          </div>
        </div>
        <div>
          <label style="display: block; margin-bottom: 0.5rem;">
            Tool Packs:
            <select id="personaToolPacks" multiple style="width: 100%; height: 80px; margin-top: 0.5rem;">
              <option value="" selected>Default (All Tools)</option>
              <option value="journal">Journal</option>
              <option value="todo">Todo</option>
              <option value="domains">Domains</option>
            </select>
          </label>
          <small style="color: #666;">Hold Ctrl/Cmd to select multiple. Leave "Default" for all tools.</small>
        </div>
      </div>
      <button type="submit" id="createPromptBtn">Create Prompt</button>
    </form>
    
    <!-- Planning Status -->
    <div id="createPersonaPromptStatus" class="planning-status">
      <div>Creating prompt...</div>
    </div>
    
    <!-- Removed Result Area - now auto-saves and opens edit modal -->
  </div>
</div>

<!-- Create Topic Modal -->
<div id="createTopicModal" class="modal">
  <div class="modal-content">
    <span class="close" onclick="closeCreateTopicModal()">&times;</span>
    <h2>Create New Topic</h2>
    <form id="createTopicForm" class="input-area">
      <input type="text" id="topicTitle" placeholder="Topic Title" required />
      <textarea id="topicInput" rows="8" placeholder="Describe what information this topic should extract..." required></textarea>
      <button type="submit" id="createTopicBtn">Create Topic</button>
    </form>
    
    <!-- Result Area -->
    <div id="topicResult" style="display: none;">
      <h3>Topic Content</h3>
      <div id="topicResultContent" class="prompt-content"></div>
      <div class="modal-actions">
        <button onclick="saveNewTopic()">Save Topic</button>
        <button onclick="editTopicContent()">Edit Content</button>
      </div>
    </div>
  </div>
</div>

<!-- Item Details Modal (for both Agents and Topics) -->
<div id="itemModal" class="modal">
  <div class="modal-content">
    <span class="close" onclick="closeItemModal()">&times;</span>
    <button id="toggleBtn" class="toggle-btn" style="display: none;" onclick="toggleTopicState()">Disable</button>
    <button id="editBtn" class="edit-btn" onclick="toggleEditMode()">Edit</button>
    <div id="modalHeader" class="modal-header">
      <h3 id="modalTitle"></h3>
      <input id="modalTitleEdit" class="edit-mode-input" style="display: none;" />
      <button id="saveBtn" class="edit-btn save-mode" style="display: none;" onclick="saveItemChanges()">Save</button>
    </div>
    <div class="modal-body">
      <div id="modalContent" class="markdown-content"></div>
      <textarea id="modalContentEdit" class="edit-mode-textarea" style="display: none;"></textarea>
      <div id="agentConfigContainer" style="display: none; margin-top: 1rem;">
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
          <div>
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
              <input type="checkbox" id="modalDailySchedule" style="width: auto;">
              <span>Run daily (scheduled agent)</span>
            </label>
          </div>
          <div>
            <label style="display: block; margin-bottom: 0.5rem;">
              Priority (0-99, lower runs first):
              <input type="number" id="modalPriority" min="0" max="99" placeholder="Default: 50"
                     style="width: 100px; margin-left: 0.5rem; padding: 0.25rem;">
            </label>
          </div>
        </div>
        <div>
          <label style="display: block; margin-bottom: 0.5rem;">
            Tool Packs:
            <select id="modalToolPacks" multiple style="width: 100%; height: 100px; margin-top: 0.5rem;">
              <option value="">Default (All Tools)</option>
              <option value="journal">Journal</option>
              <option value="todo">Todo</option>
              <option value="domains">Domains</option>
            </select>
          </label>
          <small style="color: #666;">Hold Ctrl/Cmd to select multiple. Select only "Default" to use all tools.</small>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Planning Modal -->
<div id="promptModal" class="modal">
  <div class="modal-content">
    <span class="close" onclick="closePromptModal()">&times;</span>
    <div class="modal-header">
      <h3>Agent Prompt</h3>
    </div>
    <div class="modal-body">
      <!-- Tabs -->
      <div class="modal-tabs">
        <button class="modal-tab active" onclick="switchTab('prompt')">Edit Prompt</button>
        <button class="modal-tab" onclick="switchTab('preview')">Preview</button>
        <button class="modal-tab" onclick="switchTab('config')">Configuration</button>
      </div>
      
      <!-- Tab Content -->
      <div id="promptTab" class="tab-content active">
        <textarea id="promptEditor" class="prompt-editor" placeholder="Your execution prompt will appear here..."></textarea>
      </div>
      
      <div id="previewTab" class="tab-content">
        <div id="promptPreview" class="markdown-content"></div>
      </div>
      
      <div id="configTab" class="tab-content">
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">
          <em>Note: Prompt generation uses Gemini. Configuration below applies to agent execution.</em>
        </p>
        
        <div class="config-section">
          <label for="agentBackend">Agent Backend</label>
          <select id="agentBackend">
            <option value="openai">OpenAI</option>
            <option value="anthropic">Anthropic</option>
            <option value="google">Google</option>
          </select>
        </div>
        
        <div class="config-section">
          <label for="agentModel">Model (optional)</label>
          <input type="text" id="agentModel" placeholder="Leave empty for default">
        </div>
        
        <div class="config-section">
          <label for="maxTokens">Max Tokens</label>
          <input type="number" id="maxTokens" placeholder="0 for default" min="0">
        </div>
        
        <div class="config-section">
          <label for="agentPersona">Agent</label>
          <select id="agentPersona">
            <option value="default">Default</option>
          </select>
        </div>
        
        <button id="startAgentBtn" class="start-agent-btn" onclick="startAgent()">
          üöÄ Start Agent
        </button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
let availableAgents = [];
let availableTopics = [];
let availableTools = [];
let toolPacks = {};
let currentMainTab = 'log';
let currentEditingItem = null;
let currentEditingType = null; // 'agent' or 'topic'
let isEditMode = false;
let activePackFilter = 'all';

// Switch between main tabs
function switchMainTab(tabName) {
  // Update tab buttons
  document.querySelectorAll('.tab-button').forEach(tab => {
    tab.classList.remove('active');
  });
  event.target.classList.add('active');
  
  // Update tab content
  document.querySelectorAll('.main-tab-content').forEach(content => {
    content.classList.remove('active');
  });
  document.getElementById(tabName + 'Tab').classList.add('active');
  
  currentMainTab = tabName;
  
  // Load data for the selected tab if needed
  if (tabName === 'log') {
    loadAgentSessions();
    startAutoRefresh();
  } else if (tabName === 'agents') {
    stopAutoRefresh();
    if (!document.getElementById('agentCards').children.length) {
      loadAvailableAgents();
    }
  } else if (tabName === 'topics') {
    stopAutoRefresh();
    if (!document.getElementById('topicCards').children.length) {
      loadAvailableTopics();
    }
  } else if (tabName === 'tools') {
    stopAutoRefresh();
    if (availableTools.length === 0) {
      loadAvailableTools();
    }
  }
}

// Load available agents and render cards
function loadAvailableAgents() {
  fetch('{{ url_for('agents.available_agents') }}')
    .then(r => r.json())
    .then(agents => {
      availableAgents = agents;
      renderAgentCards();
    });
}

// Load available topics and render cards
function loadAvailableTopics() {
  fetch('{{ url_for('agents.available_topics') }}')
    .then(r => r.json())
    .then(topics => {
      availableTopics = topics;
      renderTopicCards();
    });
}

// Generic function to render cards for both agents and topics
function renderCards(items, containerId, itemType, createModalFunc) {
  const container = document.getElementById(containerId);
  container.innerHTML = '';
  
  // Add Create card first
  const createCard = document.createElement('div');
  createCard.className = 'agent-card create-agent-card';
  const itemLabel = itemType === 'agent' ? 'Agent' : 'Topic';
  createCard.innerHTML = `
    <h3>+ Create New ${itemLabel}</h3>
  `;
  createCard.addEventListener('click', createModalFunc);
  container.appendChild(createCard);
  
  // Add existing items
  items.forEach(item => {
    const card = document.createElement('div');
    card.className = 'agent-card';
    
    // Add disabled class for disabled topics
    if (itemType === 'topic' && item.disabled) {
      card.className += ' disabled';
    }
    
    card.dataset.itemId = item.id;
    card.dataset.itemType = itemType;
    card.title = item.description; // Set description as tooltip
    
    // Add color border and hover effects for topics
    if (itemType === 'topic' && item.color) {
      card.style.borderLeftWidth = '4px';
      card.style.borderLeftColor = item.color;
      
      // Set hover color to match topic color
      card.addEventListener('mouseenter', () => {
        card.style.borderColor = item.color;
        card.style.boxShadow = `0 2px 8px ${item.color}33`; // 33 = 20% opacity in hex
      });
      
      card.addEventListener('mouseleave', () => {
        card.style.borderColor = '#e0e0e0';
        card.style.borderLeftColor = item.color; // Keep left border colored
        card.style.boxShadow = '';
      });
    }
    
    // Create title with color indicator for topics
    let titleHtml = item.title;
    if (itemType === 'topic') {
      if (item.color) {
        titleHtml = `<span class="topic-indicator" style="background-color: ${item.color}"></span>${item.title}`;
      }
      if (item.disabled) {
        titleHtml += ' <span style="color: #6c757d; font-size: 0.8em;">(disabled)</span>';
      }
    }
    
    // Build metadata badges HTML
    let metadataHtml = '';
    if (itemType === 'agent') {
      const badges = [];

      // Schedule badge
      if (item.schedule === 'daily') {
        badges.push('<span class="metadata-badge schedule"><span class="badge-icon">üìÖ</span>Daily</span>');
      }

      // Priority badge
      if (item.priority !== undefined && item.priority !== null) {
        badges.push(`<span class="metadata-badge priority"><span class="badge-icon">‚ö°</span>P${item.priority}</span>`);
      }

      // Multi-domain badge
      if (item.multi_domain) {
        badges.push('<span class="metadata-badge multi-domain"><span class="badge-icon">üåê</span>Multi-Domain</span>');
      }

      // Tools badge (simplified)
      if (item.tools) {
        const toolsList = item.tools.split(',').map(t => t.trim());
        if (toolsList.length === 1) {
          badges.push(`<span class="metadata-badge tools"><span class="badge-icon">üîß</span>${toolsList[0]}</span>`);
        } else {
          badges.push(`<span class="metadata-badge tools"><span class="badge-icon">üîß</span>${toolsList.length} packs</span>`);
        }
      }

      // Backend badge
      if (item.backend) {
        badges.push(`<span class="metadata-badge backend"><span class="badge-icon">ü§ñ</span>${item.backend}</span>`);
      }

      if (badges.length > 0) {
        metadataHtml = `<div class="agent-metadata">${badges.join('')}</div>`;
      }
    }

    card.innerHTML = `
      <h3>${titleHtml}</h3>
      ${metadataHtml}
    `;
    
    // Create chat link for agents only
    if (itemType === 'agent') {
      const chatLink = document.createElement('a');
      chatLink.className = 'chat-link';
      chatLink.href = `/chat?persona=${item.id}`;
      chatLink.innerHTML = 'üí¨';
      chatLink.title = `Chat with ${item.title}`;
      chatLink.onclick = (e) => {
        e.stopPropagation(); // Prevent card click when clicking chat link
      };
      card.appendChild(chatLink);
    }
    
    card.addEventListener('click', (e) => {
      viewItemDetails(item.id, itemType, e);
    });
    
    container.appendChild(card);
  });
}

// Render agent selection cards
function renderAgentCards() {
  // Sort agents by priority (if scheduled) then by title
  const sortedAgents = [...availableAgents].sort((a, b) => {
    // Scheduled agents with priority come first
    if (a.schedule === 'daily' && b.schedule === 'daily') {
      // Both scheduled, sort by priority (lower number = higher priority)
      const aPriority = a.priority ?? 50;
      const bPriority = b.priority ?? 50;
      if (aPriority !== bPriority) {
        return aPriority - bPriority;
      }
    } else if (a.schedule === 'daily') {
      return -1; // a comes first
    } else if (b.schedule === 'daily') {
      return 1; // b comes first
    }
    // Fall back to alphabetical by title
    return a.title.localeCompare(b.title);
  });

  renderCards(sortedAgents, 'agentCards', 'agent', openCreatePersonaModal);
}

// Render topic selection cards
function renderTopicCards() {
  renderCards(availableTopics, 'topicCards', 'topic', openCreateTopicModal);
}

// View item details in modal (generic for both agents and topics)
function viewItemDetails(itemId, itemType, event) {
  event.stopPropagation();
  
  const items = itemType === 'agent' ? availableAgents : availableTopics;
  const item = items.find(i => i.id === itemId);
  if (!item) return;
  
  currentEditingItem = itemId;
  currentEditingType = itemType;
  isEditMode = false;
  
  // Reset edit mode UI
  const editBtn = document.getElementById('editBtn');
  const toggleBtn = document.getElementById('toggleBtn');
  const saveBtn = document.getElementById('saveBtn');
  const modalHeader = document.getElementById('modalHeader');
  
  // Show/hide toggle button for topics only
  if (itemType === 'topic') {
    toggleBtn.style.display = 'block';
    // Update button text based on disabled state
    const isDisabled = item.disabled || false;
    toggleBtn.textContent = isDisabled ? 'Enable' : 'Disable';
    toggleBtn.className = isDisabled ? 'toggle-btn enable' : 'toggle-btn';
  } else {
    toggleBtn.style.display = 'none';
  }
  
  editBtn.style.display = 'block';
  saveBtn.style.display = 'none';
  modalHeader.classList.remove('edit-mode');
  document.getElementById('modalTitle').style.display = 'block';
  document.getElementById('modalTitleEdit').style.display = 'none';
  document.getElementById('modalContent').style.display = 'block';
  document.getElementById('modalContentEdit').style.display = 'none';
  
  document.getElementById('modalTitle').textContent = item.title;
  document.getElementById('modalTitleEdit').value = item.title;
  document.getElementById('modalContent').innerHTML = '<p>Loading...</p>';
  document.getElementById('itemModal').style.display = 'block';

  // Hide agent config container initially (only shown in edit mode for agents)
  document.getElementById('agentConfigContainer').style.display = 'none';

  // Determine the correct endpoint based on item type
  const contentUrl = itemType === 'agent'
    ? `{{ url_for('agents.agent_content', agent_id='') }}${itemId}`
    : `{{ url_for('agents.topic_content', topic_id='') }}${itemId}`;

  // Load agent's config if it's an agent
  if (itemType === 'agent') {
    // Load the agent's JSON config to get schedule, priority, and tools
    fetch(`/think/agents/${itemId}.json`)
      .then(r => r.json())
      .then(config => {
        // Schedule
        document.getElementById('modalDailySchedule').checked = config.schedule === 'daily';

        // Priority (leave empty if not set, will show placeholder)
        document.getElementById('modalPriority').value = config.priority || '';

        // Tools - parse and select appropriate options
        const toolsSelect = document.getElementById('modalToolPacks');
        const toolsArray = config.tools ? config.tools.split(',').map(t => t.trim()) : [];

        // Clear all selections first
        for (let option of toolsSelect.options) {
          option.selected = false;
        }

        // If no tools specified, select "Default"
        if (toolsArray.length === 0) {
          toolsSelect.options[0].selected = true;
        } else {
          // Select specified tool packs
          for (let tool of toolsArray) {
            for (let option of toolsSelect.options) {
              if (option.value === tool) {
                option.selected = true;
              }
            }
          }
        }
      })
      .catch(() => {
        // If no JSON file or error, set defaults
        document.getElementById('modalDailySchedule').checked = false;
        document.getElementById('modalPriority').value = '';
        document.getElementById('modalToolPacks').options[0].selected = true;
      });
  }

  // Load and render item content
  fetch(contentUrl)
    .then(r => r.json())
    .then(data => {
      if (data.error) {
        document.getElementById('modalContent').innerHTML = `<p>Error: ${data.error}</p>`;
        document.getElementById('modalContentEdit').value = '';
      } else {
        // Store raw markdown for editing
        document.getElementById('modalContentEdit').value = data.content;
        // Convert markdown to HTML for display
        const html = marked.parse(data.content);
        document.getElementById('modalContent').innerHTML = html;
      }
    })
    .catch(err => {
      document.getElementById('modalContent').innerHTML = `<p>Error loading content: ${err.message}</p>`;
      document.getElementById('modalContentEdit').value = '';
    });
}

// Toggle edit mode for agent
function toggleEditMode() {
  const editBtn = document.getElementById('editBtn');
  const saveBtn = document.getElementById('saveBtn');
  const modalHeader = document.getElementById('modalHeader');
  const titleDisplay = document.getElementById('modalTitle');
  const titleEdit = document.getElementById('modalTitleEdit');
  const contentDisplay = document.getElementById('modalContent');
  const contentEdit = document.getElementById('modalContentEdit');
  
  if (!isEditMode) {
    // Enter edit mode
    isEditMode = true;
    editBtn.style.display = 'none';
    saveBtn.style.display = 'block';
    modalHeader.classList.add('edit-mode');

    titleDisplay.style.display = 'none';
    titleEdit.style.display = 'block';
    contentDisplay.style.display = 'none';
    contentEdit.style.display = 'block';

    // Show agent config container for agents only
    if (currentEditingType === 'agent') {
      document.getElementById('agentConfigContainer').style.display = 'block';
    }

    // Focus on title input
    titleEdit.focus();
  }
}

// Save item changes (generic for both agents and topics)
async function saveItemChanges() {
  const editBtn = document.getElementById('editBtn');
  const saveBtn = document.getElementById('saveBtn');
  const modalHeader = document.getElementById('modalHeader');
  const newTitle = document.getElementById('modalTitleEdit').value.trim();
  const newContent = document.getElementById('modalContentEdit').value.trim();
  
  if (!newTitle || !newContent) {
    showError('Title and content cannot be empty');
    return;
  }
  
  if (!currentEditingItem || !currentEditingType) {
    showError('No item selected for editing');
    return;
  }
  
  saveBtn.disabled = true;
  saveBtn.textContent = 'Saving...';

  // Determine the correct endpoint based on item type
  const updateUrl = currentEditingType === 'agent'
    ? `{{ url_for('agents.update_agent', agent_id='') }}${currentEditingItem}`
    : `{{ url_for('agents.update_topic', topic_id='') }}${currentEditingItem}`;

  // Build request body
  const requestBody = {
    title: newTitle,
    content: newContent
  };

  // Add agent-specific config
  if (currentEditingType === 'agent') {
    // Schedule
    const isDaily = document.getElementById('modalDailySchedule').checked;
    if (isDaily) {
      requestBody.schedule = 'daily';
    }

    // Priority (only add if a value is entered)
    const priority = document.getElementById('modalPriority').value;
    if (priority !== '') {
      requestBody.priority = parseInt(priority);
    }

    // Tools (only add if not "Default")
    const toolsSelect = document.getElementById('modalToolPacks');
    const selectedTools = [];
    for (let option of toolsSelect.options) {
      if (option.selected && option.value !== '') {
        selectedTools.push(option.value);
      }
    }
    // Only add tools parameter if specific packs are selected
    if (selectedTools.length > 0) {
      requestBody.tools = selectedTools.join(',');
    }
  }

  try {
    const response = await fetch(updateUrl, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(requestBody)
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to save changes');
    }
    
    // Update local data
    const items = currentEditingType === 'agent' ? availableAgents : availableTopics;
    const item = items.find(i => i.id === currentEditingItem);
    if (item) {
      item.title = newTitle;
      // Update the item card if it exists
      const card = document.querySelector(`[data-item-id="${currentEditingItem}"][data-item-type="${currentEditingType}"] h3`);
      if (card) {
        card.textContent = newTitle;
      }
    }
    
    // Exit edit mode and update display
    isEditMode = false;
    editBtn.style.display = 'block';
    saveBtn.style.display = 'none';
    modalHeader.classList.remove('edit-mode');
    
    document.getElementById('modalTitle').textContent = newTitle;
    document.getElementById('modalTitle').style.display = 'block';
    document.getElementById('modalTitleEdit').style.display = 'none';
    
    // Update content display with new markdown
    const html = marked.parse(newContent);
    document.getElementById('modalContent').innerHTML = html;
    document.getElementById('modalContent').style.display = 'block';
    document.getElementById('modalContentEdit').style.display = 'none';

    // Hide agent config container when exiting edit mode
    document.getElementById('agentConfigContainer').style.display = 'none';

    // Refresh agent dropdown in prompt modal if it's open (for agents only)
    if (currentEditingType === 'agent') {
      loadPersonas();
    }
    
  } catch (error) {
    showError('Error saving changes: ' + error.message);
  } finally {
    saveBtn.disabled = false;
    saveBtn.textContent = 'Save';
  }
}

// Form submission - removed as agentForm doesn't exist in this template
// The create agent functionality is handled by createPersonaForm instead

// Show prompt modal with prompt text
function showPromptModal(promptText) {
  const modal = document.getElementById('promptModal');
  const editor = document.getElementById('promptEditor');
  
  // Set the prompt in the editor
  editor.value = promptText;
  
  // Update preview
  updatePromptPreview();
  
  // Load available agents
  loadPersonas();
  
  // Show modal
  modal.style.display = 'block';
}

// Close prompt modal
function closePromptModal() {
  document.getElementById('promptModal').style.display = 'none';
}

// Switch between tabs
function switchTab(tabName) {
  // Update tab buttons
  document.querySelectorAll('.modal-tab').forEach(tab => {
    tab.classList.remove('active');
  });
  event.target.classList.add('active');
  
  // Update tab content
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.remove('active');
  });
  document.getElementById(tabName + 'Tab').classList.add('active');
  
  // Update preview if switching to preview tab
  if (tabName === 'preview') {
    updatePromptPreview();
  }
}

// Update markdown preview
function updatePromptPreview() {
  const editor = document.getElementById('promptEditor');
  const preview = document.getElementById('promptPreview');
  
  if (editor.value.trim()) {
    preview.innerHTML = marked.parse(editor.value);
  } else {
    preview.innerHTML = '<p><em>No prompt content to preview</em></p>';
}
}

// Load available agents
function loadPersonas() {
  fetch('{{ url_for('agents.available_agents') }}')
    .then(r => r.json())
    .then(agents => {
      const select = document.getElementById('agentPersona');
      select.innerHTML = '<option value="default">Default</option>';
      
      agents.forEach(agent => {
        const option = document.createElement('option');
        option.value = agent.id;
        option.textContent = agent.title;
        select.appendChild(option);
      });
    })
    .catch(err => {
      console.error('Failed to load agents:', err);
    });
}

// Start agent with current prompt and config
async function startAgent() {
  const prompt = document.getElementById('promptEditor').value.trim();
  if (!prompt) {
    showError('Please provide a prompt before starting the agent.');
    return;
  }
  
  const backend = document.getElementById('agentBackend').value;
  const model = document.getElementById('agentModel').value.trim();
  const maxTokens = parseInt(document.getElementById('maxTokens').value) || 0;
  const persona = document.getElementById('agentPersona').value;
  
  // Build config object
  const config = {};
  if (model) config.model = model;
  if (maxTokens) config.max_tokens = maxTokens;
  
  const startBtn = document.getElementById('startAgentBtn');
  startBtn.disabled = true;
  startBtn.textContent = 'üöÄ Starting...';
  
  try {
    const response = await fetch('{{ url_for('agents.start_agent') }}', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        prompt: prompt,
        backend: backend,
        config: config,
        persona: persona
      })
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to start agent');
    }
    
    // Success - close modal and reload agents
    closePromptModal();
    loadAgentSessions();
    
    // Clear the input form
    document.getElementById('agentInput').value = '';
    
  } catch (error) {
    showError('Error starting agent: ' + error.message);
  } finally {
    startBtn.disabled = false;
    startBtn.textContent = 'üöÄ Start Agent';
  }
}

// Close item modal function
function closeItemModal() {
  // Reset edit mode when closing
  if (isEditMode) {
    isEditMode = false;
    const editBtn = document.getElementById('editBtn');
    const saveBtn = document.getElementById('saveBtn');
    const modalHeader = document.getElementById('modalHeader');
    
    editBtn.style.display = 'block';
    saveBtn.style.display = 'none';
    modalHeader.classList.remove('edit-mode');
    document.getElementById('modalTitle').style.display = 'block';
    document.getElementById('modalTitleEdit').style.display = 'none';
    document.getElementById('modalContent').style.display = 'block';
    document.getElementById('modalContentEdit').style.display = 'none';
  }
  document.getElementById('itemModal').style.display = 'none';
}

// Moved to bottom of script with createPersonaModal handling

// Pagination state
let currentPage = 0;
let pageSize = 10;
let totalAgents = 0;

// Session history table functions
function buildRow(a) {
  const tr = document.createElement('tr');
  const short = a.prompt.length > 80 ? a.prompt.slice(0, 80) + '‚Ä¶' : a.prompt;
  const chatLink = `{{ url_for('chat.chat_page') }}?agent=${a.id}`;
  
  // Status badge
  const statusClass = `status-${a.status || 'unknown'}`;
  const statusBadge = `<span class="status-badge ${statusClass}">${a.status || 'unknown'}</span>`;
  
  // PID indicator for running agents
  const pidIndicator = a.pid ? ` (PID: ${a.pid})` : '';
  
  // Format runtime
  let runtimeDisplay = '';
  if (a.runtime_seconds !== undefined && a.runtime_seconds !== null) {
    const totalSeconds = Math.floor(a.runtime_seconds);
    const minutes = Math.floor(totalSeconds / 60);
    
    if (totalSeconds > 59) {
      // For 60 seconds or more, show just minutes
      runtimeDisplay = `${minutes}m`;
    } else {
      // For less than 60 seconds, show as Xs
      runtimeDisplay = `${totalSeconds}s`;
    }
  }
  
  tr.innerHTML = `
    <td><a href="${chatLink}">${statusBadge}</a></td>
    <td><a href="${chatLink}">${a.since}</a></td>
    <td>${runtimeDisplay}</td>
    <td>${a.model}${pidIndicator}</td>
    <td>${a.persona_title || a.persona}</td>
    <td title="${a.prompt}"><a href="${chatLink}">${short}</a></td>
  `;
  tr.style.cursor = 'pointer';
  tr.onclick = () => window.location.href = chatLink;
  return tr;
}

function loadAgentSessions(page = 0) {
  const offset = page * pageSize;
  fetch(`{{ url_for('agents.agents_list') }}?type=all&limit=${pageSize}&offset=${offset}`)
    .then(r => {
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      return r.json();
    })
    .then(data => {
      // Check for API error response
      if (data.error) {
        throw new Error(data.error);
      }
      
      const agents = data.agents || [];
      const pagination = data.pagination;
      const liveCount = data.live_count || 0;
      const historicalCount = data.historical_count || 0;
      
      // Separate live and historical agents
      const liveAgents = agents.filter(a => a.status === 'running');
      const historicalAgents = agents.filter(a => a.status !== 'running');
      
      // Update counts
      document.getElementById('liveCount').textContent = liveCount;
      document.getElementById('historicalCount').textContent = historicalCount;
      
      // Update live agents table
      const liveTable = document.getElementById('liveAgentTable');
      const liveEmpty = document.getElementById('liveEmpty');
      
      if (liveAgents.length > 0) {
        liveTable.innerHTML = '<tr><th>Status</th><th>Started</th><th>Runtime</th><th>Model</th><th>Agent</th><th>Prompt</th></tr>';
        liveAgents.forEach(a => liveTable.appendChild(buildRow(a)));
        liveTable.style.display = 'table';
        liveEmpty.style.display = 'none';
      } else {
        liveTable.style.display = 'none';
        liveEmpty.style.display = 'block';
      }
      
      // Update historical agents table
      const histTable = document.getElementById('historicalAgentTable');
      const histEmpty = document.getElementById('historicalEmpty');
      
      if (historicalAgents.length > 0) {
        histTable.innerHTML = '<tr><th>Status</th><th>Started</th><th>Runtime</th><th>Model</th><th>Agent</th><th>Prompt</th></tr>';
        historicalAgents.forEach(a => histTable.appendChild(buildRow(a)));
        histTable.style.display = 'table';
        histEmpty.style.display = 'none';
      } else {
        histTable.style.display = 'none';
        histEmpty.style.display = 'block';
      }
      
      // Update pagination if available
      if (pagination && pagination.total > pagination.limit) {
        currentPage = Math.floor(pagination.offset / pagination.limit);
        totalAgents = pagination.total;
        updatePagination(pagination);
      } else {
        document.getElementById('pagination').style.display = 'none';
      }
      
      // Hide any previous error warnings
      hideConnectionWarning();
    })
    .catch(err => {
      console.error('Failed to load agents:', err);
      
      // Still try to load historical agents even if cortex is down
      fetch(`{{ url_for('agents.agents_list') }}?type=historical&limit=${pageSize}&offset=${offset}`)
        .then(r => r.json())
        .then(data => {
          const historicalAgents = data.agents || [];
          const historicalCount = data.historical_count || 0;
          
          // Update historical count
          document.getElementById('historicalCount').textContent = historicalCount;
          
          // Clear live agents section
          document.getElementById('liveCount').textContent = '0';
          document.getElementById('liveAgentTable').style.display = 'none';
          document.getElementById('liveEmpty').style.display = 'block';
          
          // Update historical agents table
          const histTable = document.getElementById('historicalAgentTable');
          const histEmpty = document.getElementById('historicalEmpty');
          
          if (historicalAgents.length > 0) {
            histTable.innerHTML = '<tr><th>Status</th><th>Started</th><th>Runtime</th><th>Model</th><th>Agent</th><th>Prompt</th></tr>';
            historicalAgents.forEach(a => histTable.appendChild(buildRow(a)));
            histTable.style.display = 'table';
            histEmpty.style.display = 'none';
          } else {
            histTable.style.display = 'none';
            histEmpty.style.display = 'block';
          }
          
          // Update pagination
          if (data.pagination && data.pagination.total > data.pagination.limit) {
            updatePagination(data.pagination);
          } else {
            document.getElementById('pagination').style.display = 'none';
          }
        })
        .catch(() => {
          // Total failure - clear everything
          document.getElementById('liveCount').textContent = '0';
          document.getElementById('historicalCount').textContent = '0';
          document.getElementById('liveAgentTable').style.display = 'none';
          document.getElementById('liveEmpty').style.display = 'block';
          document.getElementById('historicalAgentTable').style.display = 'none';
          document.getElementById('historicalEmpty').style.display = 'block';
          document.getElementById('pagination').style.display = 'none';
        });
    });
}

function updatePagination(pagination) {
  const paginationDiv = document.getElementById('pagination');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const pageInfo = document.getElementById('pageInfo');
  
  if (pagination.total > pagination.limit) {
    paginationDiv.style.display = 'flex';
    
    const currentPageNum = Math.floor(pagination.offset / pagination.limit) + 1;
    const totalPages = Math.ceil(pagination.total / pagination.limit);
    
    pageInfo.textContent = `Page ${currentPageNum} of ${totalPages} (${pagination.total} total)`;
    
    prevBtn.disabled = pagination.offset === 0;
    nextBtn.disabled = !pagination.has_more;
  } else {
    paginationDiv.style.display = 'none';
  }
}

function changePage(delta) {
  const newPage = currentPage + delta;
  if (newPage >= 0) {
    loadAgentSessions(newPage);
  }
}

// Connection warning functions
function showConnectionWarning(message) {
  let warning = document.getElementById('connectionWarning');
  if (!warning) {
    warning = document.createElement('div');
    warning.id = 'connectionWarning';
    warning.style.cssText = 'background:#f8d7da;border:1px solid #f5c6cb;color:#721c24;padding:0.75rem;margin:1rem 0;border-radius:4px;text-align:center;';
    const container = document.querySelector('.container');
    const firstChild = container.children[1]; // Insert after h1
    container.insertBefore(warning, firstChild);
  }
  warning.innerHTML = `‚ö†Ô∏è <strong>Cortex Service Unavailable:</strong> ${message}`;
  warning.style.display = 'block';
}

function hideConnectionWarning() {
  const warning = document.getElementById('connectionWarning');
  if (warning) {
    warning.style.display = 'none';
  }
}

// Show error message
function showError(message) {
  alert(message); // Simple alert for now, can be improved with a toast notification
}

// Create Agent Modal Functions
function openCreatePersonaModal() {
  const modal = document.getElementById('createPersonaModal');
  modal.style.display = 'block';
  
  // Reset form
  document.getElementById('createPersonaForm').reset();
  document.getElementById('createPersonaForm').style.display = 'block';
  document.getElementById('createPersonaForm').classList.remove('busy');
  document.getElementById('createPersonaPromptStatus').classList.remove('show');
  document.getElementById('createPromptBtn').disabled = false;
}

function closeCreatePersonaModal() {
  document.getElementById('createPersonaModal').style.display = 'none';
}

// Create Topic Modal Functions
function openCreateTopicModal() {
  const modal = document.getElementById('createTopicModal');
  modal.style.display = 'block';
  
  // Reset form
  document.getElementById('createTopicForm').reset();
  document.getElementById('topicResult').style.display = 'none';
  document.getElementById('createTopicBtn').disabled = false;
}

function closeCreateTopicModal() {
  document.getElementById('createTopicModal').style.display = 'none';
}

// Handle create agent form submission
document.getElementById('createPersonaForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const title = document.getElementById('personaTitle').value.trim();
  const input = document.getElementById('personaInput').value.trim();
  const form = e.target;
  const status = document.getElementById('createPersonaPromptStatus');
  const createBtn = document.getElementById('createPromptBtn');
  
  if (!title || !input) return;
  
  // Show prompt generation status
  form.classList.add('busy');
  status.classList.add('show');
  createBtn.disabled = true;
  
  try {
    const response = await fetch('{{ url_for('agents.create_plan') }}', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        request: input,
        model: '' // Uses Gemini Pro by default
      })
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to create prompt');
    }
    
    const generatedPrompt = data.prompt || data.plan;
    if (!generatedPrompt) {
      throw new Error('No prompt returned by planner');
    }

    // Show the generated prompt
    showPersonaPromptResult(generatedPrompt, title);

  } catch (error) {
    showError('Error creating prompt: ' + error.message);
    createBtn.disabled = false;
  } finally {
    // Remove busy state
    form.classList.remove('busy');
    status.classList.remove('show');
  }
});

async function showPersonaPromptResult(prompt, title) {
  // Auto-save the agent immediately
  const isDaily = document.getElementById('personaDailySchedule').checked;
  const priority = document.getElementById('personaPriority').value;
  const toolsSelect = document.getElementById('personaToolPacks');
  const personaId = title.toLowerCase().replace(/[^a-z0-9]+/g, '_');

  try {
    // Create the agent
    const requestBody = {
      title: title,
      content: prompt
    };

    // Add schedule if daily is checked
    if (isDaily) {
      requestBody.schedule = 'daily';
    }

    // Add priority if specified
    if (priority !== '') {
      requestBody.priority = parseInt(priority);
    }

    // Add tools if specific packs are selected
    const selectedTools = [];
    for (let option of toolsSelect.options) {
      if (option.selected && option.value !== '') {
        selectedTools.push(option.value);
      }
    }
    if (selectedTools.length > 0) {
      requestBody.tools = selectedTools.join(',');
    }

    const response = await fetch(`{{ url_for('agents.update_agent', agent_id='') }}${personaId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
    });

    const data = await response.json();

    if (response.ok) {
      // Close create modal
      closeCreatePersonaModal();

      // Reload agents list
      await loadAvailableAgents();

      // Open the edit modal with the new agent
      setTimeout(() => {
        // Find the new agent in the list
        const newAgent = availableAgents.find(a => a.id === personaId);
        if (newAgent) {
          viewItemDetails(personaId, 'agent', { stopPropagation: () => {} });
        }
      }, 100);
    } else {
      throw new Error(data.error || 'Failed to save agent');
    }
  } catch (error) {
    showError('Error saving agent: ' + error.message);
    // Re-enable the form
    document.getElementById('createPersonaForm').classList.remove('busy');
    document.getElementById('createPersonaPromptStatus').classList.remove('show');
    document.getElementById('createPromptBtn').disabled = false;
  }
}

// Removed editPersonaPrompt - now using standard edit modal

// Removed saveNewPersona - now handled in showPersonaPromptResult

// Handle create topic form submission
document.getElementById('createTopicForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const title = document.getElementById('topicTitle').value.trim();
  const input = document.getElementById('topicInput').value.trim();
  const form = e.target;
  const createBtn = document.getElementById('createTopicBtn');
  
  if (!title || !input) return;
  
  // Show the topic content area
  showTopicResult(input, title);
  
  // Hide form
  form.style.display = 'none';
});

function showTopicResult(content, title) {
  const resultDiv = document.getElementById('topicResult');
  const resultContent = document.getElementById('topicResultContent');
  
  // Store content and title for saving
  window.currentTopicContent = content;
  window.currentTopicTitle = title;
  
  // Display the content
  resultContent.textContent = content;
  resultDiv.style.display = 'block';
}

function editTopicContent() {
  const resultContent = document.getElementById('topicResultContent');
  
  // Convert to editable textarea
  const textarea = document.createElement('textarea');
  textarea.value = resultContent.textContent;
  textarea.style.width = '100%';
  textarea.style.minHeight = '400px';
  textarea.style.padding = '1rem';
  textarea.style.fontFamily = 'Monaco, Menlo, monospace';
  textarea.style.fontSize = '0.9rem';
  
  resultContent.innerHTML = '';
  resultContent.appendChild(textarea);
  
  // Update the content when editing
  textarea.addEventListener('input', () => {
    window.currentTopicContent = textarea.value;
  });
}

async function saveNewTopic() {
  const title = window.currentTopicTitle;
  const content = window.currentTopicContent;
  
  if (!title || !content) {
    showError('Missing title or content');
    return;
  }
  
  // Generate a unique ID for the new topic
  const topicId = title.toLowerCase().replace(/[^a-z0-9]+/g, '_');
  
  try {
    // Create or update the topic
    const response = await fetch(`{{ url_for('agents.update_topic', topic_id='') }}${topicId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        title: title,
        content: content
      })
    });
    
    const data = await response.json();
    
    if (response.ok) {
      alert('Topic saved successfully!');
      closeCreateTopicModal();
      // Reset form for next use
      document.getElementById('createTopicForm').style.display = 'block';
      document.getElementById('topicResult').style.display = 'none';
      // Reload topics
      loadAvailableTopics();
    } else {
      throw new Error(data.error || 'Failed to save topic');
    }
  } catch (error) {
    showError('Error saving topic: ' + error.message);
  }
}

// Update modal close handlers
window.onclick = function(event) {
  const itemModal = document.getElementById('itemModal');
  const promptModal = document.getElementById('promptModal');
  const createPersonaModal = document.getElementById('createPersonaModal');
  const createTopicModal = document.getElementById('createTopicModal');
  
  if (event.target == itemModal) {
    closeItemModal();
  }
  if (event.target == promptModal) {
    promptModal.style.display = 'none';
  }
  if (event.target == createPersonaModal) {
    createPersonaModal.style.display = 'none';
  }
  if (event.target == createTopicModal) {
    createTopicModal.style.display = 'none';
  }
};

// Auto-refresh live agents
let refreshInterval = null;

function startAutoRefresh() {
  // Refresh every 5 seconds if on the log tab
  if (currentMainTab === 'log' && !refreshInterval) {
    refreshInterval = setInterval(() => {
      if (document.visibilityState === 'visible') {
        // Only refresh the current page
        loadAgentSessions(currentPage);
      }
    }, 5000);
  }
}

function stopAutoRefresh() {
  if (refreshInterval) {
    clearInterval(refreshInterval);
    refreshInterval = null;
  }
}

// Start/stop refresh based on tab
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden') {
    stopAutoRefresh();
  } else if (currentMainTab === 'log') {
    startAutoRefresh();
  }
});

// Toggle topic disabled state
async function toggleTopicState() {
  if (!currentEditingItem || currentEditingType !== 'topic') return;
  
  const toggleBtn = document.getElementById('toggleBtn');
  toggleBtn.disabled = true;
  
  try {
    const response = await fetch(`{{ url_for('agents.toggle_topic', topic_id='') }}${currentEditingItem}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' }
    });
    
    const data = await response.json();
    
    if (response.ok) {
      // Update button text and style
      const isDisabled = data.disabled;
      toggleBtn.textContent = isDisabled ? 'Enable' : 'Disable';
      toggleBtn.className = isDisabled ? 'toggle-btn enable' : 'toggle-btn';
      
      // Update the item in availableTopics
      const topic = availableTopics.find(t => t.id === currentEditingItem);
      if (topic) {
        topic.disabled = isDisabled;
      }
      
      // Update the card appearance
      const card = document.querySelector(`[data-item-id="${currentEditingItem}"][data-item-type="topic"]`);
      if (card) {
        if (isDisabled) {
          card.classList.add('disabled');
        } else {
          card.classList.remove('disabled');
        }
        
        // Update title to show disabled state
        const h3 = card.querySelector('h3');
        if (h3) {
          let html = h3.innerHTML;
          // Remove existing disabled indicator
          html = html.replace(/ <span style="color: #6c757d; font-size: 0.8em;">\(disabled\)<\/span>/g, '');
          // Add new indicator if disabled
          if (isDisabled) {
            html += ' <span style="color: #6c757d; font-size: 0.8em;">(disabled)</span>';
          }
          h3.innerHTML = html;
        }
      }
    } else {
      showError('Failed to toggle topic: ' + (data.error || 'Unknown error'));
    }
  } catch (error) {
    showError('Error toggling topic: ' + error.message);
  } finally {
    toggleBtn.disabled = false;
  }
}

// Load available tools and render them
function loadAvailableTools() {
  fetch('{{ url_for('agents.available_tools') }}')
    .then(r => r.json())
    .then(data => {
      if (data.error) {
        document.getElementById('toolsGrid').innerHTML = `
          <div class="tools-empty-state">
            <h3>Error Loading Tools</h3>
            <p>${data.error}</p>
          </div>
        `;
        return;
      }

      availableTools = data.tools || [];
      toolPacks = data.packs || {};
      renderPackFilters();
      renderToolsGrid();
      setupToolsSearch();
    })
    .catch(err => {
      console.error('Failed to load tools:', err);
      document.getElementById('toolsGrid').innerHTML = `
        <div class="tools-empty-state">
          <h3>Failed to Load Tools</h3>
          <p>Please ensure the MCP tools server is configured correctly.</p>
        </div>
      `;
    });
}

// Render pack filter buttons
function renderPackFilters() {
  const container = document.getElementById('packFilters');
  container.innerHTML = '';

  // All tools button
  const allBtn = document.createElement('button');
  allBtn.className = 'pack-filter-btn active';
  allBtn.innerHTML = `All<span class="count">${availableTools.length}</span>`;
  allBtn.onclick = () => filterByPack('all');
  container.appendChild(allBtn);

  // Pack-specific buttons
  Object.entries(toolPacks).forEach(([packName, packInfo]) => {
    const btn = document.createElement('button');
    btn.className = 'pack-filter-btn';
    btn.innerHTML = `${packInfo.name}<span class="count">${packInfo.tools.length}</span>`;
    btn.title = packInfo.description;
    btn.onclick = () => filterByPack(packName);
    container.appendChild(btn);
  });

  // Uncategorized button (tools not in any pack)
  const uncategorized = availableTools.filter(t => t.packs.length === 0);
  if (uncategorized.length > 0) {
    const uncatBtn = document.createElement('button');
    uncatBtn.className = 'pack-filter-btn';
    uncatBtn.innerHTML = `Other<span class="count">${uncategorized.length}</span>`;
    uncatBtn.onclick = () => filterByPack('uncategorized');
    container.appendChild(uncatBtn);
  }
}

// Filter tools by pack
function filterByPack(pack) {
  activePackFilter = pack;

  // Update button states
  document.querySelectorAll('.pack-filter-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  event.target.classList.add('active');

  // Apply filter
  applyToolsFilter();
}

// Apply search and pack filters
function applyToolsFilter() {
  const searchTerm = document.getElementById('toolsSearch').value.toLowerCase();
  const cards = document.querySelectorAll('.tool-card');

  cards.forEach(card => {
    const toolName = card.dataset.toolName;
    const tool = availableTools.find(t => t.name === toolName);
    if (!tool) return;

    // Check pack filter
    let packMatch = true;
    if (activePackFilter !== 'all') {
      if (activePackFilter === 'uncategorized') {
        packMatch = tool.packs.length === 0;
      } else {
        packMatch = tool.packs.includes(activePackFilter);
      }
    }

    // Check search filter
    let searchMatch = true;
    if (searchTerm) {
      searchMatch = tool.name.toLowerCase().includes(searchTerm) ||
                   (tool.description && tool.description.toLowerCase().includes(searchTerm));
    }

    // Show/hide card
    if (packMatch && searchMatch) {
      card.classList.remove('hidden');
    } else {
      card.classList.add('hidden');
    }
  });
}

// Setup search functionality
function setupToolsSearch() {
  const searchInput = document.getElementById('toolsSearch');
  searchInput.addEventListener('input', applyToolsFilter);
}

// Render tools grid
function renderToolsGrid() {
  const container = document.getElementById('toolsGrid');
  container.innerHTML = '';

  if (availableTools.length === 0) {
    container.innerHTML = `
      <div class="tools-empty-state">
        <h3>No Tools Available</h3>
        <p>MCP tools will appear here once configured.</p>
      </div>
    `;
    return;
  }

  availableTools.forEach(tool => {
    const card = createToolCard(tool);
    container.appendChild(card);
  });
}

// Create a tool card element
function createToolCard(tool) {
  const card = document.createElement('div');
  card.className = 'tool-card';
  card.dataset.toolName = tool.name;

  // Header with name and pack badges
  const header = document.createElement('div');
  header.className = 'tool-header';

  const name = document.createElement('h3');
  name.className = 'tool-name';
  name.textContent = tool.name;
  header.appendChild(name);

  if (tool.packs && tool.packs.length > 0) {
    const packs = document.createElement('div');
    packs.className = 'tool-packs';
    tool.packs.forEach(packName => {
      const badge = document.createElement('span');
      badge.className = 'tool-pack-badge';
      badge.textContent = packName;
      packs.appendChild(badge);
    });
    header.appendChild(packs);
  }

  card.appendChild(header);

  // Description
  const desc = document.createElement('div');
  desc.className = 'tool-description';
  desc.innerHTML = marked.parse(tool.description || 'No description available');
  card.appendChild(desc);

  // Parameters (if available)
  if (tool.input_schema && tool.input_schema.properties) {
    const params = createParametersSection(tool.input_schema);
    if (params) {
      card.appendChild(params);
    }
  }

  return card;
}

// Create parameters section for a tool
function createParametersSection(schema) {
  const properties = schema.properties || {};
  const required = schema.required || [];

  if (Object.keys(properties).length === 0) {
    return null;
  }

  const section = document.createElement('div');
  section.className = 'tool-params';

  const title = document.createElement('div');
  title.className = 'tool-params-toggle tool-params-title';
  title.textContent = `Parameters (${Object.keys(properties).length})`;
  title.onclick = () => section.classList.toggle('collapsed');
  section.appendChild(title);

  const list = document.createElement('div');
  list.className = 'param-list';

  Object.entries(properties).forEach(([paramName, paramSchema]) => {
    const item = document.createElement('div');
    item.className = 'param-item';

    const name = document.createElement('span');
    name.className = 'param-name';
    name.textContent = paramName;
    item.appendChild(name);

    // Required/optional indicator
    const reqSpan = document.createElement('span');
    if (required.includes(paramName)) {
      reqSpan.className = 'param-required';
      reqSpan.textContent = '*';
    } else {
      reqSpan.className = 'param-optional';
      reqSpan.textContent = '(optional)';
    }
    item.appendChild(reqSpan);

    // Type
    if (paramSchema.type) {
      const type = document.createElement('span');
      type.className = 'param-type';
      type.textContent = `[${paramSchema.type}]`;
      item.appendChild(type);
    }

    // Description
    if (paramSchema.description) {
      const desc = document.createElement('span');
      desc.className = 'param-description';
      desc.textContent = paramSchema.description;
      item.appendChild(desc);
    }

    list.appendChild(item);
  });

  section.appendChild(list);

  // Start collapsed if more than 3 parameters
  if (Object.keys(properties).length > 3) {
    section.classList.add('collapsed');
  }

  return section;
}

// Initialize - The Log tab is shown by default now
setTimeout(() => {
  loadAgentSessions();
  startAutoRefresh();
}, 100);
</script>
{% endblock %}
