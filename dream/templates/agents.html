{% extends 'base.html' %}
{% set title = 'Agents' %}
{% set active = 'agents' %}
{% block head %}
<style>
.container { padding: 0 1em; }

/* Tab Navigation */
.tab-nav {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 2rem;
  border-bottom: 2px solid #e0e0e0;
  padding-bottom: 0;
}

.tab-button {
  padding: 0.75rem 1.5rem;
  background: none;
  border: none;
  border-bottom: 3px solid transparent;
  color: #666;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-bottom: -2px;
}

.tab-button:hover {
  color: #007bff;
  background: #f8f9ff;
}

.tab-button.active {
  color: #007bff;
  border-bottom-color: #007bff;
  font-weight: 500;
}

/* Tab Content */
.tab-container {
  min-height: 400px;
}

.main-tab-content {
  display: none;
  animation: fadeIn 0.3s ease;
}

.main-tab-content.active {
  display: block;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Agent Cards */
.agent-cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 1rem;
  margin-bottom: 2rem;
}

.agent-card {
  background: white;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  padding: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
}

.agent-card:hover {
  border-color: #007bff;
  box-shadow: 0 2px 8px rgba(0, 123, 255, 0.1);
}

.agent-card .chat-link {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  font-size: 1.5rem;
  text-decoration: none;
  opacity: 0;
  transition: opacity 0.2s ease;
  background: white;
  border-radius: 4px;
  padding: 0.2rem 0.4rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.agent-card:hover .chat-link {
  opacity: 1;
}

.agent-card .chat-link:hover {
  transform: scale(1.1);
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.agent-card.selected {
  border-color: #007bff;
  background: #f8f9ff;
  box-shadow: 0 0 0 1px #007bff;
}

.agent-card h3 {
  margin: 0 0 0.5rem 0;
  font-size: 1.1rem;
  color: #333;
}

.agent-card p {
  margin: 0;
  color: #666;
  font-size: 0.9rem;
  line-height: 1.4;
}

/* Create Persona Card */
.create-persona-card {
  background: #f8f9ff;
  border: 2px dashed #007bff;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 80px;
}

.create-persona-card:hover {
  background: #e8ecff;
  border-style: solid;
}

.create-persona-card h3 {
  color: #007bff;
  margin: 0;
  font-size: 1.2rem;
}


/* Input Form */
.input-area {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin-bottom: 2rem;
}

.input-area textarea {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-family: inherit;
  resize: vertical;
}

.input-area button {
  padding: 0.75rem 1.5rem;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1.2rem;
  align-self: flex-start;
}

.input-area button:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.input-area button:hover:not(:disabled) {
  background: #0056b3;
}

.input-area.busy {
  position: relative;
}

.input-area.busy::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.8);
  cursor: wait;
  z-index: 10;
}

.input-area.busy textarea,
.input-area.busy button {
  pointer-events: none;
}

.planning-status {
  margin-top: 0.5rem;
  padding: 0.5rem;
  background: #e3f2fd;
  border: 1px solid #90caf9;
  border-radius: 4px;
  font-size: 0.9rem;
  display: none;
}

.planning-status.show {
  display: block;
}

.selection-status {
  font-size: 0.9rem;
  color: #666;
  margin-bottom: 1rem;
}

.selection-status.required {
  color: #dc3545;
  font-weight: 500;
}

/* Session History Table */
table { 
  border-collapse: collapse; 
  width: 100%; 
  margin-top: 2rem;
}
th, td { 
  padding: 4px 8px; 
  border-bottom: 1px solid #ddd; 
  white-space: nowrap; 
  text-align: left;
}
th {
  font-weight: 600;
  background-color: #f8f9fa;
}
/* Adjust column widths */
td:nth-child(1), th:nth-child(1) { /* Status */
  width: 100px;
}
td:nth-child(2), th:nth-child(2) { /* Started */
  width: 120px;
}
td:nth-child(3), th:nth-child(3) { /* Runtime */
  width: 80px;
  text-align: right;
}
td:nth-child(4), th:nth-child(4) { /* Model */
  width: 150px;
}
td:nth-child(5), th:nth-child(5) { /* Persona */
  width: 180px;
}
td:last-child { /* Prompt */
  overflow: hidden; 
  text-overflow: ellipsis;
  max-width: 0;
}
tr:hover {
  background-color: #f8f9fa;
}
tr a {
  color: #007bff;
  text-decoration: none;
}
tr a:hover {
  text-decoration: underline;
}

/* Status indicators */
.status-badge {
  display: inline-block;
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 0.75rem;
  font-weight: 500;
  text-transform: uppercase;
  margin-right: 0.5rem;
}

.status-running {
  background-color: #d4edda;
  color: #155724;
}

.status-finished {
  background-color: #d1ecf1;
  color: #0c5460;
}

.status-error {
  background-color: #f8d7da;
  color: #721c24;
}

.status-interrupted {
  background-color: #fff3cd;
  color: #856404;
}

.status-unknown {
  background-color: #e2e3e5;
  color: #383d41;
}

/* Section headers for agent log */
.section-header {
  margin: 2rem 0 1rem 0;
  padding: 0.5rem 0;
  border-bottom: 2px solid #007bff;
  font-size: 1.1rem;
  font-weight: 500;
  color: #333;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.section-header .count {
  font-size: 0.9rem;
  font-weight: normal;
  color: #666;
  background: #f8f9fa;
  padding: 2px 8px;
  border-radius: 12px;
}

.empty-state {
  text-align: center;
  padding: 2rem;
  color: #666;
  font-style: italic;
}

/* Pagination */
.pagination {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.5rem;
  margin-top: 1rem;
  padding: 1rem;
}

.pagination button {
  padding: 0.5rem 1rem;
  border: 1px solid #ddd;
  background: white;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.pagination button:hover:not(:disabled) {
  background: #007bff;
  color: white;
  border-color: #007bff;
}

.pagination button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.pagination .page-info {
  margin: 0 1rem;
  font-size: 0.9rem;
  color: #666;
}

/* Modal Styling (reused from entities.html) */
.modal {
  display: none;
  position: fixed;
  z-index: 1000;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
}

.modal-content {
  background-color: white;
  margin: 5% auto;
  border-radius: 8px;
  width: 90%;
  max-width: 800px;
  max-height: 80vh;
  position: relative;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
  overflow: hidden;
}

.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  line-height: 1;
  position: absolute;
  top: 15px;
  right: 20px;
  background: white;
  z-index: 3;
}

.close:hover { 
  color: #000; 
}

.modal-header {
  padding: 20px 40px 15px 20px;
  border-bottom: 1px solid #e0e0e0;
  background: white;
  border-radius: 8px 8px 0 0;
}

.modal-header h3 { 
  margin: 0; 
  color: #333; 
}

.modal-body {
  max-height: calc(80vh - 80px);
  overflow-y: auto;
  padding: 20px;
}

.modal-body .markdown-content h1,
.modal-body .markdown-content h2,
.modal-body .markdown-content h3,
.modal-body .markdown-content h4,
.modal-body .markdown-content h5,
.modal-body .markdown-content h6 {
  margin-top: 1.5rem;
  margin-bottom: 0.75rem;
  color: #333;
}

.modal-body .markdown-content p {
  margin-bottom: 1rem;
  line-height: 1.6;
}

.modal-body .markdown-content ul,
.modal-body .markdown-content ol {
  margin-bottom: 1rem;
  padding-left: 2rem;
}

.modal-body .markdown-content code {
  background: #f8f9fa;
  padding: 0.2rem 0.4rem;
  border-radius: 3px;
  font-family: 'Courier New', monospace;
}

.modal-body .markdown-content pre {
  background: #f8f9fa;
  padding: 1rem;
  border-radius: 4px;
  overflow-x: auto;
  margin-bottom: 1rem;
}

/* Planning Modal Tabs */
.modal-tabs {
  display: flex;
  border-bottom: 1px solid #e0e0e0;
  margin: -20px -20px 20px -20px;
  background: #f8f9fa;
}

.modal-tab {
  padding: 12px 20px;
  cursor: pointer;
  border: none;
  background: none;
  font-size: 0.9rem;
  color: #666;
  transition: all 0.2s ease;
  flex: 1;
  text-align: center;
}

.modal-tab:hover {
  background: #e9ecef;
  color: #333;
}

.modal-tab.active {
  color: #007bff;
  background: white;
  border-bottom: 2px solid #007bff;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}

.plan-editor {
  width: 100%;
  min-height: 400px;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 1rem;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 0.9rem;
  line-height: 1.4;
  resize: vertical;
}

.config-section {
  margin-bottom: 1.5rem;
}

.config-section label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  color: #333;
}

.config-section select,
.config-section input {
  width: 100%;
  padding: 0.5rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 0.9rem;
}

.start-agent-btn {
  background: #28a745;
  color: white;
  border: none;
  padding: 0.75rem 2rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
  margin-top: 1rem;
}

.start-agent-btn:hover {
  background: #218838;
}

.start-agent-btn:disabled {
  background: #6c757d;
  cursor: not-allowed;
}

/* Create Persona Modal Styles */
#createPersonaModal .modal-content {
  max-width: 700px;
}

#personaTitle {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;
  margin-bottom: 1rem;
}

.plan-content {
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  padding: 1rem;
  margin: 1rem 0;
  max-height: 400px;
  overflow-y: auto;
  white-space: pre-wrap;
  font-family: 'Monaco', 'Menlo', monospace;
  font-size: 0.9rem;
}

.modal-actions {
  display: flex;
  gap: 1rem;
  margin-top: 1rem;
}

.modal-actions button {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
}

.modal-actions button:first-child {
  background: #28a745;
  color: white;
}

.modal-actions button:first-child:hover {
  background: #218838;
}

.modal-actions button:last-child {
  background: #6c757d;
  color: white;
}

.modal-actions button:last-child:hover {
  background: #545b62;
}

/* Edit Mode Styles */
.edit-btn {
  position: absolute;
  top: 20px;
  right: 60px;
  background: #007bff;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.9rem;
  z-index: 3;
}

.edit-btn:hover {
  background: #0056b3;
}

.edit-btn.save-mode {
  background: #28a745;
  position: static;
  margin-left: 1rem;
  flex-shrink: 0;
}

.edit-btn.save-mode:hover {
  background: #218838;
}

.modal-header.edit-mode {
  display: flex;
  align-items: center;
  padding-right: 60px;
}

.edit-mode-input {
  flex: 1;
  padding: 0.5rem;
  font-size: 1.1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-weight: 500;
  margin: 0;
}

.edit-mode-textarea {
  width: 100%;
  min-height: 400px;
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 0.9rem;
  line-height: 1.5;
  resize: vertical;
}
</style>
{% endblock %}
{% block body %}
<div class="container">
  
  <!-- Tab Navigation -->
  <div class="tab-nav">
    <button class="tab-button active" onclick="switchMainTab('log')">Log</button>
    <button class="tab-button" onclick="switchMainTab('agents')">Personas</button>
  </div>
  
  <!-- Tab Content -->
  <div class="tab-container">
    
    <!-- Log Tab -->
    <div id="logTab" class="main-tab-content active">
      <!-- Live Agents Section -->
      <div id="liveAgentsSection">
        <div class="section-header">
          <span>Live</span>
          <span class="count" id="liveCount">0</span>
        </div>
        <table id="liveAgentTable"></table>
        <div id="liveEmpty" class="empty-state" style="display: none;">
          No agents currently running
        </div>
      </div>
      
      <!-- Historical Agents Section -->
      <div id="historicalAgentsSection">
        <div class="section-header">
          <span>Completed</span>
          <span class="count" id="historicalCount">0</span>
        </div>
        <table id="historicalAgentTable"></table>
        <div id="historicalEmpty" class="empty-state" style="display: none;">
          No completed agent runs found
        </div>
      </div>
      
      <!-- Pagination -->
      <div id="pagination" class="pagination" style="display: none;">
        <button id="prevBtn" onclick="changePage(-1)">Previous</button>
        <div class="page-info">
          <span id="pageInfo">Page 1 of 1</span>
        </div>
        <button id="nextBtn" onclick="changePage(1)">Next</button>
      </div>
    </div>
    
    <!-- Personas Tab -->
    <div id="agentsTab" class="main-tab-content">
      <div id="agentCards" class="agent-cards"></div>
    </div>
    
  </div>
</div>

<!-- Create Persona Modal -->
<div id="createPersonaModal" class="modal">
  <div class="modal-content">
    <span class="close" onclick="closeCreatePersonaModal()">&times;</span>
    <h2>Create New Persona</h2>
    <form id="createPersonaForm" class="input-area">
      <input type="text" id="personaTitle" placeholder="Persona Title" required />
      <textarea id="personaInput" rows="8" placeholder="Describe what this persona should accomplish..." required></textarea>
      <button type="submit" id="createPlanBtn">Create Plan</button>
    </form>
    
    <!-- Planning Status -->
    <div id="createPersonaPlanningStatus" class="planning-status">
      <div>Creating execution plan...</div>
    </div>
    
    <!-- Result Area -->
    <div id="personaResult" style="display: none;">
      <h3>Generated Plan</h3>
      <div id="personaResultContent" class="plan-content"></div>
      <div class="modal-actions">
        <button onclick="saveNewPersona()">Save Persona</button>
        <button onclick="editPersonaPlan()">Edit Plan</button>
      </div>
    </div>
  </div>
</div>

<!-- Agent Details Modal -->
<div id="agentModal" class="modal">
  <div class="modal-content">
    <span class="close" onclick="closeAgentModal()">&times;</span>
    <button id="editBtn" class="edit-btn" onclick="toggleEditMode()">Edit</button>
    <div id="modalHeader" class="modal-header">
      <h3 id="modalTitle"></h3>
      <input id="modalTitleEdit" class="edit-mode-input" style="display: none;" />
      <button id="saveBtn" class="edit-btn save-mode" style="display: none;" onclick="savePersonaChanges()">Save</button>
    </div>
    <div class="modal-body">
      <div id="modalContent" class="markdown-content"></div>
      <textarea id="modalContentEdit" class="edit-mode-textarea" style="display: none;"></textarea>
    </div>
  </div>
</div>

<!-- Planning Modal -->
<div id="planningModal" class="modal">
  <div class="modal-content">
    <span class="close" onclick="closePlanningModal()">&times;</span>
    <div class="modal-header">
      <h3>Agent Execution Plan</h3>
    </div>
    <div class="modal-body">
      <!-- Tabs -->
      <div class="modal-tabs">
        <button class="modal-tab active" onclick="switchTab('plan')">Edit Plan</button>
        <button class="modal-tab" onclick="switchTab('preview')">Preview</button>
        <button class="modal-tab" onclick="switchTab('config')">Configuration</button>
      </div>
      
      <!-- Tab Content -->
      <div id="planTab" class="tab-content active">
        <textarea id="planEditor" class="plan-editor" placeholder="Your execution plan will appear here..."></textarea>
      </div>
      
      <div id="previewTab" class="tab-content">
        <div id="planPreview" class="markdown-content"></div>
      </div>
      
      <div id="configTab" class="tab-content">
        <p style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">
          <em>Note: Plan generation uses Gemini. Configuration below applies to agent execution.</em>
        </p>
        
        <div class="config-section">
          <label for="agentBackend">Agent Backend</label>
          <select id="agentBackend">
            <option value="openai">OpenAI</option>
            <option value="anthropic">Anthropic</option>
            <option value="google">Google</option>
          </select>
        </div>
        
        <div class="config-section">
          <label for="agentModel">Model (optional)</label>
          <input type="text" id="agentModel" placeholder="Leave empty for default">
        </div>
        
        <div class="config-section">
          <label for="maxTokens">Max Tokens</label>
          <input type="number" id="maxTokens" placeholder="0 for default" min="0">
        </div>
        
        <div class="config-section">
          <label for="agentPersona">Persona</label>
          <select id="agentPersona">
            <option value="default">Default</option>
          </select>
        </div>
        
        <button id="startAgentBtn" class="start-agent-btn" onclick="startAgent()">
          üöÄ Start Agent
        </button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
let availableAgents = [];
let currentMainTab = 'create';
let currentEditingAgent = null;
let isEditMode = false;

// Switch between main tabs
function switchMainTab(tabName) {
  // Update tab buttons
  document.querySelectorAll('.tab-button').forEach(tab => {
    tab.classList.remove('active');
  });
  event.target.classList.add('active');
  
  // Update tab content
  document.querySelectorAll('.main-tab-content').forEach(content => {
    content.classList.remove('active');
  });
  document.getElementById(tabName + 'Tab').classList.add('active');
  
  currentMainTab = tabName;
  
  // Load data for the selected tab if needed
  if (tabName === 'log') {
    loadAgentSessions();
    startAutoRefresh();
  } else if (tabName === 'agents') {
    stopAutoRefresh();
    if (!document.getElementById('agentCards').children.length) {
      loadAvailableAgents();
    }
  }
}

// Load available agents and render cards
function loadAvailableAgents() {
  fetch('{{ url_for('agents.available_agents') }}')
    .then(r => r.json())
    .then(agents => {
      availableAgents = agents;
      renderAgentCards();
    });
}

// Render agent selection cards (for viewing details only)
function renderAgentCards() {
  const container = document.getElementById('agentCards');
  container.innerHTML = '';
  
  // Add Create Persona card first
  const createCard = document.createElement('div');
  createCard.className = 'agent-card create-persona-card';
  createCard.innerHTML = `
    <h3>+ Create New Persona</h3>
  `;
  createCard.addEventListener('click', openCreatePersonaModal);
  container.appendChild(createCard);
  
  // Add existing personas
  availableAgents.forEach(agent => {
    const card = document.createElement('div');
    card.className = 'agent-card';
    card.dataset.agentId = agent.id;
    card.title = agent.description; // Set description as tooltip
    
    // Create chat link that stops propagation
    const chatLink = document.createElement('a');
    chatLink.className = 'chat-link';
    chatLink.href = `/chat#persona=${agent.id}`;
    chatLink.innerHTML = 'üí¨';
    chatLink.title = `Chat with ${agent.title}`;
    chatLink.onclick = (e) => {
      e.stopPropagation(); // Prevent card click when clicking chat link
    };
    
    card.innerHTML = `
      <h3>${agent.title}</h3>
    `;
    
    card.appendChild(chatLink);
    card.addEventListener('click', (e) => {
      viewAgentDetails(agent.id, e);
    });
    
    container.appendChild(card);
  });
}

// View agent details in modal
function viewAgentDetails(agentId, event) {
  event.stopPropagation();
  
  const agent = availableAgents.find(a => a.id === agentId);
  if (!agent) return;
  
  currentEditingAgent = agentId;
  isEditMode = false;
  
  // Reset edit mode UI
  const editBtn = document.getElementById('editBtn');
  const saveBtn = document.getElementById('saveBtn');
  const modalHeader = document.getElementById('modalHeader');
  
  editBtn.style.display = 'block';
  saveBtn.style.display = 'none';
  modalHeader.classList.remove('edit-mode');
  document.getElementById('modalTitle').style.display = 'block';
  document.getElementById('modalTitleEdit').style.display = 'none';
  document.getElementById('modalContent').style.display = 'block';
  document.getElementById('modalContentEdit').style.display = 'none';
  
  document.getElementById('modalTitle').textContent = agent.title;
  document.getElementById('modalTitleEdit').value = agent.title;
  document.getElementById('modalContent').innerHTML = '<p>Loading...</p>';
  document.getElementById('agentModal').style.display = 'block';
  
  // Load and render agent content
  fetch(`{{ url_for('agents.agent_content', agent_id='') }}${agentId}`)
    .then(r => r.json())
    .then(data => {
      if (data.error) {
        document.getElementById('modalContent').innerHTML = `<p>Error: ${data.error}</p>`;
        document.getElementById('modalContentEdit').value = '';
      } else {
        // Store raw markdown for editing
        document.getElementById('modalContentEdit').value = data.content;
        // Convert markdown to HTML for display
        const html = marked.parse(data.content);
        document.getElementById('modalContent').innerHTML = html;
      }
    })
    .catch(err => {
      document.getElementById('modalContent').innerHTML = `<p>Error loading content: ${err.message}</p>`;
      document.getElementById('modalContentEdit').value = '';
    });
}

// Toggle edit mode for persona
function toggleEditMode() {
  const editBtn = document.getElementById('editBtn');
  const saveBtn = document.getElementById('saveBtn');
  const modalHeader = document.getElementById('modalHeader');
  const titleDisplay = document.getElementById('modalTitle');
  const titleEdit = document.getElementById('modalTitleEdit');
  const contentDisplay = document.getElementById('modalContent');
  const contentEdit = document.getElementById('modalContentEdit');
  
  if (!isEditMode) {
    // Enter edit mode
    isEditMode = true;
    editBtn.style.display = 'none';
    saveBtn.style.display = 'block';
    modalHeader.classList.add('edit-mode');
    
    titleDisplay.style.display = 'none';
    titleEdit.style.display = 'block';
    contentDisplay.style.display = 'none';
    contentEdit.style.display = 'block';
    
    // Focus on title input
    titleEdit.focus();
  }
}

// Save persona changes
async function savePersonaChanges() {
  const editBtn = document.getElementById('editBtn');
  const saveBtn = document.getElementById('saveBtn');
  const modalHeader = document.getElementById('modalHeader');
  const newTitle = document.getElementById('modalTitleEdit').value.trim();
  const newContent = document.getElementById('modalContentEdit').value.trim();
  
  if (!newTitle || !newContent) {
    showError('Title and content cannot be empty');
    return;
  }
  
  if (!currentEditingAgent) {
    showError('No agent selected for editing');
    return;
  }
  
  saveBtn.disabled = true;
  saveBtn.textContent = 'Saving...';
  
  try {
    const response = await fetch(`{{ url_for('agents.update_agent', agent_id='') }}${currentEditingAgent}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        title: newTitle,
        content: newContent
      })
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to save changes');
    }
    
    // Update local data
    const agent = availableAgents.find(a => a.id === currentEditingAgent);
    if (agent) {
      agent.title = newTitle;
      // Update the agent card if it exists
      const card = document.querySelector(`[data-agent-id="${currentEditingAgent}"] h3`);
      if (card) {
        card.textContent = newTitle;
      }
    }
    
    // Exit edit mode and update display
    isEditMode = false;
    editBtn.style.display = 'block';
    saveBtn.style.display = 'none';
    modalHeader.classList.remove('edit-mode');
    
    document.getElementById('modalTitle').textContent = newTitle;
    document.getElementById('modalTitle').style.display = 'block';
    document.getElementById('modalTitleEdit').style.display = 'none';
    
    // Update content display with new markdown
    const html = marked.parse(newContent);
    document.getElementById('modalContent').innerHTML = html;
    document.getElementById('modalContent').style.display = 'block';
    document.getElementById('modalContentEdit').style.display = 'none';
    
    // Refresh persona dropdown in planning modal if it's open
    loadPersonas();
    
  } catch (error) {
    showError('Error saving changes: ' + error.message);
  } finally {
    saveBtn.disabled = false;
    saveBtn.textContent = 'Save';
  }
}

// Form submission - removed as agentForm doesn't exist in this template
// The create persona functionality is handled by createPersonaForm instead

// Show planning modal with plan
function showPlanningModal(plan) {
  const modal = document.getElementById('planningModal');
  const editor = document.getElementById('planEditor');
  
  // Set the plan in the editor
  editor.value = plan;
  
  // Update preview
  updatePreview();
  
  // Load available personas
  loadPersonas();
  
  // Show modal
  modal.style.display = 'block';
}

// Close planning modal
function closePlanningModal() {
  document.getElementById('planningModal').style.display = 'none';
}

// Switch between tabs
function switchTab(tabName) {
  // Update tab buttons
  document.querySelectorAll('.modal-tab').forEach(tab => {
    tab.classList.remove('active');
  });
  event.target.classList.add('active');
  
  // Update tab content
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.remove('active');
  });
  document.getElementById(tabName + 'Tab').classList.add('active');
  
  // Update preview if switching to preview tab
  if (tabName === 'preview') {
    updatePreview();
  }
}

// Update markdown preview
function updatePreview() {
  const editor = document.getElementById('planEditor');
  const preview = document.getElementById('planPreview');
  
  if (editor.value.trim()) {
    preview.innerHTML = marked.parse(editor.value);
  } else {
    preview.innerHTML = '<p><em>No plan content to preview</em></p>';
  }
}

// Load available personas
function loadPersonas() {
  fetch('{{ url_for('agents.available_agents') }}')
    .then(r => r.json())
    .then(agents => {
      const select = document.getElementById('agentPersona');
      select.innerHTML = '<option value="default">Default</option>';
      
      agents.forEach(agent => {
        const option = document.createElement('option');
        option.value = agent.id;
        option.textContent = agent.title;
        select.appendChild(option);
      });
    })
    .catch(err => {
      console.error('Failed to load personas:', err);
    });
}

// Start agent with current plan and config
async function startAgent() {
  const plan = document.getElementById('planEditor').value.trim();
  if (!plan) {
    showError('Please provide a plan before starting the agent.');
    return;
  }
  
  const backend = document.getElementById('agentBackend').value;
  const model = document.getElementById('agentModel').value.trim();
  const maxTokens = parseInt(document.getElementById('maxTokens').value) || 0;
  const persona = document.getElementById('agentPersona').value;
  
  const startBtn = document.getElementById('startAgentBtn');
  startBtn.disabled = true;
  startBtn.textContent = 'üöÄ Starting...';
  
  try {
    const response = await fetch('{{ url_for('agents.start_agent') }}', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        plan: plan,
        backend: backend,
        model: model,
        max_tokens: maxTokens,
        persona: persona
      })
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to start agent');
    }
    
    // Success - close modal and reload agents
    closePlanningModal();
    loadAgentSessions();
    
    // Clear the input form
    document.getElementById('agentInput').value = '';
    
  } catch (error) {
    showError('Error starting agent: ' + error.message);
  } finally {
    startBtn.disabled = false;
    startBtn.textContent = 'üöÄ Start Agent';
  }
}

// Close agent modal function
function closeAgentModal() {
  // Reset edit mode when closing
  if (isEditMode) {
    isEditMode = false;
    const editBtn = document.getElementById('editBtn');
    const saveBtn = document.getElementById('saveBtn');
    const modalHeader = document.getElementById('modalHeader');
    
    editBtn.style.display = 'block';
    saveBtn.style.display = 'none';
    modalHeader.classList.remove('edit-mode');
    document.getElementById('modalTitle').style.display = 'block';
    document.getElementById('modalTitleEdit').style.display = 'none';
    document.getElementById('modalContent').style.display = 'block';
    document.getElementById('modalContentEdit').style.display = 'none';
  }
  document.getElementById('agentModal').style.display = 'none';
}

// Moved to bottom of script with createPersonaModal handling

// Pagination state
let currentPage = 0;
let pageSize = 10;
let totalAgents = 0;

// Session history table functions
function buildRow(a) {
  const tr = document.createElement('tr');
  const short = a.prompt.length > 80 ? a.prompt.slice(0, 80) + '‚Ä¶' : a.prompt;
  const chatLink = `{{ url_for('chat.chat_page') }}#${a.id}`;
  
  // Status badge
  const statusClass = `status-${a.status || 'unknown'}`;
  const statusBadge = `<span class="status-badge ${statusClass}">${a.status || 'unknown'}</span>`;
  
  // PID indicator for running agents
  const pidIndicator = a.pid ? ` (PID: ${a.pid})` : '';
  
  // Format runtime
  let runtimeDisplay = '';
  if (a.runtime_seconds !== undefined && a.runtime_seconds !== null) {
    const totalSeconds = Math.floor(a.runtime_seconds);
    const minutes = Math.floor(totalSeconds / 60);
    
    if (totalSeconds > 59) {
      // For 60 seconds or more, show just minutes
      runtimeDisplay = `${minutes}m`;
    } else {
      // For less than 60 seconds, show as Xs
      runtimeDisplay = `${totalSeconds}s`;
    }
  }
  
  tr.innerHTML = `
    <td><a href="${chatLink}">${statusBadge}</a></td>
    <td><a href="${chatLink}">${a.since}</a></td>
    <td>${runtimeDisplay}</td>
    <td>${a.model}${pidIndicator}</td>
    <td>${a.persona_title || a.persona}</td>
    <td title="${a.prompt}"><a href="${chatLink}">${short}</a></td>
  `;
  tr.style.cursor = 'pointer';
  tr.onclick = () => window.location.href = chatLink;
  return tr;
}

function loadAgentSessions(page = 0) {
  const offset = page * pageSize;
  fetch(`{{ url_for('agents.agents_list') }}?type=all&limit=${pageSize}&offset=${offset}`)
    .then(r => {
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      return r.json();
    })
    .then(data => {
      // Check for API error response
      if (data.error) {
        throw new Error(data.error);
      }
      
      const agents = data.agents || [];
      const pagination = data.pagination;
      const liveCount = data.live_count || 0;
      const historicalCount = data.historical_count || 0;
      
      // Separate live and historical agents
      const liveAgents = agents.filter(a => a.is_live);
      const historicalAgents = agents.filter(a => !a.is_live);
      
      // Update counts
      document.getElementById('liveCount').textContent = liveCount;
      document.getElementById('historicalCount').textContent = historicalCount;
      
      // Update live agents table
      const liveTable = document.getElementById('liveAgentTable');
      const liveEmpty = document.getElementById('liveEmpty');
      
      if (liveAgents.length > 0) {
        liveTable.innerHTML = '<tr><th>Status</th><th>Started</th><th>Runtime</th><th>Model</th><th>Persona</th><th>Prompt</th></tr>';
        liveAgents.forEach(a => liveTable.appendChild(buildRow(a)));
        liveTable.style.display = 'table';
        liveEmpty.style.display = 'none';
      } else {
        liveTable.style.display = 'none';
        liveEmpty.style.display = 'block';
      }
      
      // Update historical agents table
      const histTable = document.getElementById('historicalAgentTable');
      const histEmpty = document.getElementById('historicalEmpty');
      
      if (historicalAgents.length > 0) {
        histTable.innerHTML = '<tr><th>Status</th><th>Started</th><th>Runtime</th><th>Model</th><th>Persona</th><th>Prompt</th></tr>';
        historicalAgents.forEach(a => histTable.appendChild(buildRow(a)));
        histTable.style.display = 'table';
        histEmpty.style.display = 'none';
      } else {
        histTable.style.display = 'none';
        histEmpty.style.display = 'block';
      }
      
      // Update pagination if available
      if (pagination && pagination.total > pagination.limit) {
        currentPage = Math.floor(pagination.offset / pagination.limit);
        totalAgents = pagination.total;
        updatePagination(pagination);
      } else {
        document.getElementById('pagination').style.display = 'none';
      }
      
      // Hide any previous error warnings
      hideConnectionWarning();
    })
    .catch(err => {
      console.error('Failed to load agents:', err);
      
      // Still try to load historical agents even if cortex is down
      fetch(`{{ url_for('agents.agents_list') }}?type=historical&limit=${pageSize}&offset=${offset}`)
        .then(r => r.json())
        .then(data => {
          const historicalAgents = data.agents || [];
          const historicalCount = data.historical_count || 0;
          
          // Update historical count
          document.getElementById('historicalCount').textContent = historicalCount;
          
          // Clear live agents section
          document.getElementById('liveCount').textContent = '0';
          document.getElementById('liveAgentTable').style.display = 'none';
          document.getElementById('liveEmpty').style.display = 'block';
          
          // Update historical agents table
          const histTable = document.getElementById('historicalAgentTable');
          const histEmpty = document.getElementById('historicalEmpty');
          
          if (historicalAgents.length > 0) {
            histTable.innerHTML = '<tr><th>Status</th><th>Started</th><th>Runtime</th><th>Model</th><th>Persona</th><th>Prompt</th></tr>';
            historicalAgents.forEach(a => histTable.appendChild(buildRow(a)));
            histTable.style.display = 'table';
            histEmpty.style.display = 'none';
          } else {
            histTable.style.display = 'none';
            histEmpty.style.display = 'block';
          }
          
          // Update pagination
          if (data.pagination && data.pagination.total > data.pagination.limit) {
            updatePagination(data.pagination);
          } else {
            document.getElementById('pagination').style.display = 'none';
          }
        })
        .catch(() => {
          // Total failure - clear everything
          document.getElementById('liveCount').textContent = '0';
          document.getElementById('historicalCount').textContent = '0';
          document.getElementById('liveAgentTable').style.display = 'none';
          document.getElementById('liveEmpty').style.display = 'block';
          document.getElementById('historicalAgentTable').style.display = 'none';
          document.getElementById('historicalEmpty').style.display = 'block';
          document.getElementById('pagination').style.display = 'none';
        });
    });
}

function updatePagination(pagination) {
  const paginationDiv = document.getElementById('pagination');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const pageInfo = document.getElementById('pageInfo');
  
  if (pagination.total > pagination.limit) {
    paginationDiv.style.display = 'flex';
    
    const currentPageNum = Math.floor(pagination.offset / pagination.limit) + 1;
    const totalPages = Math.ceil(pagination.total / pagination.limit);
    
    pageInfo.textContent = `Page ${currentPageNum} of ${totalPages} (${pagination.total} total)`;
    
    prevBtn.disabled = pagination.offset === 0;
    nextBtn.disabled = !pagination.has_more;
  } else {
    paginationDiv.style.display = 'none';
  }
}

function changePage(delta) {
  const newPage = currentPage + delta;
  if (newPage >= 0) {
    loadAgentSessions(newPage);
  }
}

// Connection warning functions
function showConnectionWarning(message) {
  let warning = document.getElementById('connectionWarning');
  if (!warning) {
    warning = document.createElement('div');
    warning.id = 'connectionWarning';
    warning.style.cssText = 'background:#f8d7da;border:1px solid #f5c6cb;color:#721c24;padding:0.75rem;margin:1rem 0;border-radius:4px;text-align:center;';
    const container = document.querySelector('.container');
    const firstChild = container.children[1]; // Insert after h1
    container.insertBefore(warning, firstChild);
  }
  warning.innerHTML = `‚ö†Ô∏è <strong>Cortex Service Unavailable:</strong> ${message}`;
  warning.style.display = 'block';
}

function hideConnectionWarning() {
  const warning = document.getElementById('connectionWarning');
  if (warning) {
    warning.style.display = 'none';
  }
}

// Show error message
function showError(message) {
  alert(message); // Simple alert for now, can be improved with a toast notification
}

// Create Persona Modal Functions
function openCreatePersonaModal() {
  const modal = document.getElementById('createPersonaModal');
  modal.style.display = 'block';
  
  // Reset form
  document.getElementById('createPersonaForm').reset();
  document.getElementById('createPersonaPlanningStatus').classList.remove('show');
  document.getElementById('personaResult').style.display = 'none';
  document.getElementById('createPlanBtn').disabled = false;
}

function closeCreatePersonaModal() {
  document.getElementById('createPersonaModal').style.display = 'none';
}

// Handle create persona form submission
document.getElementById('createPersonaForm').addEventListener('submit', async (e) => {
  e.preventDefault();
  
  const title = document.getElementById('personaTitle').value.trim();
  const input = document.getElementById('personaInput').value.trim();
  const form = e.target;
  const status = document.getElementById('createPersonaPlanningStatus');
  const createBtn = document.getElementById('createPlanBtn');
  
  if (!title || !input) return;
  
  // Show planning status
  form.classList.add('busy');
  status.classList.add('show');
  createBtn.disabled = true;
  
  try {
    const response = await fetch('{{ url_for('agents.create_plan') }}', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        request: input,
        model: '' // Uses Gemini Pro by default
      })
    });
    
    const data = await response.json();
    
    if (!response.ok) {
      throw new Error(data.error || 'Failed to create plan');
    }
    
    // Show the generated plan
    showPersonaResult(data.plan, title);
    
  } catch (error) {
    showError('Error creating plan: ' + error.message);
    createBtn.disabled = false;
  } finally {
    // Remove busy state
    form.classList.remove('busy');
    status.classList.remove('show');
  }
});

function showPersonaResult(plan, title) {
  const resultDiv = document.getElementById('personaResult');
  const resultContent = document.getElementById('personaResultContent');
  
  // Store plan and title for saving
  window.currentPersonaPlan = plan;
  window.currentPersonaTitle = title;
  
  // Display the plan
  resultContent.textContent = plan;
  resultDiv.style.display = 'block';
  
  // Hide form
  document.getElementById('createPersonaForm').style.display = 'none';
}

function editPersonaPlan() {
  const resultContent = document.getElementById('personaResultContent');
  
  // Convert to editable textarea
  const textarea = document.createElement('textarea');
  textarea.value = resultContent.textContent;
  textarea.style.width = '100%';
  textarea.style.minHeight = '400px';
  textarea.style.padding = '1rem';
  textarea.style.fontFamily = 'Monaco, Menlo, monospace';
  textarea.style.fontSize = '0.9rem';
  
  resultContent.innerHTML = '';
  resultContent.appendChild(textarea);
  
  // Update the plan when editing
  textarea.addEventListener('input', () => {
    window.currentPersonaPlan = textarea.value;
  });
}

async function saveNewPersona() {
  const title = window.currentPersonaTitle;
  const content = window.currentPersonaPlan;
  
  if (!title || !content) {
    showError('Missing title or content');
    return;
  }
  
  // Generate a unique ID for the new persona
  const personaId = title.toLowerCase().replace(/[^a-z0-9]+/g, '_');
  
  try {
    // Create or update the persona
    const response = await fetch(`{{ url_for('agents.update_agent', agent_id='') }}${personaId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        title: title,
        content: content
      })
    });
    
    const data = await response.json();
    
    if (response.ok) {
      alert('Persona saved successfully!');
      closeCreatePersonaModal();
      // Reset form for next use
      document.getElementById('createPersonaForm').style.display = 'block';
      document.getElementById('personaResult').style.display = 'none';
      // Reload personas
      loadAvailableAgents();
    } else {
      throw new Error(data.error || 'Failed to save persona');
    }
  } catch (error) {
    showError('Error saving persona: ' + error.message);
  }
}

// Update modal close handlers
window.onclick = function(event) {
  const agentModal = document.getElementById('agentModal');
  const planningModal = document.getElementById('planningModal');
  const createPersonaModal = document.getElementById('createPersonaModal');
  
  if (event.target == agentModal) {
    closeAgentModal();
  }
  if (event.target == planningModal) {
    planningModal.style.display = 'none';
  }
  if (event.target == createPersonaModal) {
    createPersonaModal.style.display = 'none';
  }
};

// Auto-refresh live agents
let refreshInterval = null;

function startAutoRefresh() {
  // Refresh every 5 seconds if on the log tab
  if (currentMainTab === 'log' && !refreshInterval) {
    refreshInterval = setInterval(() => {
      if (document.visibilityState === 'visible') {
        // Only refresh the current page
        loadAgentSessions(currentPage);
      }
    }, 5000);
  }
}

function stopAutoRefresh() {
  if (refreshInterval) {
    clearInterval(refreshInterval);
    refreshInterval = null;
  }
}

// Start/stop refresh based on tab
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden') {
    stopAutoRefresh();
  } else if (currentMainTab === 'log') {
    startAutoRefresh();
  }
});

// Initialize - The Log tab is shown by default now
setTimeout(() => {
  loadAgentSessions();
  startAutoRefresh();
}, 100);
</script>
{% endblock %}
