{% extends 'base.html' %}
{% set title = 'Calendar' %}
{% set active = 'calendar' %}
{% block head %}
<style>
.container { padding: 0 1em; }
h1 { margin-bottom: 0.5em; }
#controls { display: flex; align-items: center; margin-bottom: 1em; }
#controls button { background:#007bff; color:white; border:none; padding:6px 12px; margin:0 6px; border-radius:4px; cursor:pointer; }
#controls span { font-size:1.2em; font-weight:bold; }
#calendar { width:100%; border-collapse:collapse; }
#calendar th, #calendar td { width:14.28%; border:1px solid #e0e0e0; height:80px; padding:4px; }
#calendar td { display:flex; flex-direction:column; }
#calendar th { background:#f8f9fa; }
.day-number{font-weight:bold;text-decoration:none;color:inherit;}
.bar-chart{flex:1;display:flex;align-items:flex-end;gap:1px;text-decoration:none;}
.bar-chart div{flex:1;min-width:2px;}
</style>
{% endblock %}
{% block body %}
<div class="container">
  <h1>Calendar</h1>
  <div id="controls">
    <button id="prevMonth">&#8592;</button>
    <span id="monthLabel"></span>
    <button id="nextMonth">&#8594;</button>
  </div>
  <table id="calendar">
    <thead>
      <tr><th>Sun</th><th>Mon</th><th>Tue</th><th>Wed</th><th>Thu</th><th>Fri</th><th>Sat</th></tr>
    </thead>
    <tbody></tbody>
  </table>
</div>


<script>
let occurrences = {};
const dayBase = '{{ url_for("calendar.calendar_day", day="") }}';
let months = [];
let currentIndex = 0;

function loadData() {
  fetch('{{ url_for("calendar.calendar_occurrences") }}')
    .then(r => {
      if (!r.ok) throw new Error('Failed to fetch occurrences');
      return r.json();
    })
    .then(d => {
      occurrences = d || {};
      months = Array.from(new Set(Object.keys(occurrences).map(d => d.slice(0,6)))).sort();
      if(!months.length) {
        const now = new Date();
        months = [generateYearMonth(now.getFullYear(), now.getMonth())];
      }
      currentIndex = months.length - 1;
      showMonth(months[currentIndex]);
    })
    .catch(err => {
      console.error('Error loading occurrences:', err);
      const now = new Date();
      months = [generateYearMonth(now.getFullYear(), now.getMonth())];
      currentIndex = 0;
      showMonth(months[currentIndex]);
    });
}

const COLORS = ['#007bff','#28a745','#17a2b8','#ffc107','#6f42c1','#fd7e14','#e83e8c','#6c757d','#20c997','#ff5722','#9c27b0','#795548'];

function computeSlugColors(events){
  const slugs = [];
  const processed = [];
  events.forEach(o => {
    if(!o.startTime) return;
    const start = new Date(o.startTime);
    const end = o.endTime ? new Date(o.endTime) : new Date(start.getTime()+300000);
    const s = start.getHours()*60 + start.getMinutes();
    const e = end.getHours()*60 + end.getMinutes();
    if(s === 0) return;
    const slug = o.slug || 'other';
    if(!slugs.includes(slug)) slugs.push(slug);
    processed.push({slug,startMinutes:s,endMinutes:e});
  });
  const eventsBySlug = {};
  slugs.forEach(slug=>{
    eventsBySlug[slug] = processed.filter(e=>e.slug===slug).sort((a,b)=>a.startMinutes-b.startMinutes);
  });
  const slugColumnCounts = {};
  slugs.forEach(slug=>{
    const slugEvents = eventsBySlug[slug];
    const cols = [];
    slugEvents.forEach(evt=>{
      let i=0;
      while(i<cols.length && cols[i].some(ex=>evt.startMinutes < ex.endMinutes && evt.endMinutes > ex.startMinutes)) i++;
      if(i===cols.length) cols.push([]);
      cols[i].push(evt);
    });
    slugColumnCounts[slug] = cols.length;
  });
  let offset=0;
  const slugOffsets={};
  slugs.forEach(slug=>{slugOffsets[slug]=offset;offset+=slugColumnCounts[slug];});
  const sorted = [...slugs].sort((a,b)=>slugOffsets[a]-slugOffsets[b]);
  const colors={};
  sorted.forEach((s,i)=>{colors[s]=COLORS[i%COLORS.length];});
  return colors;
}

function createOccurrenceChart(dateStr, events){
  const counts = {};
  events.forEach(o=>{
    const s = o.slug || 'other';
    counts[s] = (counts[s]||0)+1;
  });
  const colors = computeSlugColors(events);
  const chart = document.createElement('a');
  chart.className = 'bar-chart';
  chart.href = dayBase + dateStr;
  const maxCount = Math.max(...Object.values(counts));
  Object.keys(counts).forEach(slug=>{
    const bar = document.createElement('div');
    bar.style.height = (counts[slug]/maxCount*100)+'%';
    bar.style.background = colors[slug] || '#6c757d';
    bar.title = `${slug}: ${counts[slug]}`;
    chart.appendChild(bar);
  });
  return chart;
}

function showMonth(ym) {
  const year = parseInt(ym.slice(0,4));
  const month = parseInt(ym.slice(4)) - 1;
  const first = new Date(year, month, 1);
  document.getElementById('monthLabel').textContent = first.toLocaleString('default',{month:'long', year:'numeric'});
  const tbody = document.querySelector('#calendar tbody');
  tbody.innerHTML='';
  const startDay = first.getDay();
  const daysInMonth = new Date(year, month+1, 0).getDate();
  let row = document.createElement('tr');
  
  // Empty cells for days before month starts
  for(let i=0; i<startDay; i++){ 
    row.appendChild(document.createElement('td')); 
  }
  
  // Days of the month
  for(let day=1; day<=daysInMonth; day++){
    if((startDay+day-1)%7===0 && day!==1){ 
      tbody.appendChild(row); 
      row=document.createElement('tr'); 
    }
    const td = document.createElement('td');
    const dateStr = ym + String(day).padStart(2,'0');
    const count = (occurrences[dateStr] || []).length;
    
    td.innerHTML = `<a class='day-number' href='${dayBase}${dateStr}'>${day}</a>`;
    if(count){
      td.appendChild(createOccurrenceChart(dateStr, occurrences[dateStr]));
    }
    row.appendChild(td);
  }
  
  // Fill remaining cells in last row
  while(row.children.length<7){ 
    row.appendChild(document.createElement('td')); 
  }
  tbody.appendChild(row);
}


function generateYearMonth(year, month) {
  return year + String(month + 1).padStart(2, '0');
}

function navigateMonth(direction) {
  const newIndex = currentIndex + direction;
  
  if (newIndex >= 0 && newIndex < months.length) {
    currentIndex = newIndex;
    showMonth(months[currentIndex]);
    return;
  }
  
  // Generate new month if at boundaries
  const isNext = direction > 0;
  const referenceYm = months[isNext ? months.length - 1 : 0];
  const year = parseInt(referenceYm.slice(0,4));
  const month = parseInt(referenceYm.slice(4)) - 1;
  const newDate = new Date(year, month + direction, 1);
  const newYm = generateYearMonth(newDate.getFullYear(), newDate.getMonth());
  
  if (isNext) {
    months.push(newYm);
    currentIndex = months.length - 1;
  } else {
    months.unshift(newYm);
    currentIndex = 0;
  }
  showMonth(months[currentIndex]);
}


document.getElementById('prevMonth').onclick = () => navigateMonth(-1);
document.getElementById('nextMonth').onclick = () => navigateMonth(1);

loadData();
</script>
{% endblock %}

