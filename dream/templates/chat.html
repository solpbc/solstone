{% extends 'base.html' %}
{% set title = 'Chat' %}
{% set active = 'chat' %}
{% block head %}
<style>
body {height:100vh; overflow:hidden;}
.container {height:100vh; display:flex; flex-direction:column; position:relative; padding:0 1em;}
#messages {flex:1; overflow-y:auto; padding:1em; padding-bottom:0; display:flex; flex-direction:column;}
.message {margin-bottom:0.75em; padding:0.75em 1em; border-radius:12px; max-width:75%; box-shadow:0 1px 3px rgba(0,0,0,0.1); animation:fadeInUp 0.3s ease-out;}
.from-user {background:linear-gradient(135deg, #667eea 0%, #764ba2 100%); color:white; align-self:flex-end; margin-left:20%;}
.from-bot {background:#fff; border:1px solid #e0e0e0; align-self:flex-start; margin-right:20%;}
@keyframes fadeInUp {from{opacity:0;transform:translateY(10px);}to{opacity:1;transform:translateY(0);}}
#messages .event-card{background:#fff4e5;border:1px solid #f0ad4e;border-radius:6px;padding:0.5em 0.75em;margin-bottom:0.75em;font-size:0.85em;max-width:80%;align-self:flex-start;}
#messages .event-card a{text-decoration:none;color:#007bff;}
#messages .event-card a:hover{text-decoration:underline;}
#messages .tool-placard{background:#e3f2fd;border:1px solid #2196f3;border-radius:6px;padding:0.4em 0.6em;margin-bottom:0.5em;font-size:0.8em;max-width:60%;align-self:flex-start;cursor:help;position:relative;}
#messages .tool-placard:hover{background:#bbdefb;}
#messages .tool-placard .tool-name{font-weight:bold;color:#1976d2;}
#messages .tool-placard .tool-status{font-size:0.9em;color:#666;margin-left:0.5em;}
#messages .tool-placard.completed{background:#e8f5e9;border-color:#4caf50;}
#messages .tool-placard.completed .tool-name{color:#2e7d32;}
#messages .tool-placard .tool-tooltip{visibility:hidden;background:#333;color:#fff;text-align:left;border-radius:4px;padding:0.5em;position:absolute;z-index:1000;bottom:125%;left:0;min-width:300px;max-width:500px;font-size:0.75em;font-family:monospace;white-space:pre-wrap;opacity:0;transition:opacity 0.3s;}
#messages .tool-placard:hover .tool-tooltip{visibility:visible;opacity:1;}
#messages .agent-update{background:#fff3e0;border:1px solid #ff9800;border-radius:6px;padding:0.4em 0.6em;margin-bottom:0.5em;font-size:0.8em;max-width:60%;align-self:flex-start;color:#e65100;font-style:italic;}
#messages .thinking-card{background:#f8f4ff;border:1px solid #9c27b0;border-radius:6px;padding:0.5em 0.75em;margin-bottom:0.75em;font-size:0.85em;max-width:80%;align-self:flex-start;cursor:pointer;}
#messages .thinking-card:hover{background:#f3e5f5;}
#messages .thinking-card .thinking-label{font-weight:bold;color:#7b1fa2;margin-bottom:0.25em;}
#messages .thinking-card .thinking-content{color:#333;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
#messages .thinking-card.expanded .thinking-content{white-space:pre-wrap;overflow:visible;text-overflow:clip;}
#drawer {display:none; border-top:1px solid #ddd; padding:0.5em; background:#fafafa;}
.input-tray {background:#f8f9fa; border-top:1px solid #e0e0e0; padding:1em;}
.input-area {display:flex; gap:0.5em; align-items:center;}
#messageInput {flex:1; resize:none; border:1px solid #ddd; border-radius:20px; padding:0.75em 1em; font-family:inherit; font-size:14px; line-height:1.5; max-height:120px; min-height:42px;}
#messageInput:focus {outline:none; border-color:#667eea;}
#backendSelect {padding:0.75em 1em; border:1px solid #ddd; border-radius:20px; background:white; cursor:pointer; font-weight:500; height:42px; font-size:14px;}
#backendSelect option[value="google"] {background:#4285f4; color:white;}
#backendSelect option[value="openai"] {background:#10a37f; color:white;}
#backendSelect option[value="anthropic"] {background:#764ba2; color:white;}
.input-area button {padding:0.75em 1.2em; border:none; border-radius:20px; cursor:pointer; font-weight:500; transition:all 0.2s; height:42px; font-size:14px;}
.input-area button[type="submit"] {background:#667eea; color:white;}
.input-area button[type="submit"]:hover {background:#5a67d8; transform:translateY(-1px);}
.input-area button[type="button"] {background:#e0e0e0; color:#333;}
.input-area button[type="button"]:hover {background:#d0d0d0;}
.message h1,.message h2,.message h3,.message h4,.message h5,.message h6 {margin:0.5em 0 0.3em 0;}
.message p {margin:0.3em 0;}
.message ul,.message ol {margin:0.3em 0; padding-left:1.5em;}
.message code {background:rgba(0,0,0,0.1); padding:0.1em 0.3em; border-radius:3px; font-size:0.9em;}
.from-user code {background:rgba(255,255,255,0.2);}
.message pre {background:rgba(0,0,0,0.1); padding:0.5em; border-radius:4px; overflow-x:auto; margin:0.5em 0;}
.from-user pre {background:rgba(255,255,255,0.15);}
.message pre code {background:none; padding:0;}
.message blockquote {margin:0.5em 0; padding-left:1em; border-left:3px solid rgba(0,0,0,0.2);}
.from-user blockquote {border-left-color:rgba(255,255,255,0.4);}
.typing-indicator {display:none; align-self:flex-start; padding:0.75em 1em; background:#f0f0f0; border-radius:12px; margin-bottom:0.75em; max-width:80px;}
.typing-indicator.show {display:flex; align-items:center; gap:4px; animation:fadeInUp 0.3s ease-out;}
.typing-indicator span {width:8px; height:8px; background:#999; border-radius:50%; animation:typingBounce 1.4s infinite ease-in-out;}
.typing-indicator span:nth-child(1) {animation-delay:-0.32s;}
.typing-indicator span:nth-child(2) {animation-delay:-0.16s;}
@keyframes typingBounce {0%,80%,100%{transform:scale(0.8);opacity:0.5;}40%{transform:scale(1);opacity:1;}}
.activity-indicator {align-self:flex-start; padding:0.75em 1em; background:#f0f0f0; border-radius:12px; margin-bottom:0.75em; margin-top:0.5em; max-width:80px; display:none;}
.activity-indicator.active {display:flex; align-items:center; gap:4px; animation:fadeInUp 0.3s ease-out;}
.activity-indicator span {width:8px; height:8px; background:#999; border-radius:50%; animation:typingBounce 1.4s infinite ease-in-out;}
.activity-indicator span:nth-child(1) {animation-delay:-0.32s;}
.activity-indicator span:nth-child(2) {animation-delay:-0.16s;}
</style>
{% endblock %}
{% block body %}
<div class="container">
  <div id="messages">
    <div class="typing-indicator" id="typingIndicator">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>
  <div id="drawer">Attachments drawer</div>
  <div class="input-tray">
    <form id="inputArea" class="input-area">
      <select id="backendSelect">
        <option value="google">ðŸ”µ Google</option>
        <option value="openai" selected>ðŸŸ¢ OpenAI</option>
        <option value="anthropic">ðŸŸ£ Claude</option>
      </select>
      <textarea id="messageInput" rows="1" placeholder="Send a message..."></textarea>
      <button type="submit">Send</button>
      <button type="button" id="clearBtn">Clear</button>
    </form>
  </div>
</div>
<script>
const sendUrl = '{{ url_for('chat.send_message') }}';
const historyUrl = '{{ url_for('chat.chat_history') }}';
const clearUrl = '{{ url_for('chat.clear_history') }}';
const agentUrl = '{{ url_for('chat.agent_events', agent_id='AGENT_ID') }}';
const form = document.getElementById('inputArea');
const input = document.getElementById('messageInput');
const messagesDiv = document.getElementById('messages');
const backendSelect = document.getElementById('backendSelect');
const searchBase = '{{ url_for('search.search_page') }}';

// Create persistent activity indicator
const activityIndicator = document.createElement('div');
activityIndicator.className = 'activity-indicator';
activityIndicator.id = 'activityIndicator';
activityIndicator.innerHTML = '<span></span><span></span><span></span>';

// Track if we're currently processing events
let eventProcessingActive = false;
let eventTimeout = null;
let responseInProgress = false;

function showActivityIndicator() {
  if (!document.getElementById('activityIndicator')) {
    messagesDiv.appendChild(activityIndicator);
  }
  activityIndicator.classList.add('active');
  eventProcessingActive = true;
  
  // Auto-scroll to keep activity indicator in view
  requestAnimationFrame(() => {
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
  });
  
  // Clear any existing timeout
  if (eventTimeout) {
    clearTimeout(eventTimeout);
    eventTimeout = null;
  }
}

function hideActivityIndicator() {
  // Only hide if we're not expecting more events
  if (!responseInProgress) {
    // Set a small delay before hiding to handle rapid event sequences
    if (eventTimeout) {
      clearTimeout(eventTimeout);
    }
    eventTimeout = setTimeout(() => {
      activityIndicator.classList.remove('active');
      eventProcessingActive = false;
    }, 500);
  }
}

function forceHideActivityIndicator() {
  // Force hide without delay
  if (eventTimeout) {
    clearTimeout(eventTimeout);
    eventTimeout = null;
  }
  activityIndicator.classList.remove('active');
  eventProcessingActive = false;
  responseInProgress = false;
}

function ensureActivityIndicatorAtBottom() {
  // Ensure activity indicator is always the last element
  if (!activityIndicator.parentNode) {
    messagesDiv.appendChild(activityIndicator);
  } else if (activityIndicator.parentNode === messagesDiv && messagesDiv.lastElementChild !== activityIndicator) {
    messagesDiv.appendChild(activityIndicator);
  }
}

// Check if viewing historical agent
const fragment = window.location.hash.slice(1);
const isHistorical = fragment && /^\d+$/.test(fragment);

function addEventCard(text, url){
  const div=document.createElement('div');
  div.className='event-card';
  const a=document.createElement('a');
  a.href=url;
  a.textContent=text;
  div.appendChild(a);  // This line was missing!
  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

// Track tool calls by ID to update them when complete
const toolPlacards = {};

// Track agent switches - only show when switching between agents
let previousAgent = null;

function addToolPlacard(toolName, args, callId){
  const div=document.createElement('div');
  div.className='tool-placard';
  
  const nameSpan=document.createElement('span');
  nameSpan.className='tool-name';
  nameSpan.textContent='ðŸ”§ ' + toolName;
  div.appendChild(nameSpan);
  
  const statusSpan=document.createElement('span');
  statusSpan.className='tool-status';
  statusSpan.textContent='(running...)';
  div.appendChild(statusSpan);
  
  if(args){
    const tooltip=document.createElement('div');
    tooltip.className='tool-tooltip';
    tooltip.textContent=JSON.stringify(args, null, 2);
    div.appendChild(tooltip);
  }
  
  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
  
  // Store reference to update later
  if(callId){
    toolPlacards[callId] = {div, statusSpan};
  }
  return div;
}

function completeToolPlacard(callId, result){
  if(toolPlacards[callId]){
    const {div, statusSpan} = toolPlacards[callId];
    div.classList.add('completed');
    statusSpan.textContent = 'âœ“';
    
    // Add result to tooltip if exists
    const tooltip = div.querySelector('.tool-tooltip');
    if(tooltip && result){
      const resultText = typeof result === 'string' ? result : JSON.stringify(result, null, 2);
      tooltip.textContent += '\n\n=== Result ===\n' + resultText;
    }
    
    delete toolPlacards[callId];
  }
}

function addAgentUpdate(agentName){
  // Only show agent switch if we're actually switching from one agent to another
  if(previousAgent && previousAgent !== agentName){
    const div=document.createElement('div');
    div.className='agent-update';
    div.textContent=`â†’ Switched from ${previousAgent} to ${agentName} agent`;
    messagesDiv.insertBefore(div, activityIndicator);
    ensureActivityIndicatorAtBottom();
    messagesDiv.scrollTop=messagesDiv.scrollHeight;
  }
  previousAgent = agentName;
}

function addThinkingCard(summary, model){
  const div=document.createElement('div');
  div.className='thinking-card';
  
  const label=document.createElement('div');
  label.className='thinking-label';
  label.textContent=`ðŸ’­ Thinking (${model})`;
  div.appendChild(label);
  
  const content=document.createElement('div');
  content.className='thinking-content';
  content.textContent=summary;
  div.appendChild(content);
  
  div.addEventListener('click', () => {
    div.classList.toggle('expanded');
  });
  
  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}

input.focus();

input.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    form.requestSubmit();
  }
});
function addMessage(text, cls, isHtml=false){
  const div=document.createElement('div');
  div.className='message '+cls;
  // Use HTML for bot messages if provided, otherwise plain text
  if(isHtml && cls === 'from-bot'){
    div.innerHTML = text;
  } else {
    div.textContent = text;
  }
  messagesDiv.insertBefore(div, activityIndicator);
  ensureActivityIndicatorAtBottom();
  messagesDiv.scrollTop=messagesDiv.scrollHeight;
}
document.getElementById('inputArea').onsubmit=async e=>{
  e.preventDefault();
  const text=input.value.trim();
  if(!text)return;
  
  // Clear previous messages for fresh one-shot conversation
  messagesDiv.innerHTML='';
  
  // Reset agent tracking when starting new conversation
  previousAgent = null;
  
  // Add the activity indicator to the messages div
  messagesDiv.appendChild(activityIndicator);
  
  addMessage(text,'from-user');
  input.value='';
  
  // Show activity indicator and mark response as in progress
  responseInProgress = true;
  showActivityIndicator();
  
  const r=await fetch(sendUrl,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({message:text,backend:backendSelect.value})});
  
  if(r.ok){
    const d=await r.json();
    addMessage(d.html||d.text,'from-bot',!!d.html);
    // Response complete - force hide after a short delay
    responseInProgress = false;
    setTimeout(forceHideActivityIndicator, 1000);
  }else{
    responseInProgress = false;
    forceHideActivityIndicator();
    let err='Error';
    try{const d=await r.json();err=d.error||err;}catch{};
    if(window.showError)showError(err);
  }
};

async function loadHistory(){
  const r=await fetch(historyUrl);
  if(!r.ok)return;
  const d=await r.json();
  for(const m of d.history){
    addMessage(m.text,m.role==='user'?'from-user':'from-bot');
  }
}

async function loadHistoricalAgent(agentId){
  const url = agentUrl.replace('AGENT_ID', agentId);
  const r = await fetch(url);
  if(!r.ok){
    showError('Failed to load historical agent: ' + agentId);
    return;
  }
  const d = await r.json();
  
  // Process events in chronological order
  // This maintains the proper sequence of messages and tool calls
  for(const event of d.events){
    if(event.event === 'start'){
      // User message
      addMessage(event.prompt || '', 'from-user');
    } else if(event.event === 'finish'){
      // Assistant final response - use HTML if available for markdown formatting
      const text = event.result || '';
      const html = event.html || text;
      addMessage(html, 'from-bot', !!event.html);
    } else if(event.event === 'error'){
      // Error event - display as final response
      const text = event.result || event.error || 'Unknown error occurred';
      const html = event.html || text;
      addMessage(html, 'from-bot', !!event.html);
    } else {
      // All other events (tool calls, thinking, etc.)
      handleHistoricalEvent(event);
    }
  }
}

// Unified event handler for both live and historical events
function processEvent(event) {
  switch(event.event) {
    case 'tool_start':
      handleToolStart(event);
      break;
    case 'tool_end':
      completeToolPlacard(event.call_id, event.result);
      break;
    case 'thinking':
      addThinkingCard(event.summary, event.model || 'unknown');
      break;
    case 'agent_updated':
      addAgentUpdate(event.agent || 'unknown');
      break;
    case 'error':
      // Handle error events during live streaming
      // Since the backend already sends formatted HTML for errors,
      // we just need to display the message
      responseInProgress = false;
      forceHideActivityIndicator();
      // Note: The actual error message will be sent from backend
      // via the finish/error handling in _handle_cortex_event
      break;
  }
}

// Handle tool_start events
function handleToolStart(event) {
  const {tool, args, call_id} = event;
  
  // Handle search tools with special event cards
  if(args && args.query) {
    // Determine which index is being searched
    let idx = 'summaries';
    let indexName = 'Summaries';
    if(tool.includes('event')) {
      idx = 'events';
      indexName = 'Events';
    } else if(tool.includes('transcript')) {
      idx = 'transcripts';
      indexName = 'Transcripts';
    }
    
    // Extract date from query if present (format: YYYYMMDD or YYYY-MM-DD)
    let dateStr = '';
    const dateMatch = args.query.match(/\b(\d{8}|\d{4}-\d{2}-\d{2})\b/);
    if(dateMatch) {
      const dateRaw = dateMatch[1].replace(/-/g, '');
      const month = parseInt(dateRaw.substring(4, 6), 10);
      const day = parseInt(dateRaw.substring(6, 8), 10);
      dateStr = ` on ${month}/${day}`;
    }
    
    // Build search URL
    const q = args.query + (idx === 'summaries' ? '' : ' index:' + idx);
    const url = searchBase + '#q=' + encodeURIComponent(q);
    
    // Create descriptive text
    const searchText = `Searching ${indexName} for "${args.query}"${dateStr}`;
    addEventCard(searchText, url);
    return;
  }
  
  // Handle get_resource tool
  if(tool === 'get_resource' && args && args.uri) {
    const resourceCard = createResourceCard(args.uri);
    if(resourceCard) {
      addEventCard(resourceCard.text, resourceCard.url);
      return;
    }
  }
  
  // Default: show tool placard
  addToolPlacard(tool, args, call_id);
}

// Create resource card for get_resource tool
function createResourceCard(uri) {
  // Parse journal://summary/20250815/meetings format
  const match = uri.match(/journal:\/\/summary\/(\d{8})\/(.+)/);
  if(!match) return null;
  
  const date = match[1];
  const topic = match[2];
  
  // Format date as M/D
  const month = parseInt(date.substring(4, 6), 10);
  const day = parseInt(date.substring(6, 8), 10);
  const dateStr = `${month}/${day}`;
  
  // Capitalize first letter of topic
  const topicDisplay = topic.charAt(0).toUpperCase() + topic.slice(1);
  
  return {
    text: `Reading ${topicDisplay} Summary from ${dateStr}`,
    url: `/calendar/${date}#${topic}`
  };
}

// Simplified wrapper for historical events
function handleHistoricalEvent(event) {
  processEvent(event);
}

// Disable input and controls if viewing historical agent
if(isHistorical){
  form.style.display = 'none';
  // Add a notice that this is historical
  const notice = document.createElement('div');
  notice.style.cssText = 'background:#fff3cd;border:1px solid #ffeaa7;padding:0.75rem;margin:1rem;border-radius:4px;text-align:center;color:#856404;';
  notice.textContent = `Viewing historical agent run: ${fragment} (read-only)`;
  document.querySelector('.container').insertBefore(notice, messagesDiv);
  
  // Add activity indicator to messages div for historical view
  messagesDiv.appendChild(activityIndicator);
  
  loadHistoricalAgent(fragment);
} else {
  // Live mode - enable normal functionality
  document.getElementById('clearBtn').onclick=async()=>{
    await fetch(clearUrl,{method:'POST'});
    messagesDiv.innerHTML='';
    messagesDiv.appendChild(activityIndicator);  // Re-add activity indicator
    previousAgent = null;  // Reset agent tracking
    responseInProgress = false;  // Reset response state
    forceHideActivityIndicator();  // Ensure it's hidden
    input.focus();
  };

  backendSelect.addEventListener('change', async ()=>{
    await fetch(clearUrl,{method:'POST'});
    messagesDiv.innerHTML='';
    messagesDiv.appendChild(activityIndicator);  // Re-add activity indicator
    previousAgent = null;  // Reset agent tracking
    responseInProgress = false;  // Reset response state
    forceHideActivityIndicator();  // Ensure it's hidden
    input.focus();
  });

  appEvents.listen('chat', e => {
    // Keep activity indicator visible while events are coming
    if (responseInProgress) {
      showActivityIndicator();
    }
    
    // Use unified event processor
    processEvent(e);
    
    // Don't hide while response is in progress
    if (responseInProgress) {
      showActivityIndicator();
    }
  });

  loadHistory();
}
</script>
{% endblock %}

