{% extends 'base.html' %}
{% import 'macros.html' as macros %}
{% set active = 'calendar' %}
{% block head %}
<style>
.modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.5); }
.modal-content { background:white; margin:5% auto; padding:1em; border-radius:8px; max-width:600px; position:relative; }
.close { position:absolute; top:10px; right:15px; cursor:pointer; font-size:24px; }
.occ-field { margin-bottom:0.5em; }
.occ-field strong { display:inline-block; width:90px; }
.occ-desc { margin-top:0.5em; white-space:pre-wrap; }
</style>
{% endblock %}
{% block body %}
<div class="container">
  {{ macros.day_heading(title,
        prev_day and url_for('calendar.calendar_day', day=prev_day),
        next_day and url_for('calendar.calendar_day', day=next_day)) }}
  <div class="tabs">
    <a class="tab active" href="#events" data-target="events">Events</a>
    {% for file in files %}
    <a class="tab" href="#{{ file.topic }}" data-target="{{ file.topic }}" data-color="{{ file.color }}">{{ file.label }}</a>
    {% endfor %}
    <a class="admin-link" style="margin-left:0" href="{{ url_for('calendar.calendar_transcript_page', day=day) }}" title="Transcripts" aria-label="Transcripts">üìù</a>
    <a class="admin-link" href="{{ url_for('admin.admin_day_page', day=day) }}" title="Admin" aria-label="Admin">‚öôÔ∏è</a>
  </div>
  <div class="content" id="events">
    <div id="eventsView"></div>
  </div>
  {% for file in files %}
  <div class="content" id="{{ file.topic }}" style="display:none">
    <div class="markdown">{{ file.html|safe }}</div>
  </div>
  {% endfor %}
  <div id="eventModal" class="modal">
    <div class="modal-content">
      <span class="close">&times;</span>
      <div id="modalBody"></div>
    </div>
  </div>
</div>
<script src="{{ url_for('review.static', filename='colors.js') }}"></script>
<script>
let tabs = Array.from(document.querySelectorAll('.tab'));
const contents = document.querySelectorAll('.content');
const day = '{{ day }}';
let events = [];
const COLORS = window.CATEGORY_COLORS;
let topicColors = {};
// initialize colors from tab data
tabs.forEach(t => { if(t.dataset.color){ topicColors[t.dataset.target] = t.dataset.color; } });

function colorTabs(){
  tabs.forEach(t => {
    const color = topicColors[t.dataset.target];
    if(color){
      t.dataset.color = color;
      t.style.color = color;
    } else {
      t.style.color = '';
      delete t.dataset.color;
    }
  });
}

function orderTabs(topics){
  const container = document.querySelector('.tabs');
  const eventTab = container.querySelector('.tab[data-target="events"]');
  const admin = container.querySelector('.admin-link');
  const fileTabs = Array.from(container.querySelectorAll('.tab')).filter(t => t !== eventTab);
  const order = {};
  topics.forEach((s,i)=>{order[s]=i;});
  fileTabs.sort((a,b)=>{
    const sa = a.dataset.target;
    const sb = b.dataset.target;
    return (order[sa] ?? 999) - (order[sb] ?? 999);
  });
  container.innerHTML = '';
  container.appendChild(eventTab);
  fileTabs.forEach(t=>container.appendChild(t));
  if(admin) container.appendChild(admin);
  tabs = Array.from(container.querySelectorAll('.tab'));
}

function renderEvents(list){
  const div = document.getElementById('eventsView');
  if(!list.length){ div.innerHTML = ""; return []; }

  // determine time range
  let start = Infinity;
  let end = -Infinity;
  list.forEach((o, idx) => {
    if(!o.startTime) return;
    const s = new Date(o.startTime);
    const e = o.endTime ? new Date(o.endTime) : new Date(s.getTime() + 3600000);
    const startMinutes = s.getHours()*60 + s.getMinutes();
    // ignore events that happen at exactly midnight (noisy data)
    if(startMinutes === 0) return;
    start = Math.min(start, startMinutes);
    end = Math.max(end, e.getHours()*60 + e.getMinutes());
  });
  let startHour = Math.max(Math.floor(start/60) - 1, 0);
  let endHour = Math.min(Math.ceil(end/60) + 1, 24);

  const pxPerHour = 66.7;
  let html = `<div class='day-view' style='height:${(endHour-startHour)*pxPerHour}px'>`;
  for(let h=startHour; h<=endHour; h++){
    const label = h===0? '12am' : h<12? h+'am' : h===12? '12pm' : (h-12)+'pm';
    html += `<div class='hour-line' style='top:${((h-startHour)/(endHour-startHour))*100}%'><span>${label}</span></div>`;
  }

  // Process events and calculate overlapping groups
  const processedEvents = [];
  const topics = [];

  list.forEach((o, idx) => {
    if(!o.startTime) return;
    const start = new Date(o.startTime);
    const end = o.endTime ? new Date(o.endTime) : new Date(start.getTime()+5*60000);
    let s = start.getHours()*60 + start.getMinutes();
    let e = end.getHours()*60 + end.getMinutes();
    s = Math.max(s, startHour*60);
    e = Math.min(e, endHour*60);
    if(e <= s) return;

    const topic = o.topic || 'other';
    if(!topics.includes(topic)) topics.push(topic);

    processedEvents.push({
      startMinutes: s,
      endMinutes: e,
      topic: topic,
      title: escapeHtml(o.title || o.summary || topic),
      href: `${window.location.pathname}${topic ? '#' + topic : ''}`,
      index: idx
    });
  });

  // Group events by topic
  const eventsByTopic = {};
  topics.forEach(topic => {
    eventsByTopic[topic] = processedEvents.filter(e => e.topic === topic);
    // Sort events within each topic by start time
    eventsByTopic[topic].sort((a, b) => a.startMinutes - b.startMinutes);
  });

  // Calculate columns needed for each topic (based on overlaps within that topic)
  const topicColumnCounts = {};
  topics.forEach(topic => {
    const topicEvents = eventsByTopic[topic];
    const topicColumns = [];

    topicEvents.forEach(event => {
      // Find first available column within this topic
      let columnIndex = 0;
      while (columnIndex < topicColumns.length &&
             topicColumns[columnIndex].some(existing =>
               event.startMinutes < existing.endMinutes &&
               event.endMinutes > existing.startMinutes)) {
        columnIndex++;
      }

      if (columnIndex === topicColumns.length) {
        topicColumns.push([]);
      }

      topicColumns[columnIndex].push(event);
      event.slugColumn = columnIndex;
    });

    topicColumnCounts[topic] = topicColumns.length;
  });

  // Calculate global column positions for each topic
  let globalColumnOffset = 0;
  const topicColumnOffsets = {};
  topics.forEach(topic => {
    topicColumnOffsets[topic] = globalColumnOffset;
    globalColumnOffset += topicColumnCounts[topic];
  });

  const totalColumns = globalColumnOffset;
  const columnWidth = totalColumns > 0 ? 100 / totalColumns : 100;

  // Assign colors based on column order
  const sortedTopics = [...topics].sort((a,b)=>topicColumnOffsets[a]-topicColumnOffsets[b]);

  // Assign final column positions
  processedEvents.forEach(event => {
    event.column = topicColumnOffsets[event.topic] + event.slugColumn;
  });
  
  // Render events
  processedEvents.forEach(event => {
    const top = ((event.startMinutes - startHour*60)/((endHour-startHour)*60))*100;
    const height = Math.max((event.endMinutes - event.startMinutes)/((endHour-startHour)*60)*100, 0.4);
    const left = event.column * columnWidth;
    const width = columnWidth * 0.95; // Leave small gap between columns
    const color = topicColors[event.topic] || '#6c757d';
    html += `<a class='occ' data-index='${event.index}' href='${event.href}' style='top:${top}%;height:${height}%;left:${left}%;width:${width}%;right:auto;background:${color}' title='${event.title}'></a>`;
  });
  html += '</div>';
  div.innerHTML = html;
  return sortedTopics;
}

function escapeHtml(text){
  const d=document.createElement('div');
  d.textContent=text;
  return d.innerHTML;
}

function fmtTime(ts){
  const d = new Date(ts);
  let h = d.getHours();
  const m = d.getMinutes();
  const suf = h >= 12 ? 'p' : 'a';
  h = h % 12;
  if(h === 0) h = 12;
  return m ? `${h}:${String(m).padStart(2,'0')}${suf}` : `${h}${suf}`;
}

function fmtLength(start, end){
  const s = new Date(start);
  const e = end ? new Date(end) : new Date(s.getTime() + 5*60000);
  const mins = Math.max(1, Math.round((e - s)/60000));
  if(mins >= 60){
    const h = Math.floor(mins/60);
    const m = mins % 60;
    return m ? `${h}h ${m}m` : `${h}h`;
  }
  return `${mins}m`;
}

function openModal(idx){
  const occ = events[idx];
  if(!occ) return;
  const body = document.getElementById('modalBody');

  const topic = occ.topic ? occ.topic.charAt(0).toUpperCase()+occ.topic.slice(1) : '';
  const titleText = `${topic ? topic+': ' : ''}${occ.title || ''}`.trim();
  const subtitle = occ.subject || occ.summary || '';
  let html = '';
  if(titleText) html += `<h3>${escapeHtml(titleText)}</h3>`;
  if(subtitle) html += `<h4>${escapeHtml(subtitle)}</h4>`;
  if(occ.startTime){
    const when = fmtTime(occ.startTime);
    const len = fmtLength(occ.startTime, occ.endTime);
    html += `<div class="occ-field"><strong>Started</strong> ${when} - ${len}</div>`;
  }
  if(Array.isArray(occ.participants) && occ.participants.length>1){
    html += `<div class="occ-field"><strong>Participants</strong> ${escapeHtml(occ.participants.join(', '))}</div>`;
  }
  if(occ.details){
    let det = typeof occ.details==='string' ? occ.details : JSON.stringify(occ.details, null, 2);
    html += `<div class="occ-desc">${escapeHtml(det)}</div>`;
  }
  body.innerHTML = html;
  document.getElementById('eventModal').style.display='block';
}

function loadEvents(){
  fetch('{{ url_for('calendar.calendar_occurrences') }}')
    .then(r => r.json())
    .then(d => {
      events = d[day] || [];
      const topicsList = renderEvents(events);
      orderTabs(topicsList);
      colorTabs();
      document.getElementById('eventsView').onclick = e => {
        const el = e.target.closest('.occ');
        if(el){ e.preventDefault(); openModal(parseInt(el.dataset.index)); }
      };
    });
}

function showTab(id){
  tabs.forEach(x=>{x.classList.remove('active'); if(x.dataset.color) x.style.color=x.dataset.color;});
  contents.forEach(c=>c.style.display='none');
  const tab = document.querySelector(`.tab[data-target="${id}"]`);
  const content = document.getElementById(id);
  if(tab){
    tab.classList.add('active');
    if(tab.dataset.color) tab.style.color = tab.dataset.color;
  }
  if(content) content.style.display='block';
  if(history.replaceState){
    history.replaceState(null, '', '#' + id);
  } else {
    location.hash = '#' + id;
  }
}

tabs.forEach(t=>t.addEventListener('click', e=>{e.preventDefault();showTab(t.dataset.target);}));
const initial = location.hash.slice(1);
loadEvents();
if(initial && document.getElementById(initial)){
  showTab(initial);
} else {
  showTab('events');
}
document.querySelector('#eventModal .close').onclick = () => {
  document.getElementById('eventModal').style.display = 'none';
};
window.onclick = e => {
  const modal = document.getElementById('eventModal');
  if(e.target === modal) modal.style.display = 'none';
};
</script>
{% endblock %}
